{"version":3,"file":"music-7lJ0S_-M.js","names":["concept: AlbumConcept"],"sources":["../../src/services/music.ts"],"sourcesContent":["import { supabase } from '@/lib/supabase/client'\nimport { Database } from '@/lib/supabase/types'\nimport { Playlist, PlaylistTrack, AlbumConcept } from '@/types'\n\ntype MusicTrack = Database['public']['Tables']['music_tracks']['Row']\ntype MusicTrackInsert = Database['public']['Tables']['music_tracks']['Insert']\ntype MusicTrackUpdate = Database['public']['Tables']['music_tracks']['Update']\n\n// Tracks\nexport const getMusicTracks = async () => {\n  const { data, error } = await supabase\n    .from('music_tracks')\n    .select('*')\n    .order('created_at', { ascending: false })\n\n  if (error) {\n    console.error('Error fetching music tracks:', error)\n    return []\n  }\n\n  return (data as MusicTrack[]) || []\n}\n\nexport const getTracksPaginated = async (\n  page: number = 1,\n  limit: number = 10,\n  search: string = '',\n) => {\n  const from = (page - 1) * limit\n  const to = from + limit - 1\n\n  let query = supabase\n    .from('music_tracks')\n    .select('*', { count: 'exact' })\n    .order('created_at', { ascending: false })\n\n  if (search) {\n    query = query.ilike('title', `%${search}%`)\n  }\n\n  const { data, error, count } = await query.range(from, to)\n\n  if (error) {\n    console.error('Error fetching paginated tracks:', error)\n    return {\n      data: [],\n      count: 0,\n      totalPages: 0,\n    }\n  }\n\n  return {\n    data: (data as MusicTrack[]) || [],\n    count: count || 0,\n    totalPages: count ? Math.ceil(count / limit) : 0,\n  }\n}\n\nexport const createTrack = async (track: MusicTrackInsert) => {\n  const { data, error } = await supabase\n    .from('music_tracks')\n    .insert(track)\n    .select()\n    .single()\n\n  if (error) throw error\n  return data\n}\n\nexport const updateTrack = async (id: string, updates: MusicTrackUpdate) => {\n  const { data, error } = await supabase\n    .from('music_tracks')\n    .update(updates)\n    .eq('id', id)\n    .select()\n    .single()\n\n  if (error) throw error\n  return data\n}\n\nexport const deleteTrack = async (id: string) => {\n  const { error } = await supabase.from('music_tracks').delete().eq('id', id)\n\n  if (error) throw error\n  return true\n}\n\n// Album Concept\nexport const getAlbumConcept = async () => {\n  // Using 'as any' for table name because types might be outdated immediately after migration\n  const { data, error } = await supabase\n    .from('album_settings' as any)\n    .select('*')\n    .limit(1)\n    .maybeSingle()\n\n  if (error) {\n    console.error('Error fetching album concept:', error)\n    return null\n  }\n\n  if (!data) return null\n\n  // Map flat DB structure to nested AlbumConcept structure\n  const row = data as any\n\n  const concept: AlbumConcept = {\n    title: {\n      en: row.title_en || '',\n      pt: row.title_pt || '',\n      ko: row.title_ko || '',\n    },\n    description: {\n      en: row.description_en || '',\n      pt: row.description_pt || '',\n      ko: row.description_ko || '',\n    },\n    cover_url: row.image_url,\n    video_url: null, // Video URL is not present in the new schema\n  }\n\n  return concept\n}\n\n// Playlists\nexport const getPlaylists = async () => {\n  const { data, error } = await supabase\n    .from('playlists')\n    .select('*')\n    .order('created_at', { ascending: false })\n\n  if (error) {\n    console.error('Error fetching playlists:', error)\n    return []\n  }\n\n  return (data as Playlist[]) || []\n}\n\nexport const createPlaylist = async (playlist: Partial<Playlist>) => {\n  const { data, error } = await supabase\n    .from('playlists')\n    .insert(playlist)\n    .select()\n    .single()\n\n  if (error) throw error\n  return data\n}\n\nexport const updatePlaylist = async (\n  id: string,\n  updates: Partial<Playlist>,\n) => {\n  const { data, error } = await supabase\n    .from('playlists')\n    .update(updates)\n    .eq('id', id)\n    .select()\n    .single()\n\n  if (error) throw error\n  return data\n}\n\nexport const deletePlaylist = async (id: string) => {\n  const { error } = await supabase.from('playlists').delete().eq('id', id)\n\n  if (error) throw error\n  return true\n}\n\n// Playlist Tracks\nexport const getPlaylistTracks = async (playlistId: string) => {\n  const { data, error } = await supabase\n    .from('playlist_tracks')\n    .select('*, track:music_tracks(*)')\n    .eq('playlist_id', playlistId)\n    .order('order_index', { ascending: true })\n\n  if (error) {\n    console.error('Error fetching playlist tracks:', error)\n    return []\n  }\n  return (data as unknown as PlaylistTrack[]) || []\n}\n\nexport const addTrackToPlaylist = async (\n  playlistId: string,\n  trackId: string,\n  orderIndex: number = 0,\n) => {\n  const { data, error } = await supabase\n    .from('playlist_tracks')\n    .insert({\n      playlist_id: playlistId,\n      track_id: trackId,\n      order_index: orderIndex,\n    })\n    .select()\n    .single()\n\n  if (error) throw error\n  return data\n}\n\nexport const removeTrackFromPlaylist = async (\n  playlistId: string,\n  trackId: string,\n) => {\n  const { error } = await supabase\n    .from('playlist_tracks')\n    .delete()\n    .match({ playlist_id: playlistId, track_id: trackId })\n\n  if (error) throw error\n  return true\n}\n"],"mappings":"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"}