import { n as MessageSquare, t as Users } from "./users-qcnhYtYp.js";
import { t as Plus } from "./plus-Dr1QuA1C.js";
import { Et as Link, Ft as __export, It as __toESM, K as Music, Nt as require_react, Pt as __commonJSMin, V as cn, at as createLucideIcon, it as BookOpen, k as supabase, st as clsx_default, v as Button, xt as require_jsx_runtime } from "./index-BeLE7zEg.js";
import { a as CardHeader, n as CardContent, o as CardTitle, r as CardDescription, t as Card } from "./card-Do66fycf.js";
var Activity = createLucideIcon("activity", [["path", {
	d: "M22 12h-2.48a2 2 0 0 0-1.93 1.46l-2.35 8.36a.25.25 0 0 1-.48 0L9.24 2.18a.25.25 0 0 0-.48 0l-2.35 8.36A2 2 0 0 1 4.49 12H2",
	key: "169zse"
}]]);
var require_isArray = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = Array.isArray;
}));
var require__freeGlobal = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = typeof global == "object" && global && global.Object === Object && global;
}));
var require__root = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var freeGlobal$1 = require__freeGlobal();
	var freeSelf = typeof self == "object" && self && self.Object === Object && self;
	module.exports = freeGlobal$1 || freeSelf || Function("return this")();
}));
var require__Symbol = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__root().Symbol;
}));
var require__getRawTag = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Symbol$6 = require__Symbol();
	var objectProto$4 = Object.prototype;
	var hasOwnProperty$11 = objectProto$4.hasOwnProperty;
	var nativeObjectToString$1 = objectProto$4.toString;
	var symToStringTag$1 = Symbol$6 ? Symbol$6.toStringTag : void 0;
	function getRawTag$1(value) {
		var isOwn = hasOwnProperty$11.call(value, symToStringTag$1), tag = value[symToStringTag$1];
		try {
			value[symToStringTag$1] = void 0;
			var unmasked = true;
		} catch (e) {}
		var result = nativeObjectToString$1.call(value);
		if (unmasked) if (isOwn) value[symToStringTag$1] = tag;
		else delete value[symToStringTag$1];
		return result;
	}
	module.exports = getRawTag$1;
}));
var require__objectToString = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var nativeObjectToString = Object.prototype.toString;
	function objectToString$1(value) {
		return nativeObjectToString.call(value);
	}
	module.exports = objectToString$1;
}));
var require__baseGetTag = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Symbol$5 = require__Symbol(), getRawTag = require__getRawTag(), objectToString = require__objectToString();
	var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
	var symToStringTag = Symbol$5 ? Symbol$5.toStringTag : void 0;
	function baseGetTag$9(value) {
		if (value == null) return value === void 0 ? undefinedTag : nullTag;
		return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
	}
	module.exports = baseGetTag$9;
}));
var require_isObjectLike = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function isObjectLike$9(value) {
		return value != null && typeof value == "object";
	}
	module.exports = isObjectLike$9;
}));
var require_isSymbol = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseGetTag$8 = require__baseGetTag(), isObjectLike$8 = require_isObjectLike();
	var symbolTag$1 = "[object Symbol]";
	function isSymbol$6(value) {
		return typeof value == "symbol" || isObjectLike$8(value) && baseGetTag$8(value) == symbolTag$1;
	}
	module.exports = isSymbol$6;
}));
var require__isKey = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isArray$13 = require_isArray(), isSymbol$5 = require_isSymbol();
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
	function isKey$3(value, object) {
		if (isArray$13(value)) return false;
		var type = typeof value;
		if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol$5(value)) return true;
		return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
	}
	module.exports = isKey$3;
}));
var require_isObject = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function isObject$11(value) {
		var type = typeof value;
		return value != null && (type == "object" || type == "function");
	}
	module.exports = isObject$11;
}));
var require_isFunction = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseGetTag$7 = require__baseGetTag(), isObject$10 = require_isObject();
	var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
	function isFunction$19(value) {
		if (!isObject$10(value)) return false;
		var tag = baseGetTag$7(value);
		return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
	}
	module.exports = isFunction$19;
}));
var require__coreJsData = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__root()["__core-js_shared__"];
}));
var require__isMasked = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var coreJsData = require__coreJsData();
	var maskSrcKey = function() {
		var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
		return uid ? "Symbol(src)_1." + uid : "";
	}();
	function isMasked$1(func) {
		return !!maskSrcKey && maskSrcKey in func;
	}
	module.exports = isMasked$1;
}));
var require__toSource = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var funcToString$2 = Function.prototype.toString;
	function toSource$2(func) {
		if (func != null) {
			try {
				return funcToString$2.call(func);
			} catch (e) {}
			try {
				return func + "";
			} catch (e) {}
		}
		return "";
	}
	module.exports = toSource$2;
}));
var require__baseIsNative = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isFunction$18 = require_isFunction(), isMasked = require__isMasked(), isObject$9 = require_isObject(), toSource$1 = require__toSource();
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
	var reIsHostCtor = /^\[object .+?Constructor\]$/;
	var funcProto$1 = Function.prototype, objectProto$3 = Object.prototype;
	var funcToString$1 = funcProto$1.toString;
	var hasOwnProperty$10 = objectProto$3.hasOwnProperty;
	var reIsNative = RegExp("^" + funcToString$1.call(hasOwnProperty$10).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
	function baseIsNative$1(value) {
		if (!isObject$9(value) || isMasked(value)) return false;
		return (isFunction$18(value) ? reIsNative : reIsHostCtor).test(toSource$1(value));
	}
	module.exports = baseIsNative$1;
}));
var require__getValue = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function getValue$1(object, key) {
		return object == null ? void 0 : object[key];
	}
	module.exports = getValue$1;
}));
var require__getNative = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseIsNative = require__baseIsNative(), getValue = require__getValue();
	function getNative$1(object, key) {
		var value = getValue(object, key);
		return baseIsNative(value) ? value : void 0;
	}
	module.exports = getNative$1;
}));
var require__nativeCreate = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__getNative()(Object, "create");
}));
var require__hashClear = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var nativeCreate$3 = require__nativeCreate();
	function hashClear$1() {
		this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
		this.size = 0;
	}
	module.exports = hashClear$1;
}));
var require__hashDelete = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function hashDelete$1(key) {
		var result = this.has(key) && delete this.__data__[key];
		this.size -= result ? 1 : 0;
		return result;
	}
	module.exports = hashDelete$1;
}));
var require__hashGet = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var nativeCreate$2 = require__nativeCreate();
	var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
	var hasOwnProperty$9 = Object.prototype.hasOwnProperty;
	function hashGet$1(key) {
		var data = this.__data__;
		if (nativeCreate$2) {
			var result = data[key];
			return result === HASH_UNDEFINED$2 ? void 0 : result;
		}
		return hasOwnProperty$9.call(data, key) ? data[key] : void 0;
	}
	module.exports = hashGet$1;
}));
var require__hashHas = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var nativeCreate$1 = require__nativeCreate();
	var hasOwnProperty$8 = Object.prototype.hasOwnProperty;
	function hashHas$1(key) {
		var data = this.__data__;
		return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$8.call(data, key);
	}
	module.exports = hashHas$1;
}));
var require__hashSet = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var nativeCreate = require__nativeCreate();
	var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
	function hashSet$1(key, value) {
		var data = this.__data__;
		this.size += this.has(key) ? 0 : 1;
		data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
		return this;
	}
	module.exports = hashSet$1;
}));
var require__Hash = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var hashClear = require__hashClear(), hashDelete = require__hashDelete(), hashGet = require__hashGet(), hashHas = require__hashHas(), hashSet = require__hashSet();
	function Hash$1(entries) {
		var index = -1, length = entries == null ? 0 : entries.length;
		this.clear();
		while (++index < length) {
			var entry = entries[index];
			this.set(entry[0], entry[1]);
		}
	}
	Hash$1.prototype.clear = hashClear;
	Hash$1.prototype["delete"] = hashDelete;
	Hash$1.prototype.get = hashGet;
	Hash$1.prototype.has = hashHas;
	Hash$1.prototype.set = hashSet;
	module.exports = Hash$1;
}));
var require__listCacheClear = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function listCacheClear$1() {
		this.__data__ = [];
		this.size = 0;
	}
	module.exports = listCacheClear$1;
}));
var require_eq = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function eq$3(value, other) {
		return value === other || value !== value && other !== other;
	}
	module.exports = eq$3;
}));
var require__assocIndexOf = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var eq$2 = require_eq();
	function assocIndexOf$4(array, key) {
		var length = array.length;
		while (length--) if (eq$2(array[length][0], key)) return length;
		return -1;
	}
	module.exports = assocIndexOf$4;
}));
var require__listCacheDelete = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var assocIndexOf$3 = require__assocIndexOf();
	var splice = Array.prototype.splice;
	function listCacheDelete$1(key) {
		var data = this.__data__, index = assocIndexOf$3(data, key);
		if (index < 0) return false;
		if (index == data.length - 1) data.pop();
		else splice.call(data, index, 1);
		--this.size;
		return true;
	}
	module.exports = listCacheDelete$1;
}));
var require__listCacheGet = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var assocIndexOf$2 = require__assocIndexOf();
	function listCacheGet$1(key) {
		var data = this.__data__, index = assocIndexOf$2(data, key);
		return index < 0 ? void 0 : data[index][1];
	}
	module.exports = listCacheGet$1;
}));
var require__listCacheHas = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var assocIndexOf$1 = require__assocIndexOf();
	function listCacheHas$1(key) {
		return assocIndexOf$1(this.__data__, key) > -1;
	}
	module.exports = listCacheHas$1;
}));
var require__listCacheSet = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var assocIndexOf = require__assocIndexOf();
	function listCacheSet$1(key, value) {
		var data = this.__data__, index = assocIndexOf(data, key);
		if (index < 0) {
			++this.size;
			data.push([key, value]);
		} else data[index][1] = value;
		return this;
	}
	module.exports = listCacheSet$1;
}));
var require__ListCache = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var listCacheClear = require__listCacheClear(), listCacheDelete = require__listCacheDelete(), listCacheGet = require__listCacheGet(), listCacheHas = require__listCacheHas(), listCacheSet = require__listCacheSet();
	function ListCache$4(entries) {
		var index = -1, length = entries == null ? 0 : entries.length;
		this.clear();
		while (++index < length) {
			var entry = entries[index];
			this.set(entry[0], entry[1]);
		}
	}
	ListCache$4.prototype.clear = listCacheClear;
	ListCache$4.prototype["delete"] = listCacheDelete;
	ListCache$4.prototype.get = listCacheGet;
	ListCache$4.prototype.has = listCacheHas;
	ListCache$4.prototype.set = listCacheSet;
	module.exports = ListCache$4;
}));
var require__Map = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__getNative()(require__root(), "Map");
}));
var require__mapCacheClear = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Hash = require__Hash(), ListCache$3 = require__ListCache(), Map$3 = require__Map();
	function mapCacheClear$1() {
		this.size = 0;
		this.__data__ = {
			"hash": new Hash(),
			"map": new (Map$3 || ListCache$3)(),
			"string": new Hash()
		};
	}
	module.exports = mapCacheClear$1;
}));
var require__isKeyable = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function isKeyable$1(value) {
		var type = typeof value;
		return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
	}
	module.exports = isKeyable$1;
}));
var require__getMapData = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isKeyable = require__isKeyable();
	function getMapData$4(map$4, key) {
		var data = map$4.__data__;
		return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
	}
	module.exports = getMapData$4;
}));
var require__mapCacheDelete = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var getMapData$3 = require__getMapData();
	function mapCacheDelete$1(key) {
		var result = getMapData$3(this, key)["delete"](key);
		this.size -= result ? 1 : 0;
		return result;
	}
	module.exports = mapCacheDelete$1;
}));
var require__mapCacheGet = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var getMapData$2 = require__getMapData();
	function mapCacheGet$1(key) {
		return getMapData$2(this, key).get(key);
	}
	module.exports = mapCacheGet$1;
}));
var require__mapCacheHas = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var getMapData$1 = require__getMapData();
	function mapCacheHas$1(key) {
		return getMapData$1(this, key).has(key);
	}
	module.exports = mapCacheHas$1;
}));
var require__mapCacheSet = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var getMapData = require__getMapData();
	function mapCacheSet$1(key, value) {
		var data = getMapData(this, key), size = data.size;
		data.set(key, value);
		this.size += data.size == size ? 0 : 1;
		return this;
	}
	module.exports = mapCacheSet$1;
}));
var require__MapCache = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var mapCacheClear = require__mapCacheClear(), mapCacheDelete = require__mapCacheDelete(), mapCacheGet = require__mapCacheGet(), mapCacheHas = require__mapCacheHas(), mapCacheSet = require__mapCacheSet();
	function MapCache$3(entries) {
		var index = -1, length = entries == null ? 0 : entries.length;
		this.clear();
		while (++index < length) {
			var entry = entries[index];
			this.set(entry[0], entry[1]);
		}
	}
	MapCache$3.prototype.clear = mapCacheClear;
	MapCache$3.prototype["delete"] = mapCacheDelete;
	MapCache$3.prototype.get = mapCacheGet;
	MapCache$3.prototype.has = mapCacheHas;
	MapCache$3.prototype.set = mapCacheSet;
	module.exports = MapCache$3;
}));
var require_memoize = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var MapCache$2 = require__MapCache();
	var FUNC_ERROR_TEXT$2 = "Expected a function";
	function memoize$3(func, resolver) {
		if (typeof func != "function" || resolver != null && typeof resolver != "function") throw new TypeError(FUNC_ERROR_TEXT$2);
		var memoized = function() {
			var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
			if (cache.has(key)) return cache.get(key);
			var result = func.apply(this, args);
			memoized.cache = cache.set(key, result) || cache;
			return result;
		};
		memoized.cache = new (memoize$3.Cache || MapCache$2)();
		return memoized;
	}
	memoize$3.Cache = MapCache$2;
	module.exports = memoize$3;
}));
var require__memoizeCapped = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var memoize$2 = require_memoize();
	var MAX_MEMOIZE_SIZE = 500;
	function memoizeCapped$1(func) {
		var result = memoize$2(func, function(key) {
			if (cache.size === MAX_MEMOIZE_SIZE) cache.clear();
			return key;
		});
		var cache = result.cache;
		return result;
	}
	module.exports = memoizeCapped$1;
}));
var require__stringToPath = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var memoizeCapped = require__memoizeCapped();
	var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
	var reEscapeChar = /\\(\\)?/g;
	module.exports = memoizeCapped(function(string) {
		var result = [];
		if (string.charCodeAt(0) === 46) result.push("");
		string.replace(rePropName, function(match, number$3, quote, subString) {
			result.push(quote ? subString.replace(reEscapeChar, "$1") : number$3 || match);
		});
		return result;
	});
}));
var require__arrayMap = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function arrayMap$3(array, iteratee) {
		var index = -1, length = array == null ? 0 : array.length, result = Array(length);
		while (++index < length) result[index] = iteratee(array[index], index, array);
		return result;
	}
	module.exports = arrayMap$3;
}));
var require__baseToString = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Symbol$4 = require__Symbol(), arrayMap$2 = require__arrayMap(), isArray$12 = require_isArray(), isSymbol$4 = require_isSymbol();
	var INFINITY$2 = Infinity;
	var symbolProto$1 = Symbol$4 ? Symbol$4.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
	function baseToString$1(value) {
		if (typeof value == "string") return value;
		if (isArray$12(value)) return arrayMap$2(value, baseToString$1) + "";
		if (isSymbol$4(value)) return symbolToString ? symbolToString.call(value) : "";
		var result = value + "";
		return result == "0" && 1 / value == -INFINITY$2 ? "-0" : result;
	}
	module.exports = baseToString$1;
}));
var require_toString = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseToString = require__baseToString();
	function toString$3(value) {
		return value == null ? "" : baseToString(value);
	}
	module.exports = toString$3;
}));
var require__castPath = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isArray$11 = require_isArray(), isKey$2 = require__isKey(), stringToPath = require__stringToPath(), toString$2 = require_toString();
	function castPath$2(value, object) {
		if (isArray$11(value)) return value;
		return isKey$2(value, object) ? [value] : stringToPath(toString$2(value));
	}
	module.exports = castPath$2;
}));
var require__toKey = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isSymbol$3 = require_isSymbol();
	var INFINITY$1 = Infinity;
	function toKey$4(value) {
		if (typeof value == "string" || isSymbol$3(value)) return value;
		var result = value + "";
		return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
	}
	module.exports = toKey$4;
}));
var require__baseGet = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var castPath$1 = require__castPath(), toKey$3 = require__toKey();
	function baseGet$3(object, path$1) {
		path$1 = castPath$1(path$1, object);
		var index = 0, length = path$1.length;
		while (object != null && index < length) object = object[toKey$3(path$1[index++])];
		return index && index == length ? object : void 0;
	}
	module.exports = baseGet$3;
}));
var require_get = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseGet$2 = require__baseGet();
	function get$6(object, path$1, defaultValue) {
		var result = object == null ? void 0 : baseGet$2(object, path$1);
		return result === void 0 ? defaultValue : result;
	}
	module.exports = get$6;
}));
var require_isNil = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function isNil$10(value) {
		return value == null;
	}
	module.exports = isNil$10;
}));
var require_isString = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseGetTag$6 = require__baseGetTag(), isArray$10 = require_isArray(), isObjectLike$7 = require_isObjectLike();
	var stringTag$2 = "[object String]";
	function isString$3(value) {
		return typeof value == "string" || !isArray$10(value) && isObjectLike$7(value) && baseGetTag$6(value) == stringTag$2;
	}
	module.exports = isString$3;
}));
/**
* @license React
* react-is.development.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var require_react_is_development$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	(function() {
		"use strict";
		var REACT_ELEMENT_TYPE = Symbol.for("react.element");
		var REACT_PORTAL_TYPE = Symbol.for("react.portal");
		var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
		var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
		var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
		var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
		var REACT_CONTEXT_TYPE = Symbol.for("react.context");
		var REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context");
		var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
		var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
		var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
		var REACT_MEMO_TYPE = Symbol.for("react.memo");
		var REACT_LAZY_TYPE = Symbol.for("react.lazy");
		var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
		var enableScopeAPI = false;
		var enableCacheElement = false;
		var enableTransitionTracing = false;
		var enableLegacyHidden = false;
		var enableDebugTracing = false;
		var REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
		function isValidElementType(type) {
			if (typeof type === "string" || typeof type === "function") return true;
			if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) return true;
			if (typeof type === "object" && type !== null) {
				if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) return true;
			}
			return false;
		}
		function typeOf(object) {
			if (typeof object === "object" && object !== null) {
				var $$typeof = object.$$typeof;
				switch ($$typeof) {
					case REACT_ELEMENT_TYPE:
						var type = object.type;
						switch (type) {
							case REACT_FRAGMENT_TYPE:
							case REACT_PROFILER_TYPE:
							case REACT_STRICT_MODE_TYPE:
							case REACT_SUSPENSE_TYPE:
							case REACT_SUSPENSE_LIST_TYPE: return type;
							default:
								var $$typeofType = type && type.$$typeof;
								switch ($$typeofType) {
									case REACT_SERVER_CONTEXT_TYPE:
									case REACT_CONTEXT_TYPE:
									case REACT_FORWARD_REF_TYPE:
									case REACT_LAZY_TYPE:
									case REACT_MEMO_TYPE:
									case REACT_PROVIDER_TYPE: return $$typeofType;
									default: return $$typeof;
								}
						}
					case REACT_PORTAL_TYPE: return $$typeof;
				}
			}
		}
		var ContextConsumer = REACT_CONTEXT_TYPE;
		var ContextProvider = REACT_PROVIDER_TYPE;
		var Element = REACT_ELEMENT_TYPE;
		var ForwardRef = REACT_FORWARD_REF_TYPE;
		var Fragment = REACT_FRAGMENT_TYPE;
		var Lazy = REACT_LAZY_TYPE;
		var Memo = REACT_MEMO_TYPE;
		var Portal = REACT_PORTAL_TYPE;
		var Profiler = REACT_PROFILER_TYPE;
		var StrictMode = REACT_STRICT_MODE_TYPE;
		var Suspense = REACT_SUSPENSE_TYPE;
		var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
		var hasWarnedAboutDeprecatedIsAsyncMode = false;
		var hasWarnedAboutDeprecatedIsConcurrentMode = false;
		function isAsyncMode(object) {
			if (!hasWarnedAboutDeprecatedIsAsyncMode) {
				hasWarnedAboutDeprecatedIsAsyncMode = true;
				console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
			}
			return false;
		}
		function isConcurrentMode(object) {
			if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
				hasWarnedAboutDeprecatedIsConcurrentMode = true;
				console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
			}
			return false;
		}
		function isContextConsumer(object) {
			return typeOf(object) === REACT_CONTEXT_TYPE;
		}
		function isContextProvider(object) {
			return typeOf(object) === REACT_PROVIDER_TYPE;
		}
		function isElement(object) {
			return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
		}
		function isForwardRef(object) {
			return typeOf(object) === REACT_FORWARD_REF_TYPE;
		}
		function isFragment$1(object) {
			return typeOf(object) === REACT_FRAGMENT_TYPE;
		}
		function isLazy(object) {
			return typeOf(object) === REACT_LAZY_TYPE;
		}
		function isMemo(object) {
			return typeOf(object) === REACT_MEMO_TYPE;
		}
		function isPortal(object) {
			return typeOf(object) === REACT_PORTAL_TYPE;
		}
		function isProfiler(object) {
			return typeOf(object) === REACT_PROFILER_TYPE;
		}
		function isStrictMode(object) {
			return typeOf(object) === REACT_STRICT_MODE_TYPE;
		}
		function isSuspense(object) {
			return typeOf(object) === REACT_SUSPENSE_TYPE;
		}
		function isSuspenseList(object) {
			return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
		}
		exports.ContextConsumer = ContextConsumer;
		exports.ContextProvider = ContextProvider;
		exports.Element = Element;
		exports.ForwardRef = ForwardRef;
		exports.Fragment = Fragment;
		exports.Lazy = Lazy;
		exports.Memo = Memo;
		exports.Portal = Portal;
		exports.Profiler = Profiler;
		exports.StrictMode = StrictMode;
		exports.Suspense = Suspense;
		exports.SuspenseList = SuspenseList;
		exports.isAsyncMode = isAsyncMode;
		exports.isConcurrentMode = isConcurrentMode;
		exports.isContextConsumer = isContextConsumer;
		exports.isContextProvider = isContextProvider;
		exports.isElement = isElement;
		exports.isForwardRef = isForwardRef;
		exports.isFragment = isFragment$1;
		exports.isLazy = isLazy;
		exports.isMemo = isMemo;
		exports.isPortal = isPortal;
		exports.isProfiler = isProfiler;
		exports.isStrictMode = isStrictMode;
		exports.isSuspense = isSuspense;
		exports.isSuspenseList = isSuspenseList;
		exports.isValidElementType = isValidElementType;
		exports.typeOf = typeOf;
	})();
}));
var require_react_is$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require_react_is_development$1();
}));
var require_isNumber = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseGetTag$5 = require__baseGetTag(), isObjectLike$6 = require_isObjectLike();
	var numberTag$2 = "[object Number]";
	function isNumber$2(value) {
		return typeof value == "number" || isObjectLike$6(value) && baseGetTag$5(value) == numberTag$2;
	}
	module.exports = isNumber$2;
}));
var require_isNaN = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isNumber$1 = require_isNumber();
	function isNaN$1(value) {
		return isNumber$1(value) && value != +value;
	}
	module.exports = isNaN$1;
}));
var import_isString$2 = /* @__PURE__ */ __toESM(require_isString());
var import_isNaN$1 = /* @__PURE__ */ __toESM(require_isNaN());
var import_get$4 = /* @__PURE__ */ __toESM(require_get());
var import_isNumber = /* @__PURE__ */ __toESM(require_isNumber());
var import_isNil$9 = /* @__PURE__ */ __toESM(require_isNil());
var mathSign = function mathSign$1(value) {
	if (value === 0) return 0;
	if (value > 0) return 1;
	return -1;
};
var isPercent = function isPercent$1(value) {
	return (0, import_isString$2.default)(value) && value.indexOf("%") === value.length - 1;
};
var isNumber = function isNumber$3(value) {
	return (0, import_isNumber.default)(value) && !(0, import_isNaN$1.default)(value);
};
var isNullish = function isNullish$1(value) {
	return (0, import_isNil$9.default)(value);
};
var isNumOrStr = function isNumOrStr$1(value) {
	return isNumber(value) || (0, import_isString$2.default)(value);
};
var idCounter = 0;
var uniqueId = function uniqueId$1(prefix$2) {
	var id = ++idCounter;
	return "".concat(prefix$2 || "").concat(id);
};
var getPercentValue = function getPercentValue$1(percent, totalValue) {
	var defaultValue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
	var validate = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
	if (!isNumber(percent) && !(0, import_isString$2.default)(percent)) return defaultValue;
	var value;
	if (isPercent(percent)) {
		var index = percent.indexOf("%");
		value = totalValue * parseFloat(percent.slice(0, index)) / 100;
	} else value = +percent;
	if ((0, import_isNaN$1.default)(value)) value = defaultValue;
	if (validate && value > totalValue) value = totalValue;
	return value;
};
var getAnyElementOfObject = function getAnyElementOfObject$1(obj) {
	if (!obj) return null;
	var keys$6 = Object.keys(obj);
	if (keys$6 && keys$6.length) return obj[keys$6[0]];
	return null;
};
var hasDuplicate = function hasDuplicate$1(ary) {
	if (!Array.isArray(ary)) return false;
	var len = ary.length;
	var cache = {};
	for (var i = 0; i < len; i++) if (!cache[ary[i]]) cache[ary[i]] = true;
	else return true;
	return false;
};
var interpolateNumber = function interpolateNumber$2(numberA, numberB) {
	if (isNumber(numberA) && isNumber(numberB)) return function(t) {
		return numberA + t * (numberB - numberA);
	};
	return function() {
		return numberB;
	};
};
function findEntryInArray(ary, specifiedKey, specifiedValue) {
	if (!ary || !ary.length) return null;
	return ary.find(function(entry) {
		return entry && (typeof specifiedKey === "function" ? specifiedKey(entry) : (0, import_get$4.default)(entry, specifiedKey)) === specifiedValue;
	});
}
var compareValues = function compareValues$1(a$1, b) {
	if (isNumber(a$1) && isNumber(b)) return a$1 - b;
	if ((0, import_isString$2.default)(a$1) && (0, import_isString$2.default)(b)) return a$1.localeCompare(b);
	if (a$1 instanceof Date && b instanceof Date) return a$1.getTime() - b.getTime();
	return String(a$1).localeCompare(String(b));
};
function shallowEqual(a$1, b) {
	for (var key in a$1) if ({}.hasOwnProperty.call(a$1, key) && (!{}.hasOwnProperty.call(b, key) || a$1[key] !== b[key])) return false;
	for (var _key in b) if ({}.hasOwnProperty.call(b, _key) && !{}.hasOwnProperty.call(a$1, _key)) return false;
	return true;
}
var import_react = /* @__PURE__ */ __toESM(require_react());
var import_isObject$3 = /* @__PURE__ */ __toESM(require_isObject());
function _typeof$43(o) {
	"@babel/helpers - typeof";
	return _typeof$43 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$43(o);
}
var SVGContainerPropKeys = ["viewBox", "children"];
var SVGElementPropKeys = [
	"aria-activedescendant",
	"aria-atomic",
	"aria-autocomplete",
	"aria-busy",
	"aria-checked",
	"aria-colcount",
	"aria-colindex",
	"aria-colspan",
	"aria-controls",
	"aria-current",
	"aria-describedby",
	"aria-details",
	"aria-disabled",
	"aria-errormessage",
	"aria-expanded",
	"aria-flowto",
	"aria-haspopup",
	"aria-hidden",
	"aria-invalid",
	"aria-keyshortcuts",
	"aria-label",
	"aria-labelledby",
	"aria-level",
	"aria-live",
	"aria-modal",
	"aria-multiline",
	"aria-multiselectable",
	"aria-orientation",
	"aria-owns",
	"aria-placeholder",
	"aria-posinset",
	"aria-pressed",
	"aria-readonly",
	"aria-relevant",
	"aria-required",
	"aria-roledescription",
	"aria-rowcount",
	"aria-rowindex",
	"aria-rowspan",
	"aria-selected",
	"aria-setsize",
	"aria-sort",
	"aria-valuemax",
	"aria-valuemin",
	"aria-valuenow",
	"aria-valuetext",
	"className",
	"color",
	"height",
	"id",
	"lang",
	"max",
	"media",
	"method",
	"min",
	"name",
	"style",
	"target",
	"width",
	"role",
	"tabIndex",
	"accentHeight",
	"accumulate",
	"additive",
	"alignmentBaseline",
	"allowReorder",
	"alphabetic",
	"amplitude",
	"arabicForm",
	"ascent",
	"attributeName",
	"attributeType",
	"autoReverse",
	"azimuth",
	"baseFrequency",
	"baselineShift",
	"baseProfile",
	"bbox",
	"begin",
	"bias",
	"by",
	"calcMode",
	"capHeight",
	"clip",
	"clipPath",
	"clipPathUnits",
	"clipRule",
	"colorInterpolation",
	"colorInterpolationFilters",
	"colorProfile",
	"colorRendering",
	"contentScriptType",
	"contentStyleType",
	"cursor",
	"cx",
	"cy",
	"d",
	"decelerate",
	"descent",
	"diffuseConstant",
	"direction",
	"display",
	"divisor",
	"dominantBaseline",
	"dur",
	"dx",
	"dy",
	"edgeMode",
	"elevation",
	"enableBackground",
	"end",
	"exponent",
	"externalResourcesRequired",
	"fill",
	"fillOpacity",
	"fillRule",
	"filter",
	"filterRes",
	"filterUnits",
	"floodColor",
	"floodOpacity",
	"focusable",
	"fontFamily",
	"fontSize",
	"fontSizeAdjust",
	"fontStretch",
	"fontStyle",
	"fontVariant",
	"fontWeight",
	"format",
	"from",
	"fx",
	"fy",
	"g1",
	"g2",
	"glyphName",
	"glyphOrientationHorizontal",
	"glyphOrientationVertical",
	"glyphRef",
	"gradientTransform",
	"gradientUnits",
	"hanging",
	"horizAdvX",
	"horizOriginX",
	"href",
	"ideographic",
	"imageRendering",
	"in2",
	"in",
	"intercept",
	"k1",
	"k2",
	"k3",
	"k4",
	"k",
	"kernelMatrix",
	"kernelUnitLength",
	"kerning",
	"keyPoints",
	"keySplines",
	"keyTimes",
	"lengthAdjust",
	"letterSpacing",
	"lightingColor",
	"limitingConeAngle",
	"local",
	"markerEnd",
	"markerHeight",
	"markerMid",
	"markerStart",
	"markerUnits",
	"markerWidth",
	"mask",
	"maskContentUnits",
	"maskUnits",
	"mathematical",
	"mode",
	"numOctaves",
	"offset",
	"opacity",
	"operator",
	"order",
	"orient",
	"orientation",
	"origin",
	"overflow",
	"overlinePosition",
	"overlineThickness",
	"paintOrder",
	"panose1",
	"pathLength",
	"patternContentUnits",
	"patternTransform",
	"patternUnits",
	"pointerEvents",
	"pointsAtX",
	"pointsAtY",
	"pointsAtZ",
	"preserveAlpha",
	"preserveAspectRatio",
	"primitiveUnits",
	"r",
	"radius",
	"refX",
	"refY",
	"renderingIntent",
	"repeatCount",
	"repeatDur",
	"requiredExtensions",
	"requiredFeatures",
	"restart",
	"result",
	"rotate",
	"rx",
	"ry",
	"seed",
	"shapeRendering",
	"slope",
	"spacing",
	"specularConstant",
	"specularExponent",
	"speed",
	"spreadMethod",
	"startOffset",
	"stdDeviation",
	"stemh",
	"stemv",
	"stitchTiles",
	"stopColor",
	"stopOpacity",
	"strikethroughPosition",
	"strikethroughThickness",
	"string",
	"stroke",
	"strokeDasharray",
	"strokeDashoffset",
	"strokeLinecap",
	"strokeLinejoin",
	"strokeMiterlimit",
	"strokeOpacity",
	"strokeWidth",
	"surfaceScale",
	"systemLanguage",
	"tableValues",
	"targetX",
	"targetY",
	"textAnchor",
	"textDecoration",
	"textLength",
	"textRendering",
	"to",
	"transform",
	"u1",
	"u2",
	"underlinePosition",
	"underlineThickness",
	"unicode",
	"unicodeBidi",
	"unicodeRange",
	"unitsPerEm",
	"vAlphabetic",
	"values",
	"vectorEffect",
	"version",
	"vertAdvY",
	"vertOriginX",
	"vertOriginY",
	"vHanging",
	"vIdeographic",
	"viewTarget",
	"visibility",
	"vMathematical",
	"widths",
	"wordSpacing",
	"writingMode",
	"x1",
	"x2",
	"x",
	"xChannelSelector",
	"xHeight",
	"xlinkActuate",
	"xlinkArcrole",
	"xlinkHref",
	"xlinkRole",
	"xlinkShow",
	"xlinkTitle",
	"xlinkType",
	"xmlBase",
	"xmlLang",
	"xmlns",
	"xmlnsXlink",
	"xmlSpace",
	"y1",
	"y2",
	"y",
	"yChannelSelector",
	"z",
	"zoomAndPan",
	"ref",
	"key",
	"angle"
];
var PolyElementKeys = ["points", "pathLength"];
var FilteredElementKeyMap = {
	svg: SVGContainerPropKeys,
	polygon: PolyElementKeys,
	polyline: PolyElementKeys
};
var EventKeys = [
	"dangerouslySetInnerHTML",
	"onCopy",
	"onCopyCapture",
	"onCut",
	"onCutCapture",
	"onPaste",
	"onPasteCapture",
	"onCompositionEnd",
	"onCompositionEndCapture",
	"onCompositionStart",
	"onCompositionStartCapture",
	"onCompositionUpdate",
	"onCompositionUpdateCapture",
	"onFocus",
	"onFocusCapture",
	"onBlur",
	"onBlurCapture",
	"onChange",
	"onChangeCapture",
	"onBeforeInput",
	"onBeforeInputCapture",
	"onInput",
	"onInputCapture",
	"onReset",
	"onResetCapture",
	"onSubmit",
	"onSubmitCapture",
	"onInvalid",
	"onInvalidCapture",
	"onLoad",
	"onLoadCapture",
	"onError",
	"onErrorCapture",
	"onKeyDown",
	"onKeyDownCapture",
	"onKeyPress",
	"onKeyPressCapture",
	"onKeyUp",
	"onKeyUpCapture",
	"onAbort",
	"onAbortCapture",
	"onCanPlay",
	"onCanPlayCapture",
	"onCanPlayThrough",
	"onCanPlayThroughCapture",
	"onDurationChange",
	"onDurationChangeCapture",
	"onEmptied",
	"onEmptiedCapture",
	"onEncrypted",
	"onEncryptedCapture",
	"onEnded",
	"onEndedCapture",
	"onLoadedData",
	"onLoadedDataCapture",
	"onLoadedMetadata",
	"onLoadedMetadataCapture",
	"onLoadStart",
	"onLoadStartCapture",
	"onPause",
	"onPauseCapture",
	"onPlay",
	"onPlayCapture",
	"onPlaying",
	"onPlayingCapture",
	"onProgress",
	"onProgressCapture",
	"onRateChange",
	"onRateChangeCapture",
	"onSeeked",
	"onSeekedCapture",
	"onSeeking",
	"onSeekingCapture",
	"onStalled",
	"onStalledCapture",
	"onSuspend",
	"onSuspendCapture",
	"onTimeUpdate",
	"onTimeUpdateCapture",
	"onVolumeChange",
	"onVolumeChangeCapture",
	"onWaiting",
	"onWaitingCapture",
	"onAuxClick",
	"onAuxClickCapture",
	"onClick",
	"onClickCapture",
	"onContextMenu",
	"onContextMenuCapture",
	"onDoubleClick",
	"onDoubleClickCapture",
	"onDrag",
	"onDragCapture",
	"onDragEnd",
	"onDragEndCapture",
	"onDragEnter",
	"onDragEnterCapture",
	"onDragExit",
	"onDragExitCapture",
	"onDragLeave",
	"onDragLeaveCapture",
	"onDragOver",
	"onDragOverCapture",
	"onDragStart",
	"onDragStartCapture",
	"onDrop",
	"onDropCapture",
	"onMouseDown",
	"onMouseDownCapture",
	"onMouseEnter",
	"onMouseLeave",
	"onMouseMove",
	"onMouseMoveCapture",
	"onMouseOut",
	"onMouseOutCapture",
	"onMouseOver",
	"onMouseOverCapture",
	"onMouseUp",
	"onMouseUpCapture",
	"onSelect",
	"onSelectCapture",
	"onTouchCancel",
	"onTouchCancelCapture",
	"onTouchEnd",
	"onTouchEndCapture",
	"onTouchMove",
	"onTouchMoveCapture",
	"onTouchStart",
	"onTouchStartCapture",
	"onPointerDown",
	"onPointerDownCapture",
	"onPointerMove",
	"onPointerMoveCapture",
	"onPointerUp",
	"onPointerUpCapture",
	"onPointerCancel",
	"onPointerCancelCapture",
	"onPointerEnter",
	"onPointerEnterCapture",
	"onPointerLeave",
	"onPointerLeaveCapture",
	"onPointerOver",
	"onPointerOverCapture",
	"onPointerOut",
	"onPointerOutCapture",
	"onGotPointerCapture",
	"onGotPointerCaptureCapture",
	"onLostPointerCapture",
	"onLostPointerCaptureCapture",
	"onScroll",
	"onScrollCapture",
	"onWheel",
	"onWheelCapture",
	"onAnimationStart",
	"onAnimationStartCapture",
	"onAnimationEnd",
	"onAnimationEndCapture",
	"onAnimationIteration",
	"onAnimationIterationCapture",
	"onTransitionEnd",
	"onTransitionEndCapture"
];
var adaptEventHandlers = function adaptEventHandlers$1(props, newHandler) {
	if (!props || typeof props === "function" || typeof props === "boolean") return null;
	var inputProps = props;
	if (/* @__PURE__ */ (0, import_react.isValidElement)(props)) inputProps = props.props;
	if (!(0, import_isObject$3.default)(inputProps)) return null;
	var out = {};
	Object.keys(inputProps).forEach(function(key) {
		if (EventKeys.includes(key)) out[key] = newHandler || function(e) {
			return inputProps[key](inputProps, e);
		};
	});
	return out;
};
var getEventHandlerOfChild = function getEventHandlerOfChild$1(originalHandler, data, index) {
	return function(e) {
		originalHandler(data, index, e);
		return null;
	};
};
var adaptEventsOfChild = function adaptEventsOfChild$1(props, data, index) {
	if (!(0, import_isObject$3.default)(props) || _typeof$43(props) !== "object") return null;
	var out = null;
	Object.keys(props).forEach(function(key) {
		var item = props[key];
		if (EventKeys.includes(key) && typeof item === "function") {
			if (!out) out = {};
			out[key] = getEventHandlerOfChild(item, data, index);
		}
	});
	return out;
};
var import_get$3 = /* @__PURE__ */ __toESM(require_get());
var import_isNil$8 = /* @__PURE__ */ __toESM(require_isNil());
var import_isString$1 = /* @__PURE__ */ __toESM(require_isString());
var import_isFunction$16 = /* @__PURE__ */ __toESM(require_isFunction());
var import_isObject$2 = /* @__PURE__ */ __toESM(require_isObject());
var import_react_is = require_react_is$1();
var _excluded$16 = ["children"], _excluded2$5 = ["children"];
function _objectWithoutProperties$16(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$16(source, excluded);
	var key, i;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i = 0; i < sourceSymbolKeys.length; i++) {
			key = sourceSymbolKeys[i];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$16(source, excluded) {
	if (source == null) return {};
	var target = {};
	for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
var REACT_BROWSER_EVENT_MAP = {
	click: "onClick",
	mousedown: "onMouseDown",
	mouseup: "onMouseUp",
	mouseover: "onMouseOver",
	mousemove: "onMouseMove",
	mouseout: "onMouseOut",
	mouseenter: "onMouseEnter",
	mouseleave: "onMouseLeave",
	touchcancel: "onTouchCancel",
	touchend: "onTouchEnd",
	touchmove: "onTouchMove",
	touchstart: "onTouchStart",
	contextmenu: "onContextMenu",
	dblclick: "onDoubleClick"
};
var getDisplayName = function getDisplayName$1(Comp) {
	if (typeof Comp === "string") return Comp;
	if (!Comp) return "";
	return Comp.displayName || Comp.name || "Component";
};
var lastChildren = null;
var lastResult = null;
var toArray = function toArray$1(children) {
	if (children === lastChildren && Array.isArray(lastResult)) return lastResult;
	var result = [];
	import_react.Children.forEach(children, function(child) {
		if ((0, import_isNil$8.default)(child)) return;
		if ((0, import_react_is.isFragment)(child)) result = result.concat(toArray$1(child.props.children));
		else result.push(child);
	});
	lastResult = result;
	lastChildren = children;
	return result;
};
function findAllByType(children, type) {
	var result = [];
	var types = [];
	if (Array.isArray(type)) types = type.map(function(t) {
		return getDisplayName(t);
	});
	else types = [getDisplayName(type)];
	toArray(children).forEach(function(child) {
		var childType = (0, import_get$3.default)(child, "type.displayName") || (0, import_get$3.default)(child, "type.name");
		if (types.indexOf(childType) !== -1) result.push(child);
	});
	return result;
}
function findChildByType(children, type) {
	var result = findAllByType(children, type);
	return result && result[0];
}
var validateWidthHeight = function validateWidthHeight$1(el) {
	if (!el || !el.props) return false;
	var _el$props = el.props, width = _el$props.width, height = _el$props.height;
	if (!isNumber(width) || width <= 0 || !isNumber(height) || height <= 0) return false;
	return true;
};
var SVG_TAGS = [
	"a",
	"altGlyph",
	"altGlyphDef",
	"altGlyphItem",
	"animate",
	"animateColor",
	"animateMotion",
	"animateTransform",
	"circle",
	"clipPath",
	"color-profile",
	"cursor",
	"defs",
	"desc",
	"ellipse",
	"feBlend",
	"feColormatrix",
	"feComponentTransfer",
	"feComposite",
	"feConvolveMatrix",
	"feDiffuseLighting",
	"feDisplacementMap",
	"feDistantLight",
	"feFlood",
	"feFuncA",
	"feFuncB",
	"feFuncG",
	"feFuncR",
	"feGaussianBlur",
	"feImage",
	"feMerge",
	"feMergeNode",
	"feMorphology",
	"feOffset",
	"fePointLight",
	"feSpecularLighting",
	"feSpotLight",
	"feTile",
	"feTurbulence",
	"filter",
	"font",
	"font-face",
	"font-face-format",
	"font-face-name",
	"font-face-url",
	"foreignObject",
	"g",
	"glyph",
	"glyphRef",
	"hkern",
	"image",
	"line",
	"lineGradient",
	"marker",
	"mask",
	"metadata",
	"missing-glyph",
	"mpath",
	"path",
	"pattern",
	"polygon",
	"polyline",
	"radialGradient",
	"rect",
	"script",
	"set",
	"stop",
	"style",
	"svg",
	"switch",
	"symbol",
	"text",
	"textPath",
	"title",
	"tref",
	"tspan",
	"use",
	"view",
	"vkern"
];
var isSvgElement = function isSvgElement$1(child) {
	return child && child.type && (0, import_isString$1.default)(child.type) && SVG_TAGS.indexOf(child.type) >= 0;
};
var isValidSpreadableProp = function isValidSpreadableProp$1(property$2, key, includeEvents, svgElementType) {
	var _FilteredElementKeyMa;
	var matchingElementTypeKeys = (_FilteredElementKeyMa = FilteredElementKeyMap === null || FilteredElementKeyMap === void 0 ? void 0 : FilteredElementKeyMap[svgElementType]) !== null && _FilteredElementKeyMa !== void 0 ? _FilteredElementKeyMa : [];
	return key.startsWith("data-") || !(0, import_isFunction$16.default)(property$2) && (svgElementType && matchingElementTypeKeys.includes(key) || SVGElementPropKeys.includes(key)) || includeEvents && EventKeys.includes(key);
};
var filterProps = function filterProps$1(props, includeEvents, svgElementType) {
	if (!props || typeof props === "function" || typeof props === "boolean") return null;
	var inputProps = props;
	if (/* @__PURE__ */ (0, import_react.isValidElement)(props)) inputProps = props.props;
	if (!(0, import_isObject$2.default)(inputProps)) return null;
	var out = {};
	Object.keys(inputProps).forEach(function(key) {
		var _inputProps;
		if (isValidSpreadableProp((_inputProps = inputProps) === null || _inputProps === void 0 ? void 0 : _inputProps[key], key, includeEvents, svgElementType)) out[key] = inputProps[key];
	});
	return out;
};
var isChildrenEqual = function isChildrenEqual$1(nextChildren, prevChildren) {
	if (nextChildren === prevChildren) return true;
	var count = import_react.Children.count(nextChildren);
	if (count !== import_react.Children.count(prevChildren)) return false;
	if (count === 0) return true;
	if (count === 1) return isSingleChildEqual(Array.isArray(nextChildren) ? nextChildren[0] : nextChildren, Array.isArray(prevChildren) ? prevChildren[0] : prevChildren);
	for (var i = 0; i < count; i++) {
		var nextChild = nextChildren[i];
		var prevChild = prevChildren[i];
		if (Array.isArray(nextChild) || Array.isArray(prevChild)) {
			if (!isChildrenEqual$1(nextChild, prevChild)) return false;
		} else if (!isSingleChildEqual(nextChild, prevChild)) return false;
	}
	return true;
};
var isSingleChildEqual = function isSingleChildEqual$1(nextChild, prevChild) {
	if ((0, import_isNil$8.default)(nextChild) && (0, import_isNil$8.default)(prevChild)) return true;
	if (!(0, import_isNil$8.default)(nextChild) && !(0, import_isNil$8.default)(prevChild)) {
		var _ref = nextChild.props || {}, nextChildren = _ref.children, nextProps = _objectWithoutProperties$16(_ref, _excluded$16);
		var _ref2 = prevChild.props || {}, prevChildren = _ref2.children, prevProps = _objectWithoutProperties$16(_ref2, _excluded2$5);
		if (nextChildren && prevChildren) return shallowEqual(nextProps, prevProps) && isChildrenEqual(nextChildren, prevChildren);
		if (!nextChildren && !prevChildren) return shallowEqual(nextProps, prevProps);
		return false;
	}
	return false;
};
var renderByOrder = function renderByOrder$1(children, renderMap) {
	var elements = [];
	var record = {};
	toArray(children).forEach(function(child, index) {
		if (isSvgElement(child)) elements.push(child);
		else if (child) {
			var displayName = getDisplayName(child.type);
			var _ref3 = renderMap[displayName] || {}, handler = _ref3.handler, once = _ref3.once;
			if (handler && (!once || !record[displayName])) {
				var results = handler(child, displayName, index);
				elements.push(results);
				record[displayName] = true;
			}
		}
	});
	return elements;
};
var getReactEventByType = function getReactEventByType$1(e) {
	var type = e && e.type;
	if (type && REACT_BROWSER_EVENT_MAP[type]) return REACT_BROWSER_EVENT_MAP[type];
	return null;
};
var parseChildIndex = function parseChildIndex$1(child, children) {
	return toArray(children).indexOf(child);
};
var _excluded$15 = [
	"children",
	"width",
	"height",
	"viewBox",
	"className",
	"style",
	"title",
	"desc"
];
function _extends$25() {
	_extends$25 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$25.apply(this, arguments);
}
function _objectWithoutProperties$15(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$15(source, excluded);
	var key, i;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i = 0; i < sourceSymbolKeys.length; i++) {
			key = sourceSymbolKeys[i];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$15(source, excluded) {
	if (source == null) return {};
	var target = {};
	for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function Surface(props) {
	var children = props.children, width = props.width, height = props.height, viewBox = props.viewBox, className = props.className, style = props.style, title = props.title, desc = props.desc, others = _objectWithoutProperties$15(props, _excluded$15);
	var svgView = viewBox || {
		width,
		height,
		x: 0,
		y: 0
	};
	var layerClass = clsx_default("recharts-surface", className);
	return /* @__PURE__ */ import_react.createElement("svg", _extends$25({}, filterProps(others, true, "svg"), {
		className: layerClass,
		width,
		height,
		style,
		viewBox: "".concat(svgView.x, " ").concat(svgView.y, " ").concat(svgView.width, " ").concat(svgView.height)
	}), /* @__PURE__ */ import_react.createElement("title", null, title), /* @__PURE__ */ import_react.createElement("desc", null, desc), children);
}
var _excluded$14 = ["children", "className"];
function _extends$24() {
	_extends$24 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$24.apply(this, arguments);
}
function _objectWithoutProperties$14(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$14(source, excluded);
	var key, i;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i = 0; i < sourceSymbolKeys.length; i++) {
			key = sourceSymbolKeys[i];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$14(source, excluded) {
	if (source == null) return {};
	var target = {};
	for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
var Layer = /* @__PURE__ */ import_react.forwardRef(function(props, ref) {
	var children = props.children, className = props.className, others = _objectWithoutProperties$14(props, _excluded$14);
	var layerClass = clsx_default("recharts-layer", className);
	return /* @__PURE__ */ import_react.createElement("g", _extends$24({ className: layerClass }, filterProps(others, true), { ref }), children);
});
var isDev$1 = true;
var warn = function warn$2(condition, format$1) {
	for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) args[_key - 2] = arguments[_key];
	if (isDev$1 && typeof console !== "undefined" && console.warn) {
		if (format$1 === void 0) console.warn("LogUtils requires an error message argument");
		if (!condition) if (format$1 === void 0) console.warn("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
		else {
			var argIndex = 0;
			console.warn(format$1.replace(/%s/g, function() {
				return args[argIndex++];
			}));
		}
	}
};
var require__baseSlice = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function baseSlice$1(array, start, end) {
		var index = -1, length = array.length;
		if (start < 0) start = -start > length ? 0 : length + start;
		end = end > length ? length : end;
		if (end < 0) end += length;
		length = start > end ? 0 : end - start >>> 0;
		start >>>= 0;
		var result = Array(length);
		while (++index < length) result[index] = array[index + start];
		return result;
	}
	module.exports = baseSlice$1;
}));
var require__castSlice = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseSlice = require__baseSlice();
	function castSlice$1(array, start, end) {
		var length = array.length;
		end = end === void 0 ? length : end;
		return !start && end >= length ? array : baseSlice(array, start, end);
	}
	module.exports = castSlice$1;
}));
var require__hasUnicode = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var reHasUnicode = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]");
	function hasUnicode$2(string) {
		return reHasUnicode.test(string);
	}
	module.exports = hasUnicode$2;
}));
var require__asciiToArray = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function asciiToArray$1(string) {
		return string.split("");
	}
	module.exports = asciiToArray$1;
}));
var require__unicodeToArray = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var rsAstralRange = "\\ud800-\\udfff", rsComboRange = "\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff", rsVarRange = "\\ufe0e\\ufe0f";
	var rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ = "\\u200d";
	var reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [
		rsNonAstral,
		rsRegional,
		rsSurrPair
	].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [
		rsNonAstral + rsCombo + "?",
		rsCombo,
		rsRegional,
		rsSurrPair,
		rsAstral
	].join("|") + ")";
	var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
	function unicodeToArray$1(string) {
		return string.match(reUnicode) || [];
	}
	module.exports = unicodeToArray$1;
}));
var require__stringToArray = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var asciiToArray = require__asciiToArray(), hasUnicode$1 = require__hasUnicode(), unicodeToArray = require__unicodeToArray();
	function stringToArray$1(string) {
		return hasUnicode$1(string) ? unicodeToArray(string) : asciiToArray(string);
	}
	module.exports = stringToArray$1;
}));
var require__createCaseFirst = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var castSlice = require__castSlice(), hasUnicode = require__hasUnicode(), stringToArray = require__stringToArray(), toString$1 = require_toString();
	function createCaseFirst(methodName) {
		return function(string) {
			string = toString$1(string);
			var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
			var chr = strSymbols ? strSymbols[0] : string.charAt(0);
			var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
			return chr[methodName]() + trailing;
		};
	}
	module.exports = createCaseFirst;
}));
var require_upperFirst = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__createCaseFirst()("toUpperCase");
}));
function constant_default$1(x$1) {
	return function constant$2() {
		return x$1;
	};
}
const cos = Math.cos;
const sin = Math.sin;
const sqrt$1 = Math.sqrt;
const pi = Math.PI;
pi / 2;
const tau = 2 * pi;
var pi$1 = Math.PI, tau$1 = 2 * pi$1, epsilon = 1e-6, tauEpsilon = tau$1 - epsilon;
function append(strings) {
	this._ += strings[0];
	for (let i = 1, n = strings.length; i < n; ++i) this._ += arguments[i] + strings[i];
}
function appendRound(digits) {
	let d = Math.floor(digits);
	if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);
	if (d > 15) return append;
	const k$1 = 10 ** d;
	return function(strings) {
		this._ += strings[0];
		for (let i = 1, n = strings.length; i < n; ++i) this._ += Math.round(arguments[i] * k$1) / k$1 + strings[i];
	};
}
var Path = class {
	constructor(digits) {
		this._x0 = this._y0 = this._x1 = this._y1 = null;
		this._ = "";
		this._append = digits == null ? append : appendRound(digits);
	}
	moveTo(x$1, y$1) {
		this._append`M${this._x0 = this._x1 = +x$1},${this._y0 = this._y1 = +y$1}`;
	}
	closePath() {
		if (this._x1 !== null) {
			this._x1 = this._x0, this._y1 = this._y0;
			this._append`Z`;
		}
	}
	lineTo(x$1, y$1) {
		this._append`L${this._x1 = +x$1},${this._y1 = +y$1}`;
	}
	quadraticCurveTo(x1, y1, x$1, y$1) {
		this._append`Q${+x1},${+y1},${this._x1 = +x$1},${this._y1 = +y$1}`;
	}
	bezierCurveTo(x1, y1, x2, y2, x$1, y$1) {
		this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x$1},${this._y1 = +y$1}`;
	}
	arcTo(x1, y1, x2, y2, r) {
		x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
		if (r < 0) throw new Error(`negative radius: ${r}`);
		let x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
		if (this._x1 === null) this._append`M${this._x1 = x1},${this._y1 = y1}`;
		else if (!(l01_2 > epsilon));
		else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) this._append`L${this._x1 = x1},${this._y1 = y1}`;
		else {
			let x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi$1 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
			if (Math.abs(t01 - 1) > epsilon) this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
			this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
		}
	}
	arc(x$1, y$1, r, a0, a1, ccw) {
		x$1 = +x$1, y$1 = +y$1, r = +r, ccw = !!ccw;
		if (r < 0) throw new Error(`negative radius: ${r}`);
		let dx = r * Math.cos(a0), dy = r * Math.sin(a0), x0 = x$1 + dx, y0 = y$1 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
		if (this._x1 === null) this._append`M${x0},${y0}`;
		else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) this._append`L${x0},${y0}`;
		if (!r) return;
		if (da < 0) da = da % tau$1 + tau$1;
		if (da > tauEpsilon) this._append`A${r},${r},0,1,${cw},${x$1 - dx},${y$1 - dy}A${r},${r},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
		else if (da > epsilon) this._append`A${r},${r},0,${+(da >= pi$1)},${cw},${this._x1 = x$1 + r * Math.cos(a1)},${this._y1 = y$1 + r * Math.sin(a1)}`;
	}
	rect(x$1, y$1, w, h) {
		this._append`M${this._x0 = this._x1 = +x$1},${this._y0 = this._y1 = +y$1}h${w = +w}v${+h}h${-w}Z`;
	}
	toString() {
		return this._;
	}
};
function path() {
	return new Path();
}
path.prototype = Path.prototype;
function withPath(shape) {
	let digits = 3;
	shape.digits = function(_) {
		if (!arguments.length) return digits;
		if (_ == null) digits = null;
		else {
			const d = Math.floor(_);
			if (!(d >= 0)) throw new RangeError(`invalid digits: ${_}`);
			digits = d;
		}
		return shape;
	};
	return () => new Path(digits);
}
Array.prototype.slice;
function array_default(x$1) {
	return typeof x$1 === "object" && "length" in x$1 ? x$1 : Array.from(x$1);
}
function Linear(context) {
	this._context = context;
}
Linear.prototype = {
	areaStart: function() {
		this._line = 0;
	},
	areaEnd: function() {
		this._line = NaN;
	},
	lineStart: function() {
		this._point = 0;
	},
	lineEnd: function() {
		if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
		this._line = 1 - this._line;
	},
	point: function(x$1, y$1) {
		x$1 = +x$1, y$1 = +y$1;
		switch (this._point) {
			case 0:
				this._point = 1;
				this._line ? this._context.lineTo(x$1, y$1) : this._context.moveTo(x$1, y$1);
				break;
			case 1: this._point = 2;
			default:
				this._context.lineTo(x$1, y$1);
				break;
		}
	}
};
function linear_default(context) {
	return new Linear(context);
}
function x(p) {
	return p[0];
}
function y(p) {
	return p[1];
}
function line_default(x$1, y$1) {
	var defined$1 = constant_default$1(true), context = null, curve = linear_default, output = null, path$1 = withPath(line);
	x$1 = typeof x$1 === "function" ? x$1 : x$1 === void 0 ? x : constant_default$1(x$1);
	y$1 = typeof y$1 === "function" ? y$1 : y$1 === void 0 ? y : constant_default$1(y$1);
	function line(data) {
		var i, n = (data = array_default(data)).length, d, defined0 = false, buffer;
		if (context == null) output = curve(buffer = path$1());
		for (i = 0; i <= n; ++i) {
			if (!(i < n && defined$1(d = data[i], i, data)) === defined0) if (defined0 = !defined0) output.lineStart();
			else output.lineEnd();
			if (defined0) output.point(+x$1(d, i, data), +y$1(d, i, data));
		}
		if (buffer) return output = null, buffer + "" || null;
	}
	line.x = function(_) {
		return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant_default$1(+_), line) : x$1;
	};
	line.y = function(_) {
		return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant_default$1(+_), line) : y$1;
	};
	line.defined = function(_) {
		return arguments.length ? (defined$1 = typeof _ === "function" ? _ : constant_default$1(!!_), line) : defined$1;
	};
	line.curve = function(_) {
		return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
	};
	line.context = function(_) {
		return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
	};
	return line;
}
function area_default(x0, y0, y1) {
	var x1 = null, defined$1 = constant_default$1(true), context = null, curve = linear_default, output = null, path$1 = withPath(area);
	x0 = typeof x0 === "function" ? x0 : x0 === void 0 ? x : constant_default$1(+x0);
	y0 = typeof y0 === "function" ? y0 : y0 === void 0 ? constant_default$1(0) : constant_default$1(+y0);
	y1 = typeof y1 === "function" ? y1 : y1 === void 0 ? y : constant_default$1(+y1);
	function area(data) {
		var i, j, k$1, n = (data = array_default(data)).length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
		if (context == null) output = curve(buffer = path$1());
		for (i = 0; i <= n; ++i) {
			if (!(i < n && defined$1(d = data[i], i, data)) === defined0) if (defined0 = !defined0) {
				j = i;
				output.areaStart();
				output.lineStart();
			} else {
				output.lineEnd();
				output.lineStart();
				for (k$1 = i - 1; k$1 >= j; --k$1) output.point(x0z[k$1], y0z[k$1]);
				output.lineEnd();
				output.areaEnd();
			}
			if (defined0) {
				x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
				output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
			}
		}
		if (buffer) return output = null, buffer + "" || null;
	}
	function arealine() {
		return line_default().defined(defined$1).curve(curve).context(context);
	}
	area.x = function(_) {
		return arguments.length ? (x0 = typeof _ === "function" ? _ : constant_default$1(+_), x1 = null, area) : x0;
	};
	area.x0 = function(_) {
		return arguments.length ? (x0 = typeof _ === "function" ? _ : constant_default$1(+_), area) : x0;
	};
	area.x1 = function(_) {
		return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant_default$1(+_), area) : x1;
	};
	area.y = function(_) {
		return arguments.length ? (y0 = typeof _ === "function" ? _ : constant_default$1(+_), y1 = null, area) : y0;
	};
	area.y0 = function(_) {
		return arguments.length ? (y0 = typeof _ === "function" ? _ : constant_default$1(+_), area) : y0;
	};
	area.y1 = function(_) {
		return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant_default$1(+_), area) : y1;
	};
	area.lineX0 = area.lineY0 = function() {
		return arealine().x(x0).y(y0);
	};
	area.lineY1 = function() {
		return arealine().x(x0).y(y1);
	};
	area.lineX1 = function() {
		return arealine().x(x1).y(y0);
	};
	area.defined = function(_) {
		return arguments.length ? (defined$1 = typeof _ === "function" ? _ : constant_default$1(!!_), area) : defined$1;
	};
	area.curve = function(_) {
		return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
	};
	area.context = function(_) {
		return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
	};
	return area;
}
var Bump = class {
	constructor(context, x$1) {
		this._context = context;
		this._x = x$1;
	}
	areaStart() {
		this._line = 0;
	}
	areaEnd() {
		this._line = NaN;
	}
	lineStart() {
		this._point = 0;
	}
	lineEnd() {
		if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
		this._line = 1 - this._line;
	}
	point(x$1, y$1) {
		x$1 = +x$1, y$1 = +y$1;
		switch (this._point) {
			case 0:
				this._point = 1;
				if (this._line) this._context.lineTo(x$1, y$1);
				else this._context.moveTo(x$1, y$1);
				break;
			case 1: this._point = 2;
			default:
				if (this._x) this._context.bezierCurveTo(this._x0 = (this._x0 + x$1) / 2, this._y0, this._x0, y$1, x$1, y$1);
				else this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y$1) / 2, x$1, this._y0, x$1, y$1);
				break;
		}
		this._x0 = x$1, this._y0 = y$1;
	}
};
function bumpX(context) {
	return new Bump(context, true);
}
function bumpY(context) {
	return new Bump(context, false);
}
var circle_default = { draw(context, size) {
	const r = sqrt$1(size / pi);
	context.moveTo(r, 0);
	context.arc(0, 0, r, 0, tau);
} };
var cross_default = { draw(context, size) {
	const r = sqrt$1(size / 5) / 2;
	context.moveTo(-3 * r, -r);
	context.lineTo(-r, -r);
	context.lineTo(-r, -3 * r);
	context.lineTo(r, -3 * r);
	context.lineTo(r, -r);
	context.lineTo(3 * r, -r);
	context.lineTo(3 * r, r);
	context.lineTo(r, r);
	context.lineTo(r, 3 * r);
	context.lineTo(-r, 3 * r);
	context.lineTo(-r, r);
	context.lineTo(-3 * r, r);
	context.closePath();
} };
var tan30 = sqrt$1(1 / 3);
var tan30_2 = tan30 * 2;
var diamond_default = { draw(context, size) {
	const y$1 = sqrt$1(size / tan30_2);
	const x$1 = y$1 * tan30;
	context.moveTo(0, -y$1);
	context.lineTo(x$1, 0);
	context.lineTo(0, y$1);
	context.lineTo(-x$1, 0);
	context.closePath();
} };
var square_default = { draw(context, size) {
	const w = sqrt$1(size);
	const x$1 = -w / 2;
	context.rect(x$1, x$1, w, w);
} };
var ka = .8908130915292852;
var kr = sin(pi / 10) / sin(7 * pi / 10);
var kx = sin(tau / 10) * kr;
var ky = -cos(tau / 10) * kr;
var star_default = { draw(context, size) {
	const r = sqrt$1(size * ka);
	const x$1 = kx * r;
	const y$1 = ky * r;
	context.moveTo(0, -r);
	context.lineTo(x$1, y$1);
	for (let i = 1; i < 5; ++i) {
		const a$1 = tau * i / 5;
		const c$1 = cos(a$1);
		const s$1 = sin(a$1);
		context.lineTo(s$1 * r, -c$1 * r);
		context.lineTo(c$1 * x$1 - s$1 * y$1, s$1 * x$1 + c$1 * y$1);
	}
	context.closePath();
} };
var sqrt3 = sqrt$1(3);
var triangle_default = { draw(context, size) {
	const y$1 = -sqrt$1(size / (sqrt3 * 3));
	context.moveTo(0, y$1 * 2);
	context.lineTo(-sqrt3 * y$1, -y$1);
	context.lineTo(sqrt3 * y$1, -y$1);
	context.closePath();
} };
var c = -.5;
var s = sqrt$1(3) / 2;
var k = 1 / sqrt$1(12);
var a = (k / 2 + 1) * 3;
var wye_default = { draw(context, size) {
	const r = sqrt$1(size / a);
	const x0 = r / 2, y0 = r * k;
	const x1 = x0, y1 = r * k + r;
	const x2 = -x1, y2 = y1;
	context.moveTo(x0, y0);
	context.lineTo(x1, y1);
	context.lineTo(x2, y2);
	context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
	context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
	context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
	context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
	context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
	context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
	context.closePath();
} };
function Symbol$3(type, size) {
	let context = null, path$1 = withPath(symbol);
	type = typeof type === "function" ? type : constant_default$1(type || circle_default);
	size = typeof size === "function" ? size : constant_default$1(size === void 0 ? 64 : +size);
	function symbol() {
		let buffer;
		if (!context) context = buffer = path$1();
		type.apply(this, arguments).draw(context, +size.apply(this, arguments));
		if (buffer) return context = null, buffer + "" || null;
	}
	symbol.type = function(_) {
		return arguments.length ? (type = typeof _ === "function" ? _ : constant_default$1(_), symbol) : type;
	};
	symbol.size = function(_) {
		return arguments.length ? (size = typeof _ === "function" ? _ : constant_default$1(+_), symbol) : size;
	};
	symbol.context = function(_) {
		return arguments.length ? (context = _ == null ? null : _, symbol) : context;
	};
	return symbol;
}
function noop_default() {}
function point$2(that, x$1, y$1) {
	that._context.bezierCurveTo((2 * that._x0 + that._x1) / 3, (2 * that._y0 + that._y1) / 3, (that._x0 + 2 * that._x1) / 3, (that._y0 + 2 * that._y1) / 3, (that._x0 + 4 * that._x1 + x$1) / 6, (that._y0 + 4 * that._y1 + y$1) / 6);
}
function Basis(context) {
	this._context = context;
}
Basis.prototype = {
	areaStart: function() {
		this._line = 0;
	},
	areaEnd: function() {
		this._line = NaN;
	},
	lineStart: function() {
		this._x0 = this._x1 = this._y0 = this._y1 = NaN;
		this._point = 0;
	},
	lineEnd: function() {
		switch (this._point) {
			case 3: point$2(this, this._x1, this._y1);
			case 2:
				this._context.lineTo(this._x1, this._y1);
				break;
		}
		if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
		this._line = 1 - this._line;
	},
	point: function(x$1, y$1) {
		x$1 = +x$1, y$1 = +y$1;
		switch (this._point) {
			case 0:
				this._point = 1;
				this._line ? this._context.lineTo(x$1, y$1) : this._context.moveTo(x$1, y$1);
				break;
			case 1:
				this._point = 2;
				break;
			case 2:
				this._point = 3;
				this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
			default:
				point$2(this, x$1, y$1);
				break;
		}
		this._x0 = this._x1, this._x1 = x$1;
		this._y0 = this._y1, this._y1 = y$1;
	}
};
function basis_default(context) {
	return new Basis(context);
}
function BasisClosed(context) {
	this._context = context;
}
BasisClosed.prototype = {
	areaStart: noop_default,
	areaEnd: noop_default,
	lineStart: function() {
		this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
		this._point = 0;
	},
	lineEnd: function() {
		switch (this._point) {
			case 1:
				this._context.moveTo(this._x2, this._y2);
				this._context.closePath();
				break;
			case 2:
				this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
				this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
				this._context.closePath();
				break;
			case 3:
				this.point(this._x2, this._y2);
				this.point(this._x3, this._y3);
				this.point(this._x4, this._y4);
				break;
		}
	},
	point: function(x$1, y$1) {
		x$1 = +x$1, y$1 = +y$1;
		switch (this._point) {
			case 0:
				this._point = 1;
				this._x2 = x$1, this._y2 = y$1;
				break;
			case 1:
				this._point = 2;
				this._x3 = x$1, this._y3 = y$1;
				break;
			case 2:
				this._point = 3;
				this._x4 = x$1, this._y4 = y$1;
				this._context.moveTo((this._x0 + 4 * this._x1 + x$1) / 6, (this._y0 + 4 * this._y1 + y$1) / 6);
				break;
			default:
				point$2(this, x$1, y$1);
				break;
		}
		this._x0 = this._x1, this._x1 = x$1;
		this._y0 = this._y1, this._y1 = y$1;
	}
};
function basisClosed_default(context) {
	return new BasisClosed(context);
}
function BasisOpen(context) {
	this._context = context;
}
BasisOpen.prototype = {
	areaStart: function() {
		this._line = 0;
	},
	areaEnd: function() {
		this._line = NaN;
	},
	lineStart: function() {
		this._x0 = this._x1 = this._y0 = this._y1 = NaN;
		this._point = 0;
	},
	lineEnd: function() {
		if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
		this._line = 1 - this._line;
	},
	point: function(x$1, y$1) {
		x$1 = +x$1, y$1 = +y$1;
		switch (this._point) {
			case 0:
				this._point = 1;
				break;
			case 1:
				this._point = 2;
				break;
			case 2:
				this._point = 3;
				var x0 = (this._x0 + 4 * this._x1 + x$1) / 6, y0 = (this._y0 + 4 * this._y1 + y$1) / 6;
				this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
				break;
			case 3: this._point = 4;
			default:
				point$2(this, x$1, y$1);
				break;
		}
		this._x0 = this._x1, this._x1 = x$1;
		this._y0 = this._y1, this._y1 = y$1;
	}
};
function basisOpen_default(context) {
	return new BasisOpen(context);
}
function LinearClosed(context) {
	this._context = context;
}
LinearClosed.prototype = {
	areaStart: noop_default,
	areaEnd: noop_default,
	lineStart: function() {
		this._point = 0;
	},
	lineEnd: function() {
		if (this._point) this._context.closePath();
	},
	point: function(x$1, y$1) {
		x$1 = +x$1, y$1 = +y$1;
		if (this._point) this._context.lineTo(x$1, y$1);
		else this._point = 1, this._context.moveTo(x$1, y$1);
	}
};
function linearClosed_default(context) {
	return new LinearClosed(context);
}
function sign(x$1) {
	return x$1 < 0 ? -1 : 1;
}
function slope3(that, x2, y2) {
	var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
	return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), .5 * Math.abs(p)) || 0;
}
function slope2(that, t) {
	var h = that._x1 - that._x0;
	return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}
function point$1(that, t0$1, t1$1) {
	var x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 3;
	that._context.bezierCurveTo(x0 + dx, y0 + dx * t0$1, x1 - dx, y1 - dx * t1$1, x1, y1);
}
function MonotoneX(context) {
	this._context = context;
}
MonotoneX.prototype = {
	areaStart: function() {
		this._line = 0;
	},
	areaEnd: function() {
		this._line = NaN;
	},
	lineStart: function() {
		this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
		this._point = 0;
	},
	lineEnd: function() {
		switch (this._point) {
			case 2:
				this._context.lineTo(this._x1, this._y1);
				break;
			case 3:
				point$1(this, this._t0, slope2(this, this._t0));
				break;
		}
		if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
		this._line = 1 - this._line;
	},
	point: function(x$1, y$1) {
		var t1$1 = NaN;
		x$1 = +x$1, y$1 = +y$1;
		if (x$1 === this._x1 && y$1 === this._y1) return;
		switch (this._point) {
			case 0:
				this._point = 1;
				this._line ? this._context.lineTo(x$1, y$1) : this._context.moveTo(x$1, y$1);
				break;
			case 1:
				this._point = 2;
				break;
			case 2:
				this._point = 3;
				point$1(this, slope2(this, t1$1 = slope3(this, x$1, y$1)), t1$1);
				break;
			default:
				point$1(this, this._t0, t1$1 = slope3(this, x$1, y$1));
				break;
		}
		this._x0 = this._x1, this._x1 = x$1;
		this._y0 = this._y1, this._y1 = y$1;
		this._t0 = t1$1;
	}
};
function MonotoneY(context) {
	this._context = new ReflectContext(context);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x$1, y$1) {
	MonotoneX.prototype.point.call(this, y$1, x$1);
};
function ReflectContext(context) {
	this._context = context;
}
ReflectContext.prototype = {
	moveTo: function(x$1, y$1) {
		this._context.moveTo(y$1, x$1);
	},
	closePath: function() {
		this._context.closePath();
	},
	lineTo: function(x$1, y$1) {
		this._context.lineTo(y$1, x$1);
	},
	bezierCurveTo: function(x1, y1, x2, y2, x$1, y$1) {
		this._context.bezierCurveTo(y1, x1, y2, x2, y$1, x$1);
	}
};
function monotoneX(context) {
	return new MonotoneX(context);
}
function monotoneY(context) {
	return new MonotoneY(context);
}
function Natural(context) {
	this._context = context;
}
Natural.prototype = {
	areaStart: function() {
		this._line = 0;
	},
	areaEnd: function() {
		this._line = NaN;
	},
	lineStart: function() {
		this._x = [];
		this._y = [];
	},
	lineEnd: function() {
		var x$1 = this._x, y$1 = this._y, n = x$1.length;
		if (n) {
			this._line ? this._context.lineTo(x$1[0], y$1[0]) : this._context.moveTo(x$1[0], y$1[0]);
			if (n === 2) this._context.lineTo(x$1[1], y$1[1]);
			else {
				var px = controlPoints(x$1), py = controlPoints(y$1);
				for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x$1[i1], y$1[i1]);
			}
		}
		if (this._line || this._line !== 0 && n === 1) this._context.closePath();
		this._line = 1 - this._line;
		this._x = this._y = null;
	},
	point: function(x$1, y$1) {
		this._x.push(+x$1);
		this._y.push(+y$1);
	}
};
function controlPoints(x$1) {
	var i, n = x$1.length - 1, m, a$1 = new Array(n), b = new Array(n), r = new Array(n);
	a$1[0] = 0, b[0] = 2, r[0] = x$1[0] + 2 * x$1[1];
	for (i = 1; i < n - 1; ++i) a$1[i] = 1, b[i] = 4, r[i] = 4 * x$1[i] + 2 * x$1[i + 1];
	a$1[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x$1[n - 1] + x$1[n];
	for (i = 1; i < n; ++i) m = a$1[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
	a$1[n - 1] = r[n - 1] / b[n - 1];
	for (i = n - 2; i >= 0; --i) a$1[i] = (r[i] - a$1[i + 1]) / b[i];
	b[n - 1] = (x$1[n] + a$1[n - 1]) / 2;
	for (i = 0; i < n - 1; ++i) b[i] = 2 * x$1[i + 1] - a$1[i + 1];
	return [a$1, b];
}
function natural_default(context) {
	return new Natural(context);
}
function Step(context, t) {
	this._context = context;
	this._t = t;
}
Step.prototype = {
	areaStart: function() {
		this._line = 0;
	},
	areaEnd: function() {
		this._line = NaN;
	},
	lineStart: function() {
		this._x = this._y = NaN;
		this._point = 0;
	},
	lineEnd: function() {
		if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
		if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
		if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
	},
	point: function(x$1, y$1) {
		x$1 = +x$1, y$1 = +y$1;
		switch (this._point) {
			case 0:
				this._point = 1;
				this._line ? this._context.lineTo(x$1, y$1) : this._context.moveTo(x$1, y$1);
				break;
			case 1: this._point = 2;
			default:
				if (this._t <= 0) {
					this._context.lineTo(this._x, y$1);
					this._context.lineTo(x$1, y$1);
				} else {
					var x1 = this._x * (1 - this._t) + x$1 * this._t;
					this._context.lineTo(x1, this._y);
					this._context.lineTo(x1, y$1);
				}
				break;
		}
		this._x = x$1, this._y = y$1;
	}
};
function step_default(context) {
	return new Step(context, .5);
}
function stepBefore(context) {
	return new Step(context, 0);
}
function stepAfter(context) {
	return new Step(context, 1);
}
function none_default(series, order) {
	if (!((n = series.length) > 1)) return;
	for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
		s0 = s1, s1 = series[order[i]];
		for (j = 0; j < m; ++j) s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
	}
}
function none_default$1(series) {
	var n = series.length, o = new Array(n);
	while (--n >= 0) o[n] = n;
	return o;
}
function stackValue(d, key) {
	return d[key];
}
function stackSeries(key) {
	const series = [];
	series.key = key;
	return series;
}
function stack_default() {
	var keys$6 = constant_default$1([]), order = none_default$1, offset = none_default, value = stackValue;
	function stack(data) {
		var sz = Array.from(keys$6.apply(this, arguments), stackSeries), i, n = sz.length, j = -1, oz;
		for (const d of data) for (i = 0, ++j; i < n; ++i) (sz[i][j] = [0, +value(d, sz[i].key, j, data)]).data = d;
		for (i = 0, oz = array_default(order(sz)); i < n; ++i) sz[oz[i]].index = i;
		offset(sz, oz);
		return sz;
	}
	stack.keys = function(_) {
		return arguments.length ? (keys$6 = typeof _ === "function" ? _ : constant_default$1(Array.from(_)), stack) : keys$6;
	};
	stack.value = function(_) {
		return arguments.length ? (value = typeof _ === "function" ? _ : constant_default$1(+_), stack) : value;
	};
	stack.order = function(_) {
		return arguments.length ? (order = _ == null ? none_default$1 : typeof _ === "function" ? _ : constant_default$1(Array.from(_)), stack) : order;
	};
	stack.offset = function(_) {
		return arguments.length ? (offset = _ == null ? none_default : _, stack) : offset;
	};
	return stack;
}
function expand_default(series, order) {
	if (!((n = series.length) > 0)) return;
	for (var i, n, j = 0, m = series[0].length, y$1; j < m; ++j) {
		for (y$1 = i = 0; i < n; ++i) y$1 += series[i][j][1] || 0;
		if (y$1) for (i = 0; i < n; ++i) series[i][j][1] /= y$1;
	}
	none_default(series, order);
}
function silhouette_default(series, order) {
	if (!((n = series.length) > 0)) return;
	for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
		for (var i = 0, y$1 = 0; i < n; ++i) y$1 += series[i][j][1] || 0;
		s0[j][1] += s0[j][0] = -y$1 / 2;
	}
	none_default(series, order);
}
function wiggle_default(series, order) {
	if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
	for (var y$1 = 0, j = 1, s0, m, n; j < m; ++j) {
		for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
			var si = series[order[i]], sij0 = si[j][1] || 0, s3 = (sij0 - (si[j - 1][1] || 0)) / 2;
			for (var k$1 = 0; k$1 < i; ++k$1) {
				var sk = series[order[k$1]], skj0 = sk[j][1] || 0, skj1 = sk[j - 1][1] || 0;
				s3 += skj0 - skj1;
			}
			s1 += sij0, s2 += s3 * sij0;
		}
		s0[j - 1][1] += s0[j - 1][0] = y$1;
		if (s1) y$1 -= s2 / s1;
	}
	s0[j - 1][1] += s0[j - 1][0] = y$1;
	none_default(series, order);
}
var import_upperFirst$2 = /* @__PURE__ */ __toESM(require_upperFirst());
function _typeof$42(o) {
	"@babel/helpers - typeof";
	return _typeof$42 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$42(o);
}
var _excluded$13 = [
	"type",
	"size",
	"sizeType"
];
function _extends$23() {
	_extends$23 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$23.apply(this, arguments);
}
function ownKeys$34(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$34(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$34(Object(t), !0).forEach(function(r$1) {
			_defineProperty$39(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$34(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}
function _defineProperty$39(obj, key, value) {
	key = _toPropertyKey$40(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$40(t) {
	var i = _toPrimitive$40(t, "string");
	return "symbol" == _typeof$42(i) ? i : i + "";
}
function _toPrimitive$40(t, r) {
	if ("object" != _typeof$42(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$42(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
function _objectWithoutProperties$13(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$13(source, excluded);
	var key, i;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i = 0; i < sourceSymbolKeys.length; i++) {
			key = sourceSymbolKeys[i];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$13(source, excluded) {
	if (source == null) return {};
	var target = {};
	for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
var symbolFactories = {
	symbolCircle: circle_default,
	symbolCross: cross_default,
	symbolDiamond: diamond_default,
	symbolSquare: square_default,
	symbolStar: star_default,
	symbolTriangle: triangle_default,
	symbolWye: wye_default
};
var RADIAN$1 = Math.PI / 180;
var getSymbolFactory = function getSymbolFactory$1(type) {
	return symbolFactories["symbol".concat((0, import_upperFirst$2.default)(type))] || circle_default;
};
var calculateAreaSize = function calculateAreaSize$1(size, sizeType, type) {
	if (sizeType === "area") return size;
	switch (type) {
		case "cross": return 5 * size * size / 9;
		case "diamond": return .5 * size * size / Math.sqrt(3);
		case "square": return size * size;
		case "star":
			var angle = 18 * RADIAN$1;
			return 1.25 * size * size * (Math.tan(angle) - Math.tan(angle * 2) * Math.pow(Math.tan(angle), 2));
		case "triangle": return Math.sqrt(3) * size * size / 4;
		case "wye": return (21 - 10 * Math.sqrt(3)) * size * size / 8;
		default: return Math.PI * size * size / 4;
	}
};
var registerSymbol = function registerSymbol$1(key, factory) {
	symbolFactories["symbol".concat((0, import_upperFirst$2.default)(key))] = factory;
};
var Symbols = function Symbols$1(_ref) {
	var _ref$type = _ref.type, type = _ref$type === void 0 ? "circle" : _ref$type, _ref$size = _ref.size, size = _ref$size === void 0 ? 64 : _ref$size, _ref$sizeType = _ref.sizeType, sizeType = _ref$sizeType === void 0 ? "area" : _ref$sizeType;
	var props = _objectSpread$34(_objectSpread$34({}, _objectWithoutProperties$13(_ref, _excluded$13)), {}, {
		type,
		size,
		sizeType
	});
	var getPath$2 = function getPath$3() {
		var symbolFactory = getSymbolFactory(type);
		return Symbol$3().type(symbolFactory).size(calculateAreaSize(size, sizeType, type))();
	};
	var className = props.className, cx = props.cx, cy = props.cy;
	var filteredProps = filterProps(props, true);
	if (cx === +cx && cy === +cy && size === +size) return /* @__PURE__ */ import_react.createElement("path", _extends$23({}, filteredProps, {
		className: clsx_default("recharts-symbols", className),
		transform: "translate(".concat(cx, ", ").concat(cy, ")"),
		d: getPath$2()
	}));
	return null;
};
Symbols.registerSymbol = registerSymbol;
var import_isFunction$15 = /* @__PURE__ */ __toESM(require_isFunction());
function _typeof$41(o) {
	"@babel/helpers - typeof";
	return _typeof$41 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$41(o);
}
function _extends$22() {
	_extends$22 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$22.apply(this, arguments);
}
function ownKeys$33(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$33(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$33(Object(t), !0).forEach(function(r$1) {
			_defineProperty$38(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$33(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}
function _classCallCheck$17(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$17(target, props) {
	for (var i = 0; i < props.length; i++) {
		var descriptor = props[i];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$39(descriptor.key), descriptor);
	}
}
function _createClass$17(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$17(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$17(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _callSuper$13(t, o, e) {
	return o = _getPrototypeOf$14(o), _possibleConstructorReturn$14(t, _isNativeReflectConstruct$14() ? Reflect.construct(o, e || [], _getPrototypeOf$14(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn$14(self$1, call) {
	if (call && (_typeof$41(call) === "object" || typeof call === "function")) return call;
	else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
	return _assertThisInitialized$14(self$1);
}
function _assertThisInitialized$14(self$1) {
	if (self$1 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return self$1;
}
function _isNativeReflectConstruct$14() {
	try {
		var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
	} catch (t$1) {}
	return (_isNativeReflectConstruct$14 = function _isNativeReflectConstruct$15() {
		return !!t;
	})();
}
function _getPrototypeOf$14(o) {
	_getPrototypeOf$14 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf$15(o$1) {
		return o$1.__proto__ || Object.getPrototypeOf(o$1);
	};
	return _getPrototypeOf$14(o);
}
function _inherits$14(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
	subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
		value: subClass,
		writable: true,
		configurable: true
	} });
	Object.defineProperty(subClass, "prototype", { writable: false });
	if (superClass) _setPrototypeOf$14(subClass, superClass);
}
function _setPrototypeOf$14(o, p) {
	_setPrototypeOf$14 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf$15(o$1, p$1) {
		o$1.__proto__ = p$1;
		return o$1;
	};
	return _setPrototypeOf$14(o, p);
}
function _defineProperty$38(obj, key, value) {
	key = _toPropertyKey$39(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$39(t) {
	var i = _toPrimitive$39(t, "string");
	return "symbol" == _typeof$41(i) ? i : i + "";
}
function _toPrimitive$39(t, r) {
	if ("object" != _typeof$41(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$41(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
var SIZE = 32;
var DefaultLegendContent = /* @__PURE__ */ function(_PureComponent) {
	function DefaultLegendContent$1() {
		_classCallCheck$17(this, DefaultLegendContent$1);
		return _callSuper$13(this, DefaultLegendContent$1, arguments);
	}
	_inherits$14(DefaultLegendContent$1, _PureComponent);
	return _createClass$17(DefaultLegendContent$1, [
		{
			key: "renderIcon",
			value: function renderIcon(data) {
				var inactiveColor = this.props.inactiveColor;
				var halfSize = SIZE / 2;
				var sixthSize = SIZE / 6;
				var thirdSize = SIZE / 3;
				var color$1 = data.inactive ? inactiveColor : data.color;
				if (data.type === "plainline") return /* @__PURE__ */ import_react.createElement("line", {
					strokeWidth: 4,
					fill: "none",
					stroke: color$1,
					strokeDasharray: data.payload.strokeDasharray,
					x1: 0,
					y1: halfSize,
					x2: SIZE,
					y2: halfSize,
					className: "recharts-legend-icon"
				});
				if (data.type === "line") return /* @__PURE__ */ import_react.createElement("path", {
					strokeWidth: 4,
					fill: "none",
					stroke: color$1,
					d: "M0,".concat(halfSize, "h").concat(thirdSize, "\n            A").concat(sixthSize, ",").concat(sixthSize, ",0,1,1,").concat(2 * thirdSize, ",").concat(halfSize, "\n            H").concat(SIZE, "M").concat(2 * thirdSize, ",").concat(halfSize, "\n            A").concat(sixthSize, ",").concat(sixthSize, ",0,1,1,").concat(thirdSize, ",").concat(halfSize),
					className: "recharts-legend-icon"
				});
				if (data.type === "rect") return /* @__PURE__ */ import_react.createElement("path", {
					stroke: "none",
					fill: color$1,
					d: "M0,".concat(SIZE / 8, "h").concat(SIZE, "v").concat(SIZE * 3 / 4, "h").concat(-SIZE, "z"),
					className: "recharts-legend-icon"
				});
				if (/* @__PURE__ */ import_react.isValidElement(data.legendIcon)) {
					var iconProps = _objectSpread$33({}, data);
					delete iconProps.legendIcon;
					return /* @__PURE__ */ import_react.cloneElement(data.legendIcon, iconProps);
				}
				return /* @__PURE__ */ import_react.createElement(Symbols, {
					fill: color$1,
					cx: halfSize,
					cy: halfSize,
					size: SIZE,
					sizeType: "diameter",
					type: data.type
				});
			}
		},
		{
			key: "renderItems",
			value: function renderItems() {
				var _this = this;
				var _this$props = this.props, payload = _this$props.payload, iconSize = _this$props.iconSize, layout = _this$props.layout, formatter = _this$props.formatter, inactiveColor = _this$props.inactiveColor;
				var viewBox = {
					x: 0,
					y: 0,
					width: SIZE,
					height: SIZE
				};
				var itemStyle = {
					display: layout === "horizontal" ? "inline-block" : "block",
					marginRight: 10
				};
				var svgStyle = {
					display: "inline-block",
					verticalAlign: "middle",
					marginRight: 4
				};
				return payload.map(function(entry, i) {
					var finalFormatter = entry.formatter || formatter;
					var className = clsx_default(_defineProperty$38(_defineProperty$38({ "recharts-legend-item": true }, "legend-item-".concat(i), true), "inactive", entry.inactive));
					if (entry.type === "none") return null;
					var entryValue = !(0, import_isFunction$15.default)(entry.value) ? entry.value : null;
					warn(!(0, import_isFunction$15.default)(entry.value), "The name property is also required when using a function for the dataKey of a chart's cartesian components. Ex: <Bar name=\"Name of my Data\"/>");
					var color$1 = entry.inactive ? inactiveColor : entry.color;
					return /* @__PURE__ */ import_react.createElement("li", _extends$22({
						className,
						style: itemStyle,
						key: "legend-item-".concat(i)
					}, adaptEventsOfChild(_this.props, entry, i)), /* @__PURE__ */ import_react.createElement(Surface, {
						width: iconSize,
						height: iconSize,
						viewBox,
						style: svgStyle
					}, _this.renderIcon(entry)), /* @__PURE__ */ import_react.createElement("span", {
						className: "recharts-legend-item-text",
						style: { color: color$1 }
					}, finalFormatter ? finalFormatter(entryValue, entry, i) : entryValue));
				});
			}
		},
		{
			key: "render",
			value: function render() {
				var _this$props2 = this.props, payload = _this$props2.payload, layout = _this$props2.layout, align = _this$props2.align;
				if (!payload || !payload.length) return null;
				var finalStyle = {
					padding: 0,
					margin: 0,
					textAlign: layout === "horizontal" ? align : "left"
				};
				return /* @__PURE__ */ import_react.createElement("ul", {
					className: "recharts-default-legend",
					style: finalStyle
				}, this.renderItems());
			}
		}
	]);
}(import_react.PureComponent);
_defineProperty$38(DefaultLegendContent, "displayName", "Legend");
_defineProperty$38(DefaultLegendContent, "defaultProps", {
	iconSize: 14,
	layout: "horizontal",
	align: "center",
	verticalAlign: "middle",
	inactiveColor: "#ccc"
});
var require__stackClear = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var ListCache$2 = require__ListCache();
	function stackClear$1() {
		this.__data__ = new ListCache$2();
		this.size = 0;
	}
	module.exports = stackClear$1;
}));
var require__stackDelete = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function stackDelete$1(key) {
		var data = this.__data__, result = data["delete"](key);
		this.size = data.size;
		return result;
	}
	module.exports = stackDelete$1;
}));
var require__stackGet = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function stackGet$1(key) {
		return this.__data__.get(key);
	}
	module.exports = stackGet$1;
}));
var require__stackHas = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function stackHas$1(key) {
		return this.__data__.has(key);
	}
	module.exports = stackHas$1;
}));
var require__stackSet = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var ListCache$1 = require__ListCache(), Map$2 = require__Map(), MapCache$1 = require__MapCache();
	var LARGE_ARRAY_SIZE$1 = 200;
	function stackSet$1(key, value) {
		var data = this.__data__;
		if (data instanceof ListCache$1) {
			var pairs = data.__data__;
			if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
				pairs.push([key, value]);
				this.size = ++data.size;
				return this;
			}
			data = this.__data__ = new MapCache$1(pairs);
		}
		data.set(key, value);
		this.size = data.size;
		return this;
	}
	module.exports = stackSet$1;
}));
var require__Stack = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var ListCache = require__ListCache(), stackClear = require__stackClear(), stackDelete = require__stackDelete(), stackGet = require__stackGet(), stackHas = require__stackHas(), stackSet = require__stackSet();
	function Stack$2(entries) {
		this.size = (this.__data__ = new ListCache(entries)).size;
	}
	Stack$2.prototype.clear = stackClear;
	Stack$2.prototype["delete"] = stackDelete;
	Stack$2.prototype.get = stackGet;
	Stack$2.prototype.has = stackHas;
	Stack$2.prototype.set = stackSet;
	module.exports = Stack$2;
}));
var require__setCacheAdd = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var HASH_UNDEFINED = "__lodash_hash_undefined__";
	function setCacheAdd$1(value) {
		this.__data__.set(value, HASH_UNDEFINED);
		return this;
	}
	module.exports = setCacheAdd$1;
}));
var require__setCacheHas = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function setCacheHas$1(value) {
		return this.__data__.has(value);
	}
	module.exports = setCacheHas$1;
}));
var require__SetCache = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var MapCache = require__MapCache(), setCacheAdd = require__setCacheAdd(), setCacheHas = require__setCacheHas();
	function SetCache$2(values) {
		var index = -1, length = values == null ? 0 : values.length;
		this.__data__ = new MapCache();
		while (++index < length) this.add(values[index]);
	}
	SetCache$2.prototype.add = SetCache$2.prototype.push = setCacheAdd;
	SetCache$2.prototype.has = setCacheHas;
	module.exports = SetCache$2;
}));
var require__arraySome = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function arraySome$2(array, predicate) {
		var index = -1, length = array == null ? 0 : array.length;
		while (++index < length) if (predicate(array[index], index, array)) return true;
		return false;
	}
	module.exports = arraySome$2;
}));
var require__cacheHas = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function cacheHas$2(cache, key) {
		return cache.has(key);
	}
	module.exports = cacheHas$2;
}));
var require__equalArrays = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var SetCache$1 = require__SetCache(), arraySome$1 = require__arraySome(), cacheHas$1 = require__cacheHas();
	var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
	function equalArrays$2(array, other, bitmask, customizer, equalFunc, stack) {
		var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
		if (arrLength != othLength && !(isPartial && othLength > arrLength)) return false;
		var arrStacked = stack.get(array);
		var othStacked = stack.get(other);
		if (arrStacked && othStacked) return arrStacked == other && othStacked == array;
		var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache$1() : void 0;
		stack.set(array, other);
		stack.set(other, array);
		while (++index < arrLength) {
			var arrValue = array[index], othValue = other[index];
			if (customizer) var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
			if (compared !== void 0) {
				if (compared) continue;
				result = false;
				break;
			}
			if (seen) {
				if (!arraySome$1(other, function(othValue$1, othIndex) {
					if (!cacheHas$1(seen, othIndex) && (arrValue === othValue$1 || equalFunc(arrValue, othValue$1, bitmask, customizer, stack))) return seen.push(othIndex);
				})) {
					result = false;
					break;
				}
			} else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
				result = false;
				break;
			}
		}
		stack["delete"](array);
		stack["delete"](other);
		return result;
	}
	module.exports = equalArrays$2;
}));
var require__Uint8Array = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__root().Uint8Array;
}));
var require__mapToArray = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function mapToArray$1(map$4) {
		var index = -1, result = Array(map$4.size);
		map$4.forEach(function(value, key) {
			result[++index] = [key, value];
		});
		return result;
	}
	module.exports = mapToArray$1;
}));
var require__setToArray = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function setToArray$3(set) {
		var index = -1, result = Array(set.size);
		set.forEach(function(value) {
			result[++index] = value;
		});
		return result;
	}
	module.exports = setToArray$3;
}));
var require__equalByTag = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Symbol$2 = require__Symbol(), Uint8Array$1 = require__Uint8Array(), eq$1 = require_eq(), equalArrays$1 = require__equalArrays(), mapToArray = require__mapToArray(), setToArray$2 = require__setToArray();
	var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
	var boolTag$2 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag = "[object Symbol]";
	var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]";
	var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
	function equalByTag$1(object, other, tag, bitmask, customizer, equalFunc, stack) {
		switch (tag) {
			case dataViewTag$2:
				if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) return false;
				object = object.buffer;
				other = other.buffer;
			case arrayBufferTag$1:
				if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) return false;
				return true;
			case boolTag$2:
			case dateTag$1:
			case numberTag$1: return eq$1(+object, +other);
			case errorTag$1: return object.name == other.name && object.message == other.message;
			case regexpTag$1:
			case stringTag$1: return object == other + "";
			case mapTag$2: var convert = mapToArray;
			case setTag$2:
				var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
				convert || (convert = setToArray$2);
				if (object.size != other.size && !isPartial) return false;
				var stacked = stack.get(object);
				if (stacked) return stacked == other;
				bitmask |= COMPARE_UNORDERED_FLAG$2;
				stack.set(object, other);
				var result = equalArrays$1(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
				stack["delete"](object);
				return result;
			case symbolTag: if (symbolValueOf) return symbolValueOf.call(object) == symbolValueOf.call(other);
		}
		return false;
	}
	module.exports = equalByTag$1;
}));
var require__arrayPush = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function arrayPush$2(array, values) {
		var index = -1, length = values.length, offset = array.length;
		while (++index < length) array[offset + index] = values[index];
		return array;
	}
	module.exports = arrayPush$2;
}));
var require__baseGetAllKeys = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var arrayPush$1 = require__arrayPush(), isArray$9 = require_isArray();
	function baseGetAllKeys$1(object, keysFunc, symbolsFunc) {
		var result = keysFunc(object);
		return isArray$9(object) ? result : arrayPush$1(result, symbolsFunc(object));
	}
	module.exports = baseGetAllKeys$1;
}));
var require__arrayFilter = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function arrayFilter$1(array, predicate) {
		var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
		while (++index < length) {
			var value = array[index];
			if (predicate(value, index, array)) result[resIndex++] = value;
		}
		return result;
	}
	module.exports = arrayFilter$1;
}));
var require_stubArray = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function stubArray$1() {
		return [];
	}
	module.exports = stubArray$1;
}));
var require__getSymbols = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var arrayFilter = require__arrayFilter(), stubArray = require_stubArray();
	var propertyIsEnumerable$1 = Object.prototype.propertyIsEnumerable;
	var nativeGetSymbols = Object.getOwnPropertySymbols;
	module.exports = !nativeGetSymbols ? stubArray : function(object) {
		if (object == null) return [];
		object = Object(object);
		return arrayFilter(nativeGetSymbols(object), function(symbol) {
			return propertyIsEnumerable$1.call(object, symbol);
		});
	};
}));
var require__baseTimes = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function baseTimes$1(n, iteratee) {
		var index = -1, result = Array(n);
		while (++index < n) result[index] = iteratee(index);
		return result;
	}
	module.exports = baseTimes$1;
}));
var require__baseIsArguments = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseGetTag$4 = require__baseGetTag(), isObjectLike$5 = require_isObjectLike();
	var argsTag$2 = "[object Arguments]";
	function baseIsArguments$1(value) {
		return isObjectLike$5(value) && baseGetTag$4(value) == argsTag$2;
	}
	module.exports = baseIsArguments$1;
}));
var require_isArguments = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseIsArguments = require__baseIsArguments(), isObjectLike$4 = require_isObjectLike();
	var objectProto$2 = Object.prototype;
	var hasOwnProperty$7 = objectProto$2.hasOwnProperty;
	var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;
	module.exports = baseIsArguments(function() {
		return arguments;
	}()) ? baseIsArguments : function(value) {
		return isObjectLike$4(value) && hasOwnProperty$7.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
	};
}));
var require_stubFalse = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function stubFalse$1() {
		return false;
	}
	module.exports = stubFalse$1;
}));
var require_isBuffer = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var root$1 = require__root(), stubFalse = require_stubFalse();
	var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
	var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
	var Buffer = freeModule$1 && freeModule$1.exports === freeExports$1 ? root$1.Buffer : void 0;
	module.exports = (Buffer ? Buffer.isBuffer : void 0) || stubFalse;
}));
var require__isIndex = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var MAX_SAFE_INTEGER$1 = 9007199254740991;
	var reIsUint = /^(?:0|[1-9]\d*)$/;
	function isIndex$3(value, length) {
		var type = typeof value;
		length = length == null ? MAX_SAFE_INTEGER$1 : length;
		return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
	}
	module.exports = isIndex$3;
}));
var require_isLength = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var MAX_SAFE_INTEGER = 9007199254740991;
	function isLength$3(value) {
		return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}
	module.exports = isLength$3;
}));
var require__baseIsTypedArray = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseGetTag$3 = require__baseGetTag(), isLength$2 = require_isLength(), isObjectLike$3 = require_isObjectLike();
	var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag$1 = "[object Map]", numberTag = "[object Number]", objectTag$3 = "[object Object]", regexpTag = "[object RegExp]", setTag$1 = "[object Set]", stringTag = "[object String]", weakMapTag$1 = "[object WeakMap]";
	var arrayBufferTag = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag$1] = typedArrayTags[numberTag] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag] = typedArrayTags[setTag$1] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag$1] = false;
	function baseIsTypedArray$1(value) {
		return isObjectLike$3(value) && isLength$2(value.length) && !!typedArrayTags[baseGetTag$3(value)];
	}
	module.exports = baseIsTypedArray$1;
}));
var require__baseUnary = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function baseUnary$2(func) {
		return function(value) {
			return func(value);
		};
	}
	module.exports = baseUnary$2;
}));
var require__nodeUtil = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var freeGlobal = require__freeGlobal();
	var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
	var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
	var freeProcess = freeModule && freeModule.exports === freeExports && freeGlobal.process;
	module.exports = function() {
		try {
			var types = freeModule && freeModule.require && freeModule.require("util").types;
			if (types) return types;
			return freeProcess && freeProcess.binding && freeProcess.binding("util");
		} catch (e) {}
	}();
}));
var require_isTypedArray = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseIsTypedArray = require__baseIsTypedArray(), baseUnary$1 = require__baseUnary(), nodeUtil = require__nodeUtil();
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
	module.exports = nodeIsTypedArray ? baseUnary$1(nodeIsTypedArray) : baseIsTypedArray;
}));
var require__arrayLikeKeys = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseTimes = require__baseTimes(), isArguments$2 = require_isArguments(), isArray$8 = require_isArray(), isBuffer$1 = require_isBuffer(), isIndex$2 = require__isIndex(), isTypedArray$1 = require_isTypedArray();
	var hasOwnProperty$6 = Object.prototype.hasOwnProperty;
	function arrayLikeKeys$1(value, inherited) {
		var isArr = isArray$8(value), isArg = !isArr && isArguments$2(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
		for (var key in value) if ((inherited || hasOwnProperty$6.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex$2(key, length)))) result.push(key);
		return result;
	}
	module.exports = arrayLikeKeys$1;
}));
var require__isPrototype = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var objectProto$1 = Object.prototype;
	function isPrototype$1(value) {
		var Ctor = value && value.constructor;
		return value === (typeof Ctor == "function" && Ctor.prototype || objectProto$1);
	}
	module.exports = isPrototype$1;
}));
var require__overArg = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function overArg(func, transform) {
		return function(arg) {
			return func(transform(arg));
		};
	}
	module.exports = overArg;
}));
var require__nativeKeys = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__overArg()(Object.keys, Object);
}));
var require__baseKeys = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isPrototype = require__isPrototype(), nativeKeys = require__nativeKeys();
	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	function baseKeys$1(object) {
		if (!isPrototype(object)) return nativeKeys(object);
		var result = [];
		for (var key in Object(object)) if (hasOwnProperty$5.call(object, key) && key != "constructor") result.push(key);
		return result;
	}
	module.exports = baseKeys$1;
}));
var require_isArrayLike = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isFunction$15 = require_isFunction(), isLength$1 = require_isLength();
	function isArrayLike$5(value) {
		return value != null && isLength$1(value.length) && !isFunction$15(value);
	}
	module.exports = isArrayLike$5;
}));
var require_keys = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var arrayLikeKeys = require__arrayLikeKeys(), baseKeys = require__baseKeys(), isArrayLike$4 = require_isArrayLike();
	function keys$5(object) {
		return isArrayLike$4(object) ? arrayLikeKeys(object) : baseKeys(object);
	}
	module.exports = keys$5;
}));
var require__getAllKeys = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseGetAllKeys = require__baseGetAllKeys(), getSymbols = require__getSymbols(), keys$4 = require_keys();
	function getAllKeys$1(object) {
		return baseGetAllKeys(object, keys$4, getSymbols);
	}
	module.exports = getAllKeys$1;
}));
var require__equalObjects = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var getAllKeys = require__getAllKeys();
	var COMPARE_PARTIAL_FLAG$3 = 1;
	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	function equalObjects$1(object, other, bitmask, customizer, equalFunc, stack) {
		var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length;
		if (objLength != getAllKeys(other).length && !isPartial) return false;
		var index = objLength;
		while (index--) {
			var key = objProps[index];
			if (!(isPartial ? key in other : hasOwnProperty$4.call(other, key))) return false;
		}
		var objStacked = stack.get(object);
		var othStacked = stack.get(other);
		if (objStacked && othStacked) return objStacked == other && othStacked == object;
		var result = true;
		stack.set(object, other);
		stack.set(other, object);
		var skipCtor = isPartial;
		while (++index < objLength) {
			key = objProps[index];
			var objValue = object[key], othValue = other[key];
			if (customizer) var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
			if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
				result = false;
				break;
			}
			skipCtor || (skipCtor = key == "constructor");
		}
		if (result && !skipCtor) {
			var objCtor = object.constructor, othCtor = other.constructor;
			if (objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) result = false;
		}
		stack["delete"](object);
		stack["delete"](other);
		return result;
	}
	module.exports = equalObjects$1;
}));
var require__DataView = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__getNative()(require__root(), "DataView");
}));
var require__Promise = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__getNative()(require__root(), "Promise");
}));
var require__Set = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__getNative()(require__root(), "Set");
}));
var require__WeakMap = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__getNative()(require__root(), "WeakMap");
}));
var require__getTag = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var DataView$1 = require__DataView(), Map$1 = require__Map(), Promise$1 = require__Promise(), Set$2 = require__Set(), WeakMap$1 = require__WeakMap(), baseGetTag$2 = require__baseGetTag(), toSource = require__toSource();
	var mapTag = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
	var dataViewTag = "[object DataView]";
	var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$1);
	var getTag$1 = baseGetTag$2;
	if (DataView$1 && getTag$1(new DataView$1(/* @__PURE__ */ new ArrayBuffer(1))) != dataViewTag || Map$1 && getTag$1(new Map$1()) != mapTag || Promise$1 && getTag$1(Promise$1.resolve()) != promiseTag || Set$2 && getTag$1(new Set$2()) != setTag || WeakMap$1 && getTag$1(new WeakMap$1()) != weakMapTag) getTag$1 = function(value) {
		var result = baseGetTag$2(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
		if (ctorString) switch (ctorString) {
			case dataViewCtorString: return dataViewTag;
			case mapCtorString: return mapTag;
			case promiseCtorString: return promiseTag;
			case setCtorString: return setTag;
			case weakMapCtorString: return weakMapTag;
		}
		return result;
	};
	module.exports = getTag$1;
}));
var require__baseIsEqualDeep = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Stack$1 = require__Stack(), equalArrays = require__equalArrays(), equalByTag = require__equalByTag(), equalObjects = require__equalObjects(), getTag = require__getTag(), isArray$7 = require_isArray(), isBuffer = require_isBuffer(), isTypedArray = require_isTypedArray();
	var COMPARE_PARTIAL_FLAG$2 = 1;
	var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag$1 = "[object Object]";
	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;
	function baseIsEqualDeep$1(object, other, bitmask, customizer, equalFunc, stack) {
		var objIsArr = isArray$7(object), othIsArr = isArray$7(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
		objTag = objTag == argsTag ? objectTag$1 : objTag;
		othTag = othTag == argsTag ? objectTag$1 : othTag;
		var objIsObj = objTag == objectTag$1, othIsObj = othTag == objectTag$1, isSameTag = objTag == othTag;
		if (isSameTag && isBuffer(object)) {
			if (!isBuffer(other)) return false;
			objIsArr = true;
			objIsObj = false;
		}
		if (isSameTag && !objIsObj) {
			stack || (stack = new Stack$1());
			return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
		}
		if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
			var objIsWrapped = objIsObj && hasOwnProperty$3.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$3.call(other, "__wrapped__");
			if (objIsWrapped || othIsWrapped) {
				var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
				stack || (stack = new Stack$1());
				return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
			}
		}
		if (!isSameTag) return false;
		stack || (stack = new Stack$1());
		return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}
	module.exports = baseIsEqualDeep$1;
}));
var require__baseIsEqual = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseIsEqualDeep = require__baseIsEqualDeep(), isObjectLike$2 = require_isObjectLike();
	function baseIsEqual$3(value, other, bitmask, customizer, stack) {
		if (value === other) return true;
		if (value == null || other == null || !isObjectLike$2(value) && !isObjectLike$2(other)) return value !== value && other !== other;
		return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$3, stack);
	}
	module.exports = baseIsEqual$3;
}));
var require__baseIsMatch = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Stack = require__Stack(), baseIsEqual$2 = require__baseIsEqual();
	var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
	function baseIsMatch$1(object, source, matchData, customizer) {
		var index = matchData.length, length = index, noCustomizer = !customizer;
		if (object == null) return !length;
		object = Object(object);
		while (index--) {
			var data = matchData[index];
			if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) return false;
		}
		while (++index < length) {
			data = matchData[index];
			var key = data[0], objValue = object[key], srcValue = data[1];
			if (noCustomizer && data[2]) {
				if (objValue === void 0 && !(key in object)) return false;
			} else {
				var stack = new Stack();
				if (customizer) var result = customizer(objValue, srcValue, key, object, source, stack);
				if (!(result === void 0 ? baseIsEqual$2(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) return false;
			}
		}
		return true;
	}
	module.exports = baseIsMatch$1;
}));
var require__isStrictComparable = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isObject$6 = require_isObject();
	function isStrictComparable$2(value) {
		return value === value && !isObject$6(value);
	}
	module.exports = isStrictComparable$2;
}));
var require__getMatchData = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isStrictComparable$1 = require__isStrictComparable(), keys$3 = require_keys();
	function getMatchData$1(object) {
		var result = keys$3(object), length = result.length;
		while (length--) {
			var key = result[length], value = object[key];
			result[length] = [
				key,
				value,
				isStrictComparable$1(value)
			];
		}
		return result;
	}
	module.exports = getMatchData$1;
}));
var require__matchesStrictComparable = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function matchesStrictComparable$2(key, srcValue) {
		return function(object) {
			if (object == null) return false;
			return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
		};
	}
	module.exports = matchesStrictComparable$2;
}));
var require__baseMatches = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseIsMatch = require__baseIsMatch(), getMatchData = require__getMatchData(), matchesStrictComparable$1 = require__matchesStrictComparable();
	function baseMatches$1(source) {
		var matchData = getMatchData(source);
		if (matchData.length == 1 && matchData[0][2]) return matchesStrictComparable$1(matchData[0][0], matchData[0][1]);
		return function(object) {
			return object === source || baseIsMatch(object, source, matchData);
		};
	}
	module.exports = baseMatches$1;
}));
var require__baseHasIn = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function baseHasIn$1(object, key) {
		return object != null && key in Object(object);
	}
	module.exports = baseHasIn$1;
}));
var require__hasPath = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var castPath = require__castPath(), isArguments$1 = require_isArguments(), isArray$6 = require_isArray(), isIndex$1 = require__isIndex(), isLength = require_isLength(), toKey$2 = require__toKey();
	function hasPath$1(object, path$1, hasFunc) {
		path$1 = castPath(path$1, object);
		var index = -1, length = path$1.length, result = false;
		while (++index < length) {
			var key = toKey$2(path$1[index]);
			if (!(result = object != null && hasFunc(object, key))) break;
			object = object[key];
		}
		if (result || ++index != length) return result;
		length = object == null ? 0 : object.length;
		return !!length && isLength(length) && isIndex$1(key, length) && (isArray$6(object) || isArguments$1(object));
	}
	module.exports = hasPath$1;
}));
var require_hasIn = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseHasIn = require__baseHasIn(), hasPath = require__hasPath();
	function hasIn$1(object, path$1) {
		return object != null && hasPath(object, path$1, baseHasIn);
	}
	module.exports = hasIn$1;
}));
var require__baseMatchesProperty = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseIsEqual$1 = require__baseIsEqual(), get$3 = require_get(), hasIn = require_hasIn(), isKey$1 = require__isKey(), isStrictComparable = require__isStrictComparable(), matchesStrictComparable = require__matchesStrictComparable(), toKey$1 = require__toKey();
	var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
	function baseMatchesProperty$1(path$1, srcValue) {
		if (isKey$1(path$1) && isStrictComparable(srcValue)) return matchesStrictComparable(toKey$1(path$1), srcValue);
		return function(object) {
			var objValue = get$3(object, path$1);
			return objValue === void 0 && objValue === srcValue ? hasIn(object, path$1) : baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
		};
	}
	module.exports = baseMatchesProperty$1;
}));
var require_identity = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function identity$10(value) {
		return value;
	}
	module.exports = identity$10;
}));
var require__baseProperty = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function baseProperty$1(key) {
		return function(object) {
			return object == null ? void 0 : object[key];
		};
	}
	module.exports = baseProperty$1;
}));
var require__basePropertyDeep = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseGet$1 = require__baseGet();
	function basePropertyDeep$1(path$1) {
		return function(object) {
			return baseGet$1(object, path$1);
		};
	}
	module.exports = basePropertyDeep$1;
}));
var require_property = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseProperty = require__baseProperty(), basePropertyDeep = require__basePropertyDeep(), isKey = require__isKey(), toKey = require__toKey();
	function property$1(path$1) {
		return isKey(path$1) ? baseProperty(toKey(path$1)) : basePropertyDeep(path$1);
	}
	module.exports = property$1;
}));
var require__baseIteratee = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseMatches = require__baseMatches(), baseMatchesProperty = require__baseMatchesProperty(), identity$9 = require_identity(), isArray$5 = require_isArray(), property = require_property();
	function baseIteratee$8(value) {
		if (typeof value == "function") return value;
		if (value == null) return identity$9;
		if (typeof value == "object") return isArray$5(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
		return property(value);
	}
	module.exports = baseIteratee$8;
}));
var require__baseFindIndex = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function baseFindIndex$2(array, predicate, fromIndex, fromRight) {
		var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
		while (fromRight ? index-- : ++index < length) if (predicate(array[index], index, array)) return index;
		return -1;
	}
	module.exports = baseFindIndex$2;
}));
var require__baseIsNaN = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function baseIsNaN$1(value) {
		return value !== value;
	}
	module.exports = baseIsNaN$1;
}));
var require__strictIndexOf = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function strictIndexOf$1(array, value, fromIndex) {
		var index = fromIndex - 1, length = array.length;
		while (++index < length) if (array[index] === value) return index;
		return -1;
	}
	module.exports = strictIndexOf$1;
}));
var require__baseIndexOf = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseFindIndex$1 = require__baseFindIndex(), baseIsNaN = require__baseIsNaN(), strictIndexOf = require__strictIndexOf();
	function baseIndexOf$1(array, value, fromIndex) {
		return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex$1(array, baseIsNaN, fromIndex);
	}
	module.exports = baseIndexOf$1;
}));
var require__arrayIncludes = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseIndexOf = require__baseIndexOf();
	function arrayIncludes$1(array, value) {
		return !!(array == null ? 0 : array.length) && baseIndexOf(array, value, 0) > -1;
	}
	module.exports = arrayIncludes$1;
}));
var require__arrayIncludesWith = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function arrayIncludesWith$1(array, value, comparator) {
		var index = -1, length = array == null ? 0 : array.length;
		while (++index < length) if (comparator(value, array[index])) return true;
		return false;
	}
	module.exports = arrayIncludesWith$1;
}));
var require_noop = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function noop$1() {}
	module.exports = noop$1;
}));
var require__createSet = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Set$1 = require__Set(), noop = require_noop(), setToArray$1 = require__setToArray();
	module.exports = !(Set$1 && 1 / setToArray$1(new Set$1([, -0]))[1] == Infinity) ? noop : function(values) {
		return new Set$1(values);
	};
}));
var require__baseUniq = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var SetCache = require__SetCache(), arrayIncludes = require__arrayIncludes(), arrayIncludesWith = require__arrayIncludesWith(), cacheHas = require__cacheHas(), createSet = require__createSet(), setToArray = require__setToArray();
	var LARGE_ARRAY_SIZE = 200;
	function baseUniq$1(array, iteratee, comparator) {
		var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
		if (comparator) {
			isCommon = false;
			includes = arrayIncludesWith;
		} else if (length >= LARGE_ARRAY_SIZE) {
			var set = iteratee ? null : createSet(array);
			if (set) return setToArray(set);
			isCommon = false;
			includes = cacheHas;
			seen = new SetCache();
		} else seen = iteratee ? [] : result;
		outer: while (++index < length) {
			var value = array[index], computed = iteratee ? iteratee(value) : value;
			value = comparator || value !== 0 ? value : 0;
			if (isCommon && computed === computed) {
				var seenIndex = seen.length;
				while (seenIndex--) if (seen[seenIndex] === computed) continue outer;
				if (iteratee) seen.push(computed);
				result.push(value);
			} else if (!includes(seen, computed, comparator)) {
				if (seen !== result) seen.push(computed);
				result.push(value);
			}
		}
		return result;
	}
	module.exports = baseUniq$1;
}));
var import_uniqBy = /* @__PURE__ */ __toESM((/* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseIteratee$7 = require__baseIteratee(), baseUniq = require__baseUniq();
	function uniqBy$1(array, iteratee) {
		return array && array.length ? baseUniq(array, baseIteratee$7(iteratee, 2)) : [];
	}
	module.exports = uniqBy$1;
})))());
var import_isFunction$14 = /* @__PURE__ */ __toESM(require_isFunction());
function getUniqPayload(payload, option, defaultUniqBy$2) {
	if (option === true) return (0, import_uniqBy.default)(payload, defaultUniqBy$2);
	if ((0, import_isFunction$14.default)(option)) return (0, import_uniqBy.default)(payload, option);
	return payload;
}
function _typeof$40(o) {
	"@babel/helpers - typeof";
	return _typeof$40 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$40(o);
}
var _excluded$12 = ["ref"];
function ownKeys$32(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$32(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$32(Object(t), !0).forEach(function(r$1) {
			_defineProperty$37(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$32(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}
function _classCallCheck$16(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$16(target, props) {
	for (var i = 0; i < props.length; i++) {
		var descriptor = props[i];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$38(descriptor.key), descriptor);
	}
}
function _createClass$16(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$16(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$16(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _callSuper$12(t, o, e) {
	return o = _getPrototypeOf$13(o), _possibleConstructorReturn$13(t, _isNativeReflectConstruct$13() ? Reflect.construct(o, e || [], _getPrototypeOf$13(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn$13(self$1, call) {
	if (call && (_typeof$40(call) === "object" || typeof call === "function")) return call;
	else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
	return _assertThisInitialized$13(self$1);
}
function _assertThisInitialized$13(self$1) {
	if (self$1 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return self$1;
}
function _isNativeReflectConstruct$13() {
	try {
		var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
	} catch (t$1) {}
	return (_isNativeReflectConstruct$13 = function _isNativeReflectConstruct$15() {
		return !!t;
	})();
}
function _getPrototypeOf$13(o) {
	_getPrototypeOf$13 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf$15(o$1) {
		return o$1.__proto__ || Object.getPrototypeOf(o$1);
	};
	return _getPrototypeOf$13(o);
}
function _inherits$13(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
	subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
		value: subClass,
		writable: true,
		configurable: true
	} });
	Object.defineProperty(subClass, "prototype", { writable: false });
	if (superClass) _setPrototypeOf$13(subClass, superClass);
}
function _setPrototypeOf$13(o, p) {
	_setPrototypeOf$13 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf$15(o$1, p$1) {
		o$1.__proto__ = p$1;
		return o$1;
	};
	return _setPrototypeOf$13(o, p);
}
function _defineProperty$37(obj, key, value) {
	key = _toPropertyKey$38(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$38(t) {
	var i = _toPrimitive$38(t, "string");
	return "symbol" == _typeof$40(i) ? i : i + "";
}
function _toPrimitive$38(t, r) {
	if ("object" != _typeof$40(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$40(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
function _objectWithoutProperties$12(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$12(source, excluded);
	var key, i;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i = 0; i < sourceSymbolKeys.length; i++) {
			key = sourceSymbolKeys[i];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$12(source, excluded) {
	if (source == null) return {};
	var target = {};
	for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function defaultUniqBy$1(entry) {
	return entry.value;
}
function renderContent$1(content, props) {
	if (/* @__PURE__ */ import_react.isValidElement(content)) return /* @__PURE__ */ import_react.cloneElement(content, props);
	if (typeof content === "function") return /* @__PURE__ */ import_react.createElement(content, props);
	props.ref;
	var otherProps = _objectWithoutProperties$12(props, _excluded$12);
	return /* @__PURE__ */ import_react.createElement(DefaultLegendContent, otherProps);
}
var EPS$1 = 1;
var Legend = /* @__PURE__ */ function(_PureComponent) {
	function Legend$1() {
		var _this;
		_classCallCheck$16(this, Legend$1);
		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
		_this = _callSuper$12(this, Legend$1, [].concat(args));
		_defineProperty$37(_this, "lastBoundingBox", {
			width: -1,
			height: -1
		});
		return _this;
	}
	_inherits$13(Legend$1, _PureComponent);
	return _createClass$16(Legend$1, [
		{
			key: "componentDidMount",
			value: function componentDidMount() {
				this.updateBBox();
			}
		},
		{
			key: "componentDidUpdate",
			value: function componentDidUpdate() {
				this.updateBBox();
			}
		},
		{
			key: "getBBox",
			value: function getBBox() {
				if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) {
					var box = this.wrapperNode.getBoundingClientRect();
					box.height = this.wrapperNode.offsetHeight;
					box.width = this.wrapperNode.offsetWidth;
					return box;
				}
				return null;
			}
		},
		{
			key: "updateBBox",
			value: function updateBBox() {
				var onBBoxUpdate = this.props.onBBoxUpdate;
				var box = this.getBBox();
				if (box) {
					if (Math.abs(box.width - this.lastBoundingBox.width) > EPS$1 || Math.abs(box.height - this.lastBoundingBox.height) > EPS$1) {
						this.lastBoundingBox.width = box.width;
						this.lastBoundingBox.height = box.height;
						if (onBBoxUpdate) onBBoxUpdate(box);
					}
				} else if (this.lastBoundingBox.width !== -1 || this.lastBoundingBox.height !== -1) {
					this.lastBoundingBox.width = -1;
					this.lastBoundingBox.height = -1;
					if (onBBoxUpdate) onBBoxUpdate(null);
				}
			}
		},
		{
			key: "getBBoxSnapshot",
			value: function getBBoxSnapshot() {
				if (this.lastBoundingBox.width >= 0 && this.lastBoundingBox.height >= 0) return _objectSpread$32({}, this.lastBoundingBox);
				return {
					width: 0,
					height: 0
				};
			}
		},
		{
			key: "getDefaultPosition",
			value: function getDefaultPosition(style) {
				var _this$props = this.props, layout = _this$props.layout, align = _this$props.align, verticalAlign = _this$props.verticalAlign, margin = _this$props.margin, chartWidth = _this$props.chartWidth, chartHeight = _this$props.chartHeight;
				var hPos, vPos;
				if (!style || (style.left === void 0 || style.left === null) && (style.right === void 0 || style.right === null)) if (align === "center" && layout === "vertical") {
					var box = this.getBBoxSnapshot();
					hPos = { left: ((chartWidth || 0) - box.width) / 2 };
				} else hPos = align === "right" ? { right: margin && margin.right || 0 } : { left: margin && margin.left || 0 };
				if (!style || (style.top === void 0 || style.top === null) && (style.bottom === void 0 || style.bottom === null)) if (verticalAlign === "middle") {
					var _box = this.getBBoxSnapshot();
					vPos = { top: ((chartHeight || 0) - _box.height) / 2 };
				} else vPos = verticalAlign === "bottom" ? { bottom: margin && margin.bottom || 0 } : { top: margin && margin.top || 0 };
				return _objectSpread$32(_objectSpread$32({}, hPos), vPos);
			}
		},
		{
			key: "render",
			value: function render() {
				var _this2 = this;
				var _this$props2 = this.props, content = _this$props2.content, width = _this$props2.width, height = _this$props2.height, wrapperStyle = _this$props2.wrapperStyle, payloadUniqBy = _this$props2.payloadUniqBy, payload = _this$props2.payload;
				var outerStyle = _objectSpread$32(_objectSpread$32({
					position: "absolute",
					width: width || "auto",
					height: height || "auto"
				}, this.getDefaultPosition(wrapperStyle)), wrapperStyle);
				return /* @__PURE__ */ import_react.createElement("div", {
					className: "recharts-legend-wrapper",
					style: outerStyle,
					ref: function ref(node) {
						_this2.wrapperNode = node;
					}
				}, renderContent$1(content, _objectSpread$32(_objectSpread$32({}, this.props), {}, { payload: getUniqPayload(payload, payloadUniqBy, defaultUniqBy$1) })));
			}
		}
	], [{
		key: "getWithHeight",
		value: function getWithHeight(item, chartWidth) {
			var layout = _objectSpread$32(_objectSpread$32({}, this.defaultProps), item.props).layout;
			if (layout === "vertical" && isNumber(item.props.height)) return { height: item.props.height };
			if (layout === "horizontal") return { width: item.props.width || chartWidth };
			return null;
		}
	}]);
}(import_react.PureComponent);
_defineProperty$37(Legend, "displayName", "Legend");
_defineProperty$37(Legend, "defaultProps", {
	iconSize: 14,
	layout: "horizontal",
	align: "center",
	verticalAlign: "bottom"
});
var require__isFlattenable = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var Symbol$1 = require__Symbol(), isArguments = require_isArguments(), isArray$4 = require_isArray();
	var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
	function isFlattenable$1(value) {
		return isArray$4(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
	}
	module.exports = isFlattenable$1;
}));
var require__baseFlatten = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var arrayPush = require__arrayPush(), isFlattenable = require__isFlattenable();
	function baseFlatten$2(array, depth, predicate, isStrict, result) {
		var index = -1, length = array.length;
		predicate || (predicate = isFlattenable);
		result || (result = []);
		while (++index < length) {
			var value = array[index];
			if (depth > 0 && predicate(value)) if (depth > 1) baseFlatten$2(value, depth - 1, predicate, isStrict, result);
			else arrayPush(result, value);
			else if (!isStrict) result[result.length] = value;
		}
		return result;
	}
	module.exports = baseFlatten$2;
}));
var require__createBaseFor = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function createBaseFor(fromRight) {
		return function(object, iteratee, keysFunc) {
			var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
			while (length--) {
				var key = props[fromRight ? length : ++index];
				if (iteratee(iterable[key], key, iterable) === false) break;
			}
			return object;
		};
	}
	module.exports = createBaseFor;
}));
var require__baseFor = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__createBaseFor()();
}));
var require__baseForOwn = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseFor = require__baseFor(), keys$2 = require_keys();
	function baseForOwn$2(object, iteratee) {
		return object && baseFor(object, iteratee, keys$2);
	}
	module.exports = baseForOwn$2;
}));
var require__createBaseEach = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isArrayLike$3 = require_isArrayLike();
	function createBaseEach(eachFunc, fromRight) {
		return function(collection, iteratee) {
			if (collection == null) return collection;
			if (!isArrayLike$3(collection)) return eachFunc(collection, iteratee);
			var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
			while (fromRight ? index-- : ++index < length) if (iteratee(iterable[index], index, iterable) === false) break;
			return collection;
		};
	}
	module.exports = createBaseEach;
}));
var require__baseEach = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseForOwn$1 = require__baseForOwn();
	module.exports = require__createBaseEach()(baseForOwn$1);
}));
var require__baseMap = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseEach$2 = require__baseEach(), isArrayLike$2 = require_isArrayLike();
	function baseMap$2(collection, iteratee) {
		var index = -1, result = isArrayLike$2(collection) ? Array(collection.length) : [];
		baseEach$2(collection, function(value, key, collection$1) {
			result[++index] = iteratee(value, key, collection$1);
		});
		return result;
	}
	module.exports = baseMap$2;
}));
var require__baseSortBy = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function baseSortBy$1(array, comparer) {
		var length = array.length;
		array.sort(comparer);
		while (length--) array[length] = array[length].value;
		return array;
	}
	module.exports = baseSortBy$1;
}));
var require__compareAscending = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isSymbol$2 = require_isSymbol();
	function compareAscending$1(value, other) {
		if (value !== other) {
			var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol$2(value);
			var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol$2(other);
			if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) return 1;
			if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) return -1;
		}
		return 0;
	}
	module.exports = compareAscending$1;
}));
var require__compareMultiple = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var compareAscending = require__compareAscending();
	function compareMultiple$1(object, other, orders) {
		var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
		while (++index < length) {
			var result = compareAscending(objCriteria[index], othCriteria[index]);
			if (result) {
				if (index >= ordersLength) return result;
				return result * (orders[index] == "desc" ? -1 : 1);
			}
		}
		return object.index - other.index;
	}
	module.exports = compareMultiple$1;
}));
var require__baseOrderBy = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var arrayMap$1 = require__arrayMap(), baseGet = require__baseGet(), baseIteratee$6 = require__baseIteratee(), baseMap$1 = require__baseMap(), baseSortBy = require__baseSortBy(), baseUnary = require__baseUnary(), compareMultiple = require__compareMultiple(), identity$8 = require_identity(), isArray$3 = require_isArray();
	function baseOrderBy$1(collection, iteratees, orders) {
		if (iteratees.length) iteratees = arrayMap$1(iteratees, function(iteratee) {
			if (isArray$3(iteratee)) return function(value) {
				return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
			};
			return iteratee;
		});
		else iteratees = [identity$8];
		var index = -1;
		iteratees = arrayMap$1(iteratees, baseUnary(baseIteratee$6));
		return baseSortBy(baseMap$1(collection, function(value, key, collection$1) {
			var criteria = arrayMap$1(iteratees, function(iteratee) {
				return iteratee(value);
			});
			return {
				"criteria": criteria,
				"index": ++index,
				"value": value
			};
		}), function(object, other) {
			return compareMultiple(object, other, orders);
		});
	}
	module.exports = baseOrderBy$1;
}));
var require__apply = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function apply$1(func, thisArg, args) {
		switch (args.length) {
			case 0: return func.call(thisArg);
			case 1: return func.call(thisArg, args[0]);
			case 2: return func.call(thisArg, args[0], args[1]);
			case 3: return func.call(thisArg, args[0], args[1], args[2]);
		}
		return func.apply(thisArg, args);
	}
	module.exports = apply$1;
}));
var require__overRest = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var apply = require__apply();
	var nativeMax$3 = Math.max;
	function overRest$1(func, start, transform) {
		start = nativeMax$3(start === void 0 ? func.length - 1 : start, 0);
		return function() {
			var args = arguments, index = -1, length = nativeMax$3(args.length - start, 0), array = Array(length);
			while (++index < length) array[index] = args[start + index];
			index = -1;
			var otherArgs = Array(start + 1);
			while (++index < start) otherArgs[index] = args[index];
			otherArgs[start] = transform(array);
			return apply(func, this, otherArgs);
		};
	}
	module.exports = overRest$1;
}));
var require_constant = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function constant$1(value) {
		return function() {
			return value;
		};
	}
	module.exports = constant$1;
}));
var require__defineProperty = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var getNative = require__getNative();
	module.exports = function() {
		try {
			var func = getNative(Object, "defineProperty");
			func({}, "", {});
			return func;
		} catch (e) {}
	}();
}));
var require__baseSetToString = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var constant = require_constant(), defineProperty$1 = require__defineProperty(), identity$7 = require_identity();
	module.exports = !defineProperty$1 ? identity$7 : function(func, string) {
		return defineProperty$1(func, "toString", {
			"configurable": true,
			"enumerable": false,
			"value": constant(string),
			"writable": true
		});
	};
}));
var require__shortOut = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var HOT_COUNT = 800, HOT_SPAN = 16;
	var nativeNow = Date.now;
	function shortOut(func) {
		var count = 0, lastCalled = 0;
		return function() {
			var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
			lastCalled = stamp;
			if (remaining > 0) {
				if (++count >= HOT_COUNT) return arguments[0];
			} else count = 0;
			return func.apply(void 0, arguments);
		};
	}
	module.exports = shortOut;
}));
var require__setToString = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseSetToString = require__baseSetToString();
	module.exports = require__shortOut()(baseSetToString);
}));
var require__baseRest = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var identity$6 = require_identity(), overRest = require__overRest(), setToString = require__setToString();
	function baseRest$1(func, start) {
		return setToString(overRest(func, start, identity$6), func + "");
	}
	module.exports = baseRest$1;
}));
var require__isIterateeCall = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var eq = require_eq(), isArrayLike$1 = require_isArrayLike(), isIndex = require__isIndex(), isObject$5 = require_isObject();
	function isIterateeCall$4(value, index, object) {
		if (!isObject$5(object)) return false;
		var type = typeof index;
		if (type == "number" ? isArrayLike$1(object) && isIndex(index, object.length) : type == "string" && index in object) return eq(object[index], value);
		return false;
	}
	module.exports = isIterateeCall$4;
}));
var require_sortBy = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseFlatten$1 = require__baseFlatten(), baseOrderBy = require__baseOrderBy(), baseRest = require__baseRest(), isIterateeCall$3 = require__isIterateeCall();
	module.exports = baseRest(function(collection, iteratees) {
		if (collection == null) return [];
		var length = iteratees.length;
		if (length > 1 && isIterateeCall$3(collection, iteratees[0], iteratees[1])) iteratees = [];
		else if (length > 2 && isIterateeCall$3(iteratees[0], iteratees[1], iteratees[2])) iteratees = [iteratees[0]];
		return baseOrderBy(collection, baseFlatten$1(iteratees, 1), []);
	});
}));
var import_sortBy$2 = /* @__PURE__ */ __toESM(require_sortBy());
var import_isNil$7 = /* @__PURE__ */ __toESM(require_isNil());
function _typeof$39(o) {
	"@babel/helpers - typeof";
	return _typeof$39 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$39(o);
}
function _extends$21() {
	_extends$21 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$21.apply(this, arguments);
}
function _slicedToArray$11(arr, i) {
	return _arrayWithHoles$12(arr) || _iterableToArrayLimit$11(arr, i) || _unsupportedIterableToArray$18(arr, i) || _nonIterableRest$12();
}
function _nonIterableRest$12() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$18(o, minLen) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$18(o, minLen);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$18(o, minLen);
}
function _arrayLikeToArray$18(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$11(r, l) {
	var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a$1 = [], f = !0, o = !1;
		try {
			if (i = (t = t.call(r)).next, 0 === l) {
				if (Object(t) !== t) return;
				f = !1;
			} else for (; !(f = (e = i.call(t)).done) && (a$1.push(e.value), a$1.length !== l); f = !0);
		} catch (r$1) {
			o = !0, n = r$1;
		} finally {
			try {
				if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a$1;
	}
}
function _arrayWithHoles$12(arr) {
	if (Array.isArray(arr)) return arr;
}
function ownKeys$31(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$31(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$31(Object(t), !0).forEach(function(r$1) {
			_defineProperty$36(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$31(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}
function _defineProperty$36(obj, key, value) {
	key = _toPropertyKey$37(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$37(t) {
	var i = _toPrimitive$37(t, "string");
	return "symbol" == _typeof$39(i) ? i : i + "";
}
function _toPrimitive$37(t, r) {
	if ("object" != _typeof$39(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$39(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
function defaultFormatter(value) {
	return Array.isArray(value) && isNumOrStr(value[0]) && isNumOrStr(value[1]) ? value.join(" ~ ") : value;
}
var DefaultTooltipContent = function DefaultTooltipContent$1(props) {
	var _props$separator = props.separator, separator = _props$separator === void 0 ? " : " : _props$separator, _props$contentStyle = props.contentStyle, contentStyle = _props$contentStyle === void 0 ? {} : _props$contentStyle, _props$itemStyle = props.itemStyle, itemStyle = _props$itemStyle === void 0 ? {} : _props$itemStyle, _props$labelStyle = props.labelStyle, labelStyle = _props$labelStyle === void 0 ? {} : _props$labelStyle, payload = props.payload, formatter = props.formatter, itemSorter = props.itemSorter, wrapperClassName = props.wrapperClassName, labelClassName = props.labelClassName, label = props.label, labelFormatter = props.labelFormatter, _props$accessibilityL = props.accessibilityLayer, accessibilityLayer = _props$accessibilityL === void 0 ? false : _props$accessibilityL;
	var renderContent$2 = function renderContent$3() {
		if (payload && payload.length) {
			var listStyle = {
				padding: 0,
				margin: 0
			};
			var items = (itemSorter ? (0, import_sortBy$2.default)(payload, itemSorter) : payload).map(function(entry, i) {
				if (entry.type === "none") return null;
				var finalItemStyle = _objectSpread$31({
					display: "block",
					paddingTop: 4,
					paddingBottom: 4,
					color: entry.color || "#000"
				}, itemStyle);
				var finalFormatter = entry.formatter || formatter || defaultFormatter;
				var value = entry.value, name = entry.name;
				var finalValue = value;
				var finalName = name;
				if (finalFormatter && finalValue != null && finalName != null) {
					var formatted = finalFormatter(value, name, entry, i, payload);
					if (Array.isArray(formatted)) {
						var _formatted = _slicedToArray$11(formatted, 2);
						finalValue = _formatted[0];
						finalName = _formatted[1];
					} else finalValue = formatted;
				}
				return /* @__PURE__ */ import_react.createElement("li", {
					className: "recharts-tooltip-item",
					key: "tooltip-item-".concat(i),
					style: finalItemStyle
				}, isNumOrStr(finalName) ? /* @__PURE__ */ import_react.createElement("span", { className: "recharts-tooltip-item-name" }, finalName) : null, isNumOrStr(finalName) ? /* @__PURE__ */ import_react.createElement("span", { className: "recharts-tooltip-item-separator" }, separator) : null, /* @__PURE__ */ import_react.createElement("span", { className: "recharts-tooltip-item-value" }, finalValue), /* @__PURE__ */ import_react.createElement("span", { className: "recharts-tooltip-item-unit" }, entry.unit || ""));
			});
			return /* @__PURE__ */ import_react.createElement("ul", {
				className: "recharts-tooltip-item-list",
				style: listStyle
			}, items);
		}
		return null;
	};
	var finalStyle = _objectSpread$31({
		margin: 0,
		padding: 10,
		backgroundColor: "#fff",
		border: "1px solid #ccc",
		whiteSpace: "nowrap"
	}, contentStyle);
	var finalLabelStyle = _objectSpread$31({ margin: 0 }, labelStyle);
	var hasLabel = !(0, import_isNil$7.default)(label);
	var finalLabel = hasLabel ? label : "";
	var wrapperCN = clsx_default("recharts-default-tooltip", wrapperClassName);
	var labelCN = clsx_default("recharts-tooltip-label", labelClassName);
	if (hasLabel && labelFormatter && payload !== void 0 && payload !== null) finalLabel = labelFormatter(label, payload);
	var accessibilityAttributes = accessibilityLayer ? {
		role: "status",
		"aria-live": "assertive"
	} : {};
	return /* @__PURE__ */ import_react.createElement("div", _extends$21({
		className: wrapperCN,
		style: finalStyle
	}, accessibilityAttributes), /* @__PURE__ */ import_react.createElement("p", {
		className: labelCN,
		style: finalLabelStyle
	}, /* @__PURE__ */ import_react.isValidElement(finalLabel) ? finalLabel : "".concat(finalLabel)), renderContent$2());
};
function _typeof$38(o) {
	"@babel/helpers - typeof";
	return _typeof$38 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$38(o);
}
function _defineProperty$35(obj, key, value) {
	key = _toPropertyKey$36(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$36(t) {
	var i = _toPrimitive$36(t, "string");
	return "symbol" == _typeof$38(i) ? i : i + "";
}
function _toPrimitive$36(t, r) {
	if ("object" != _typeof$38(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$38(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
var CSS_CLASS_PREFIX = "recharts-tooltip-wrapper";
var TOOLTIP_HIDDEN = { visibility: "hidden" };
function getTooltipCSSClassName(_ref) {
	var coordinate = _ref.coordinate, translateX = _ref.translateX, translateY = _ref.translateY;
	return clsx_default(CSS_CLASS_PREFIX, _defineProperty$35(_defineProperty$35(_defineProperty$35(_defineProperty$35({}, "".concat(CSS_CLASS_PREFIX, "-right"), isNumber(translateX) && coordinate && isNumber(coordinate.x) && translateX >= coordinate.x), "".concat(CSS_CLASS_PREFIX, "-left"), isNumber(translateX) && coordinate && isNumber(coordinate.x) && translateX < coordinate.x), "".concat(CSS_CLASS_PREFIX, "-bottom"), isNumber(translateY) && coordinate && isNumber(coordinate.y) && translateY >= coordinate.y), "".concat(CSS_CLASS_PREFIX, "-top"), isNumber(translateY) && coordinate && isNumber(coordinate.y) && translateY < coordinate.y));
}
function getTooltipTranslateXY(_ref2) {
	var allowEscapeViewBox = _ref2.allowEscapeViewBox, coordinate = _ref2.coordinate, key = _ref2.key, offsetTopLeft = _ref2.offsetTopLeft, position = _ref2.position, reverseDirection = _ref2.reverseDirection, tooltipDimension = _ref2.tooltipDimension, viewBox = _ref2.viewBox, viewBoxDimension = _ref2.viewBoxDimension;
	if (position && isNumber(position[key])) return position[key];
	var negative = coordinate[key] - tooltipDimension - offsetTopLeft;
	var positive = coordinate[key] + offsetTopLeft;
	if (allowEscapeViewBox[key]) return reverseDirection[key] ? negative : positive;
	if (reverseDirection[key]) {
		if (negative < viewBox[key]) return Math.max(positive, viewBox[key]);
		return Math.max(negative, viewBox[key]);
	}
	if (positive + tooltipDimension > viewBox[key] + viewBoxDimension) return Math.max(negative, viewBox[key]);
	return Math.max(positive, viewBox[key]);
}
function getTransformStyle(_ref3) {
	var translateX = _ref3.translateX, translateY = _ref3.translateY;
	return { transform: _ref3.useTranslate3d ? "translate3d(".concat(translateX, "px, ").concat(translateY, "px, 0)") : "translate(".concat(translateX, "px, ").concat(translateY, "px)") };
}
function getTooltipTranslate(_ref4) {
	var allowEscapeViewBox = _ref4.allowEscapeViewBox, coordinate = _ref4.coordinate, offsetTopLeft = _ref4.offsetTopLeft, position = _ref4.position, reverseDirection = _ref4.reverseDirection, tooltipBox = _ref4.tooltipBox, useTranslate3d = _ref4.useTranslate3d, viewBox = _ref4.viewBox;
	var cssProperties, translateX, translateY;
	if (tooltipBox.height > 0 && tooltipBox.width > 0 && coordinate) {
		translateX = getTooltipTranslateXY({
			allowEscapeViewBox,
			coordinate,
			key: "x",
			offsetTopLeft,
			position,
			reverseDirection,
			tooltipDimension: tooltipBox.width,
			viewBox,
			viewBoxDimension: viewBox.width
		});
		translateY = getTooltipTranslateXY({
			allowEscapeViewBox,
			coordinate,
			key: "y",
			offsetTopLeft,
			position,
			reverseDirection,
			tooltipDimension: tooltipBox.height,
			viewBox,
			viewBoxDimension: viewBox.height
		});
		cssProperties = getTransformStyle({
			translateX,
			translateY,
			useTranslate3d
		});
	} else cssProperties = TOOLTIP_HIDDEN;
	return {
		cssProperties,
		cssClasses: getTooltipCSSClassName({
			translateX,
			translateY,
			coordinate
		})
	};
}
function _typeof$37(o) {
	"@babel/helpers - typeof";
	return _typeof$37 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$37(o);
}
function ownKeys$30(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$30(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$30(Object(t), !0).forEach(function(r$1) {
			_defineProperty$34(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$30(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}
function _classCallCheck$15(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$15(target, props) {
	for (var i = 0; i < props.length; i++) {
		var descriptor = props[i];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$35(descriptor.key), descriptor);
	}
}
function _createClass$15(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$15(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$15(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _callSuper$11(t, o, e) {
	return o = _getPrototypeOf$12(o), _possibleConstructorReturn$12(t, _isNativeReflectConstruct$12() ? Reflect.construct(o, e || [], _getPrototypeOf$12(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn$12(self$1, call) {
	if (call && (_typeof$37(call) === "object" || typeof call === "function")) return call;
	else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
	return _assertThisInitialized$12(self$1);
}
function _assertThisInitialized$12(self$1) {
	if (self$1 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return self$1;
}
function _isNativeReflectConstruct$12() {
	try {
		var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
	} catch (t$1) {}
	return (_isNativeReflectConstruct$12 = function _isNativeReflectConstruct$15() {
		return !!t;
	})();
}
function _getPrototypeOf$12(o) {
	_getPrototypeOf$12 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf$15(o$1) {
		return o$1.__proto__ || Object.getPrototypeOf(o$1);
	};
	return _getPrototypeOf$12(o);
}
function _inherits$12(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
	subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
		value: subClass,
		writable: true,
		configurable: true
	} });
	Object.defineProperty(subClass, "prototype", { writable: false });
	if (superClass) _setPrototypeOf$12(subClass, superClass);
}
function _setPrototypeOf$12(o, p) {
	_setPrototypeOf$12 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf$15(o$1, p$1) {
		o$1.__proto__ = p$1;
		return o$1;
	};
	return _setPrototypeOf$12(o, p);
}
function _defineProperty$34(obj, key, value) {
	key = _toPropertyKey$35(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$35(t) {
	var i = _toPrimitive$35(t, "string");
	return "symbol" == _typeof$37(i) ? i : i + "";
}
function _toPrimitive$35(t, r) {
	if ("object" != _typeof$37(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$37(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
var EPSILON = 1;
var TooltipBoundingBox = /* @__PURE__ */ function(_PureComponent) {
	function TooltipBoundingBox$1() {
		var _this;
		_classCallCheck$15(this, TooltipBoundingBox$1);
		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
		_this = _callSuper$11(this, TooltipBoundingBox$1, [].concat(args));
		_defineProperty$34(_this, "state", {
			dismissed: false,
			dismissedAtCoordinate: {
				x: 0,
				y: 0
			},
			lastBoundingBox: {
				width: -1,
				height: -1
			}
		});
		_defineProperty$34(_this, "handleKeyDown", function(event) {
			if (event.key === "Escape") {
				var _this$props$coordinat, _this$props$coordinat2, _this$props$coordinat3, _this$props$coordinat4;
				_this.setState({
					dismissed: true,
					dismissedAtCoordinate: {
						x: (_this$props$coordinat = (_this$props$coordinat2 = _this.props.coordinate) === null || _this$props$coordinat2 === void 0 ? void 0 : _this$props$coordinat2.x) !== null && _this$props$coordinat !== void 0 ? _this$props$coordinat : 0,
						y: (_this$props$coordinat3 = (_this$props$coordinat4 = _this.props.coordinate) === null || _this$props$coordinat4 === void 0 ? void 0 : _this$props$coordinat4.y) !== null && _this$props$coordinat3 !== void 0 ? _this$props$coordinat3 : 0
					}
				});
			}
		});
		return _this;
	}
	_inherits$12(TooltipBoundingBox$1, _PureComponent);
	return _createClass$15(TooltipBoundingBox$1, [
		{
			key: "updateBBox",
			value: function updateBBox() {
				if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) {
					var box = this.wrapperNode.getBoundingClientRect();
					if (Math.abs(box.width - this.state.lastBoundingBox.width) > EPSILON || Math.abs(box.height - this.state.lastBoundingBox.height) > EPSILON) this.setState({ lastBoundingBox: {
						width: box.width,
						height: box.height
					} });
				} else if (this.state.lastBoundingBox.width !== -1 || this.state.lastBoundingBox.height !== -1) this.setState({ lastBoundingBox: {
					width: -1,
					height: -1
				} });
			}
		},
		{
			key: "componentDidMount",
			value: function componentDidMount() {
				document.addEventListener("keydown", this.handleKeyDown);
				this.updateBBox();
			}
		},
		{
			key: "componentWillUnmount",
			value: function componentWillUnmount() {
				document.removeEventListener("keydown", this.handleKeyDown);
			}
		},
		{
			key: "componentDidUpdate",
			value: function componentDidUpdate() {
				var _this$props$coordinat5, _this$props$coordinat6;
				if (this.props.active) this.updateBBox();
				if (!this.state.dismissed) return;
				if (((_this$props$coordinat5 = this.props.coordinate) === null || _this$props$coordinat5 === void 0 ? void 0 : _this$props$coordinat5.x) !== this.state.dismissedAtCoordinate.x || ((_this$props$coordinat6 = this.props.coordinate) === null || _this$props$coordinat6 === void 0 ? void 0 : _this$props$coordinat6.y) !== this.state.dismissedAtCoordinate.y) this.state.dismissed = false;
			}
		},
		{
			key: "render",
			value: function render() {
				var _this2 = this;
				var _this$props = this.props, active = _this$props.active, allowEscapeViewBox = _this$props.allowEscapeViewBox, animationDuration = _this$props.animationDuration, animationEasing = _this$props.animationEasing, children = _this$props.children, coordinate = _this$props.coordinate, hasPayload = _this$props.hasPayload, isAnimationActive = _this$props.isAnimationActive, offset = _this$props.offset, position = _this$props.position, reverseDirection = _this$props.reverseDirection, useTranslate3d = _this$props.useTranslate3d, viewBox = _this$props.viewBox, wrapperStyle = _this$props.wrapperStyle;
				var _getTooltipTranslate = getTooltipTranslate({
					allowEscapeViewBox,
					coordinate,
					offsetTopLeft: offset,
					position,
					reverseDirection,
					tooltipBox: this.state.lastBoundingBox,
					useTranslate3d,
					viewBox
				}), cssClasses = _getTooltipTranslate.cssClasses, cssProperties = _getTooltipTranslate.cssProperties;
				var outerStyle = _objectSpread$30(_objectSpread$30({ transition: isAnimationActive && active ? "transform ".concat(animationDuration, "ms ").concat(animationEasing) : void 0 }, cssProperties), {}, {
					pointerEvents: "none",
					visibility: !this.state.dismissed && active && hasPayload ? "visible" : "hidden",
					position: "absolute",
					top: 0,
					left: 0
				}, wrapperStyle);
				return /* @__PURE__ */ import_react.createElement("div", {
					tabIndex: -1,
					className: cssClasses,
					style: outerStyle,
					ref: function ref(node) {
						_this2.wrapperNode = node;
					}
				}, children);
			}
		}
	]);
}(import_react.PureComponent);
var Global = {
	isSsr: function parseIsSsrByDefault$1() {
		return !(typeof window !== "undefined" && window.document && window.document.createElement && window.setTimeout);
	}(),
	get: function get$7(key) {
		return Global[key];
	},
	set: function set(key, value) {
		if (typeof key === "string") Global[key] = value;
		else {
			var keys$6 = Object.keys(key);
			if (keys$6 && keys$6.length) keys$6.forEach(function(k$1) {
				Global[k$1] = key[k$1];
			});
		}
	}
};
function _typeof$36(o) {
	"@babel/helpers - typeof";
	return _typeof$36 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$36(o);
}
function ownKeys$29(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$29(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$29(Object(t), !0).forEach(function(r$1) {
			_defineProperty$33(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$29(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}
function _classCallCheck$14(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$14(target, props) {
	for (var i = 0; i < props.length; i++) {
		var descriptor = props[i];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$34(descriptor.key), descriptor);
	}
}
function _createClass$14(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$14(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$14(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _callSuper$10(t, o, e) {
	return o = _getPrototypeOf$11(o), _possibleConstructorReturn$11(t, _isNativeReflectConstruct$11() ? Reflect.construct(o, e || [], _getPrototypeOf$11(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn$11(self$1, call) {
	if (call && (_typeof$36(call) === "object" || typeof call === "function")) return call;
	else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
	return _assertThisInitialized$11(self$1);
}
function _assertThisInitialized$11(self$1) {
	if (self$1 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return self$1;
}
function _isNativeReflectConstruct$11() {
	try {
		var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
	} catch (t$1) {}
	return (_isNativeReflectConstruct$11 = function _isNativeReflectConstruct$15() {
		return !!t;
	})();
}
function _getPrototypeOf$11(o) {
	_getPrototypeOf$11 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf$15(o$1) {
		return o$1.__proto__ || Object.getPrototypeOf(o$1);
	};
	return _getPrototypeOf$11(o);
}
function _inherits$11(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
	subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
		value: subClass,
		writable: true,
		configurable: true
	} });
	Object.defineProperty(subClass, "prototype", { writable: false });
	if (superClass) _setPrototypeOf$11(subClass, superClass);
}
function _setPrototypeOf$11(o, p) {
	_setPrototypeOf$11 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf$15(o$1, p$1) {
		o$1.__proto__ = p$1;
		return o$1;
	};
	return _setPrototypeOf$11(o, p);
}
function _defineProperty$33(obj, key, value) {
	key = _toPropertyKey$34(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$34(t) {
	var i = _toPrimitive$34(t, "string");
	return "symbol" == _typeof$36(i) ? i : i + "";
}
function _toPrimitive$34(t, r) {
	if ("object" != _typeof$36(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$36(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
function defaultUniqBy(entry) {
	return entry.dataKey;
}
function renderContent(content, props) {
	if (/* @__PURE__ */ import_react.isValidElement(content)) return /* @__PURE__ */ import_react.cloneElement(content, props);
	if (typeof content === "function") return /* @__PURE__ */ import_react.createElement(content, props);
	return /* @__PURE__ */ import_react.createElement(DefaultTooltipContent, props);
}
var Tooltip = /* @__PURE__ */ function(_PureComponent) {
	function Tooltip$1() {
		_classCallCheck$14(this, Tooltip$1);
		return _callSuper$10(this, Tooltip$1, arguments);
	}
	_inherits$11(Tooltip$1, _PureComponent);
	return _createClass$14(Tooltip$1, [{
		key: "render",
		value: function render() {
			var _this = this;
			var _this$props = this.props, active = _this$props.active, allowEscapeViewBox = _this$props.allowEscapeViewBox, animationDuration = _this$props.animationDuration, animationEasing = _this$props.animationEasing, content = _this$props.content, coordinate = _this$props.coordinate, filterNull = _this$props.filterNull, isAnimationActive = _this$props.isAnimationActive, offset = _this$props.offset, payload = _this$props.payload, payloadUniqBy = _this$props.payloadUniqBy, position = _this$props.position, reverseDirection = _this$props.reverseDirection, useTranslate3d = _this$props.useTranslate3d, viewBox = _this$props.viewBox, wrapperStyle = _this$props.wrapperStyle;
			var finalPayload = payload !== null && payload !== void 0 ? payload : [];
			if (filterNull && finalPayload.length) finalPayload = getUniqPayload(payload.filter(function(entry) {
				return entry.value != null && (entry.hide !== true || _this.props.includeHidden);
			}), payloadUniqBy, defaultUniqBy);
			var hasPayload = finalPayload.length > 0;
			return /* @__PURE__ */ import_react.createElement(TooltipBoundingBox, {
				allowEscapeViewBox,
				animationDuration,
				animationEasing,
				isAnimationActive,
				active,
				coordinate,
				hasPayload,
				offset,
				position,
				reverseDirection,
				useTranslate3d,
				viewBox,
				wrapperStyle
			}, renderContent(content, _objectSpread$29(_objectSpread$29({}, this.props), {}, { payload: finalPayload })));
		}
	}]);
}(import_react.PureComponent);
_defineProperty$33(Tooltip, "displayName", "Tooltip");
_defineProperty$33(Tooltip, "defaultProps", {
	accessibilityLayer: false,
	allowEscapeViewBox: {
		x: false,
		y: false
	},
	animationDuration: 400,
	animationEasing: "ease",
	contentStyle: {},
	coordinate: {
		x: 0,
		y: 0
	},
	cursor: true,
	cursorStyle: {},
	filterNull: true,
	isAnimationActive: !Global.isSsr,
	itemStyle: {},
	labelStyle: {},
	offset: 10,
	reverseDirection: {
		x: false,
		y: false
	},
	separator: " : ",
	trigger: "hover",
	useTranslate3d: false,
	viewBox: {
		x: 0,
		y: 0,
		height: 0,
		width: 0
	},
	wrapperStyle: {}
});
var require_now = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var root = require__root();
	var now$1 = function() {
		return root.Date.now();
	};
	module.exports = now$1;
}));
var require__trimmedEndIndex = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var reWhitespace = /\s/;
	function trimmedEndIndex$1(string) {
		var index = string.length;
		while (index-- && reWhitespace.test(string.charAt(index)));
		return index;
	}
	module.exports = trimmedEndIndex$1;
}));
var require__baseTrim = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var trimmedEndIndex = require__trimmedEndIndex();
	var reTrimStart = /^\s+/;
	function baseTrim$1(string) {
		return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
	}
	module.exports = baseTrim$1;
}));
var require_toNumber = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseTrim = require__baseTrim(), isObject$4 = require_isObject(), isSymbol$1 = require_isSymbol();
	var NAN = NaN;
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
	var reIsBinary = /^0b[01]+$/i;
	var reIsOctal = /^0o[0-7]+$/i;
	var freeParseInt = parseInt;
	function toNumber$2(value) {
		if (typeof value == "number") return value;
		if (isSymbol$1(value)) return NAN;
		if (isObject$4(value)) {
			var other = typeof value.valueOf == "function" ? value.valueOf() : value;
			value = isObject$4(other) ? other + "" : other;
		}
		if (typeof value != "string") return value === 0 ? value : +value;
		value = baseTrim(value);
		var isBinary = reIsBinary.test(value);
		return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
	}
	module.exports = toNumber$2;
}));
var require_debounce = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isObject$3 = require_isObject(), now = require_now(), toNumber$1 = require_toNumber();
	var FUNC_ERROR_TEXT$1 = "Expected a function";
	var nativeMax$2 = Math.max, nativeMin = Math.min;
	function debounce$1(func, wait, options) {
		var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
		if (typeof func != "function") throw new TypeError(FUNC_ERROR_TEXT$1);
		wait = toNumber$1(wait) || 0;
		if (isObject$3(options)) {
			leading = !!options.leading;
			maxing = "maxWait" in options;
			maxWait = maxing ? nativeMax$2(toNumber$1(options.maxWait) || 0, wait) : maxWait;
			trailing = "trailing" in options ? !!options.trailing : trailing;
		}
		function invokeFunc(time$1) {
			var args = lastArgs, thisArg = lastThis;
			lastArgs = lastThis = void 0;
			lastInvokeTime = time$1;
			result = func.apply(thisArg, args);
			return result;
		}
		function leadingEdge(time$1) {
			lastInvokeTime = time$1;
			timerId = setTimeout(timerExpired, wait);
			return leading ? invokeFunc(time$1) : result;
		}
		function remainingWait(time$1) {
			var timeSinceLastCall = time$1 - lastCallTime, timeSinceLastInvoke = time$1 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
			return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
		}
		function shouldInvoke(time$1) {
			var timeSinceLastCall = time$1 - lastCallTime, timeSinceLastInvoke = time$1 - lastInvokeTime;
			return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
		}
		function timerExpired() {
			var time$1 = now();
			if (shouldInvoke(time$1)) return trailingEdge(time$1);
			timerId = setTimeout(timerExpired, remainingWait(time$1));
		}
		function trailingEdge(time$1) {
			timerId = void 0;
			if (trailing && lastArgs) return invokeFunc(time$1);
			lastArgs = lastThis = void 0;
			return result;
		}
		function cancel() {
			if (timerId !== void 0) clearTimeout(timerId);
			lastInvokeTime = 0;
			lastArgs = lastCallTime = lastThis = timerId = void 0;
		}
		function flush() {
			return timerId === void 0 ? result : trailingEdge(now());
		}
		function debounced() {
			var time$1 = now(), isInvoking = shouldInvoke(time$1);
			lastArgs = arguments;
			lastThis = this;
			lastCallTime = time$1;
			if (isInvoking) {
				if (timerId === void 0) return leadingEdge(lastCallTime);
				if (maxing) {
					clearTimeout(timerId);
					timerId = setTimeout(timerExpired, wait);
					return invokeFunc(lastCallTime);
				}
			}
			if (timerId === void 0) timerId = setTimeout(timerExpired, wait);
			return result;
		}
		debounced.cancel = cancel;
		debounced.flush = flush;
		return debounced;
	}
	module.exports = debounce$1;
}));
var require_throttle = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var debounce = require_debounce(), isObject$2 = require_isObject();
	var FUNC_ERROR_TEXT = "Expected a function";
	function throttle$2(func, wait, options) {
		var leading = true, trailing = true;
		if (typeof func != "function") throw new TypeError(FUNC_ERROR_TEXT);
		if (isObject$2(options)) {
			leading = "leading" in options ? !!options.leading : leading;
			trailing = "trailing" in options ? !!options.trailing : trailing;
		}
		return debounce(func, wait, {
			"leading": leading,
			"maxWait": wait,
			"trailing": trailing
		});
	}
	module.exports = throttle$2;
}));
var import_throttle$1 = /* @__PURE__ */ __toESM(require_throttle());
function _typeof$35(o) {
	"@babel/helpers - typeof";
	return _typeof$35 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$35(o);
}
function ownKeys$28(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$28(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$28(Object(t), !0).forEach(function(r$1) {
			_defineProperty$32(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$28(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}
function _defineProperty$32(obj, key, value) {
	key = _toPropertyKey$33(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$33(t) {
	var i = _toPrimitive$33(t, "string");
	return "symbol" == _typeof$35(i) ? i : i + "";
}
function _toPrimitive$33(t, r) {
	if ("object" != _typeof$35(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$35(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
function _slicedToArray$10(arr, i) {
	return _arrayWithHoles$11(arr) || _iterableToArrayLimit$10(arr, i) || _unsupportedIterableToArray$17(arr, i) || _nonIterableRest$11();
}
function _nonIterableRest$11() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$17(o, minLen) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$17(o, minLen);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$17(o, minLen);
}
function _arrayLikeToArray$17(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$10(r, l) {
	var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a$1 = [], f = !0, o = !1;
		try {
			if (i = (t = t.call(r)).next, 0 === l) {
				if (Object(t) !== t) return;
				f = !1;
			} else for (; !(f = (e = i.call(t)).done) && (a$1.push(e.value), a$1.length !== l); f = !0);
		} catch (r$1) {
			o = !0, n = r$1;
		} finally {
			try {
				if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a$1;
	}
}
function _arrayWithHoles$11(arr) {
	if (Array.isArray(arr)) return arr;
}
var ResponsiveContainer = /* @__PURE__ */ (0, import_react.forwardRef)(function(_ref, ref) {
	var aspect = _ref.aspect, _ref$initialDimension = _ref.initialDimension, initialDimension = _ref$initialDimension === void 0 ? {
		width: -1,
		height: -1
	} : _ref$initialDimension, _ref$width = _ref.width, width = _ref$width === void 0 ? "100%" : _ref$width, _ref$height = _ref.height, height = _ref$height === void 0 ? "100%" : _ref$height, _ref$minWidth = _ref.minWidth, minWidth = _ref$minWidth === void 0 ? 0 : _ref$minWidth, minHeight = _ref.minHeight, maxHeight = _ref.maxHeight, children = _ref.children, _ref$debounce = _ref.debounce, debounce$2 = _ref$debounce === void 0 ? 0 : _ref$debounce, id = _ref.id, className = _ref.className, onResize = _ref.onResize, _ref$style = _ref.style, style = _ref$style === void 0 ? {} : _ref$style;
	var containerRef = (0, import_react.useRef)(null);
	var onResizeRef = (0, import_react.useRef)();
	onResizeRef.current = onResize;
	(0, import_react.useImperativeHandle)(ref, function() {
		return Object.defineProperty(containerRef.current, "current", {
			get: function get$7() {
				console.warn("The usage of ref.current.current is deprecated and will no longer be supported.");
				return containerRef.current;
			},
			configurable: true
		});
	});
	var _useState2 = _slicedToArray$10((0, import_react.useState)({
		containerWidth: initialDimension.width,
		containerHeight: initialDimension.height
	}), 2), sizes = _useState2[0], setSizes = _useState2[1];
	var setContainerSize = (0, import_react.useCallback)(function(newWidth, newHeight) {
		setSizes(function(prevState) {
			var roundedWidth = Math.round(newWidth);
			var roundedHeight = Math.round(newHeight);
			if (prevState.containerWidth === roundedWidth && prevState.containerHeight === roundedHeight) return prevState;
			return {
				containerWidth: roundedWidth,
				containerHeight: roundedHeight
			};
		});
	}, []);
	(0, import_react.useEffect)(function() {
		var callback = function callback$1(entries) {
			var _onResizeRef$current;
			var _entries$0$contentRec = entries[0].contentRect, containerWidth$1 = _entries$0$contentRec.width, containerHeight$1 = _entries$0$contentRec.height;
			setContainerSize(containerWidth$1, containerHeight$1);
			(_onResizeRef$current = onResizeRef.current) === null || _onResizeRef$current === void 0 || _onResizeRef$current.call(onResizeRef, containerWidth$1, containerHeight$1);
		};
		if (debounce$2 > 0) callback = (0, import_throttle$1.default)(callback, debounce$2, {
			trailing: true,
			leading: false
		});
		var observer = new ResizeObserver(callback);
		var _containerRef$current = containerRef.current.getBoundingClientRect(), containerWidth = _containerRef$current.width, containerHeight = _containerRef$current.height;
		setContainerSize(containerWidth, containerHeight);
		observer.observe(containerRef.current);
		return function() {
			observer.disconnect();
		};
	}, [setContainerSize, debounce$2]);
	var chartContent = (0, import_react.useMemo)(function() {
		var containerWidth = sizes.containerWidth, containerHeight = sizes.containerHeight;
		if (containerWidth < 0 || containerHeight < 0) return null;
		warn(isPercent(width) || isPercent(height), "The width(%s) and height(%s) are both fixed numbers,\n       maybe you don't need to use a ResponsiveContainer.", width, height);
		warn(!aspect || aspect > 0, "The aspect(%s) must be greater than zero.", aspect);
		var calculatedWidth = isPercent(width) ? containerWidth : width;
		var calculatedHeight = isPercent(height) ? containerHeight : height;
		if (aspect && aspect > 0) {
			if (calculatedWidth) calculatedHeight = calculatedWidth / aspect;
			else if (calculatedHeight) calculatedWidth = calculatedHeight * aspect;
			if (maxHeight && calculatedHeight > maxHeight) calculatedHeight = maxHeight;
		}
		warn(calculatedWidth > 0 || calculatedHeight > 0, "The width(%s) and height(%s) of chart should be greater than 0,\n       please check the style of container, or the props width(%s) and height(%s),\n       or add a minWidth(%s) or minHeight(%s) or use aspect(%s) to control the\n       height and width.", calculatedWidth, calculatedHeight, width, height, minWidth, minHeight, aspect);
		var isCharts = !Array.isArray(children) && getDisplayName(children.type).endsWith("Chart");
		return import_react.Children.map(children, function(child) {
			if (/* @__PURE__ */ import_react.isValidElement(child)) return /* @__PURE__ */ (0, import_react.cloneElement)(child, _objectSpread$28({
				width: calculatedWidth,
				height: calculatedHeight
			}, isCharts ? { style: _objectSpread$28({
				height: "100%",
				width: "100%",
				maxHeight: calculatedHeight,
				maxWidth: calculatedWidth
			}, child.props.style) } : {}));
			return child;
		});
	}, [
		aspect,
		children,
		height,
		maxHeight,
		minHeight,
		minWidth,
		sizes,
		width
	]);
	return /* @__PURE__ */ import_react.createElement("div", {
		id: id ? "".concat(id) : void 0,
		className: clsx_default("recharts-responsive-container", className),
		style: _objectSpread$28(_objectSpread$28({}, style), {}, {
			width,
			height,
			minWidth,
			minHeight,
			maxHeight
		}),
		ref: containerRef
	}, chartContent);
});
var Cell = function Cell$1(_props) {
	return null;
};
Cell.displayName = "Cell";
function _typeof$34(o) {
	"@babel/helpers - typeof";
	return _typeof$34 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$34(o);
}
function ownKeys$27(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$27(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$27(Object(t), !0).forEach(function(r$1) {
			_defineProperty$31(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$27(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}
function _defineProperty$31(obj, key, value) {
	key = _toPropertyKey$32(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$32(t) {
	var i = _toPrimitive$32(t, "string");
	return "symbol" == _typeof$34(i) ? i : i + "";
}
function _toPrimitive$32(t, r) {
	if ("object" != _typeof$34(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$34(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
var stringCache = {
	widthCache: {},
	cacheCount: 0
};
var MAX_CACHE_NUM = 2e3;
var SPAN_STYLE = {
	position: "absolute",
	top: "-20000px",
	left: 0,
	padding: 0,
	margin: 0,
	border: "none",
	whiteSpace: "pre"
};
var MEASUREMENT_SPAN_ID = "recharts_measurement_span";
function removeInvalidKeys(obj) {
	var copyObj = _objectSpread$27({}, obj);
	Object.keys(copyObj).forEach(function(key) {
		if (!copyObj[key]) delete copyObj[key];
	});
	return copyObj;
}
var getStringSize = function getStringSize$1(text) {
	var style = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
	if (text === void 0 || text === null || Global.isSsr) return {
		width: 0,
		height: 0
	};
	var copyStyle = removeInvalidKeys(style);
	var cacheKey = JSON.stringify({
		text,
		copyStyle
	});
	if (stringCache.widthCache[cacheKey]) return stringCache.widthCache[cacheKey];
	try {
		var measurementSpan = document.getElementById(MEASUREMENT_SPAN_ID);
		if (!measurementSpan) {
			measurementSpan = document.createElement("span");
			measurementSpan.setAttribute("id", MEASUREMENT_SPAN_ID);
			measurementSpan.setAttribute("aria-hidden", "true");
			document.body.appendChild(measurementSpan);
		}
		var measurementSpanStyle = _objectSpread$27(_objectSpread$27({}, SPAN_STYLE), copyStyle);
		Object.assign(measurementSpan.style, measurementSpanStyle);
		measurementSpan.textContent = "".concat(text);
		var rect = measurementSpan.getBoundingClientRect();
		var result = {
			width: rect.width,
			height: rect.height
		};
		stringCache.widthCache[cacheKey] = result;
		if (++stringCache.cacheCount > MAX_CACHE_NUM) {
			stringCache.cacheCount = 0;
			stringCache.widthCache = {};
		}
		return result;
	} catch (e) {
		return {
			width: 0,
			height: 0
		};
	}
};
var getOffset = function getOffset$1(rect) {
	return {
		top: rect.top + window.scrollY - document.documentElement.clientTop,
		left: rect.left + window.scrollX - document.documentElement.clientLeft
	};
};
function _typeof$33(o) {
	"@babel/helpers - typeof";
	return _typeof$33 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$33(o);
}
function _slicedToArray$9(arr, i) {
	return _arrayWithHoles$10(arr) || _iterableToArrayLimit$9(arr, i) || _unsupportedIterableToArray$16(arr, i) || _nonIterableRest$10();
}
function _nonIterableRest$10() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$16(o, minLen) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$16(o, minLen);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$16(o, minLen);
}
function _arrayLikeToArray$16(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$9(r, l) {
	var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a$1 = [], f = !0, o = !1;
		try {
			if (i = (t = t.call(r)).next, 0 === l) {
				if (Object(t) !== t) return;
				f = !1;
			} else for (; !(f = (e = i.call(t)).done) && (a$1.push(e.value), a$1.length !== l); f = !0);
		} catch (r$1) {
			o = !0, n = r$1;
		} finally {
			try {
				if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a$1;
	}
}
function _arrayWithHoles$10(arr) {
	if (Array.isArray(arr)) return arr;
}
function _classCallCheck$13(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$13(target, props) {
	for (var i = 0; i < props.length; i++) {
		var descriptor = props[i];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$31(descriptor.key), descriptor);
	}
}
function _createClass$13(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$13(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$13(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _toPropertyKey$31(t) {
	var i = _toPrimitive$31(t, "string");
	return "symbol" == _typeof$33(i) ? i : i + "";
}
function _toPrimitive$31(t, r) {
	if ("object" != _typeof$33(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$33(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
var MULTIPLY_OR_DIVIDE_REGEX = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([*/])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/;
var ADD_OR_SUBTRACT_REGEX = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([+-])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/;
var CSS_LENGTH_UNIT_REGEX = /^px|cm|vh|vw|em|rem|%|mm|in|pt|pc|ex|ch|vmin|vmax|Q$/;
var NUM_SPLIT_REGEX = /(-?\d+(?:\.\d+)?)([a-zA-Z%]+)?/;
var CONVERSION_RATES = {
	cm: 96 / 2.54,
	mm: 96 / 25.4,
	pt: 96 / 72,
	pc: 96 / 6,
	"in": 96,
	Q: 96 / (2.54 * 40),
	px: 1
};
var FIXED_CSS_LENGTH_UNITS = Object.keys(CONVERSION_RATES);
var STR_NAN = "NaN";
function convertToPx(value, unit$1) {
	return value * CONVERSION_RATES[unit$1];
}
var DecimalCSS = /* @__PURE__ */ function() {
	function DecimalCSS$1(num, unit$1) {
		_classCallCheck$13(this, DecimalCSS$1);
		this.num = num;
		this.unit = unit$1;
		this.num = num;
		this.unit = unit$1;
		if (Number.isNaN(num)) this.unit = "";
		if (unit$1 !== "" && !CSS_LENGTH_UNIT_REGEX.test(unit$1)) {
			this.num = NaN;
			this.unit = "";
		}
		if (FIXED_CSS_LENGTH_UNITS.includes(unit$1)) {
			this.num = convertToPx(num, unit$1);
			this.unit = "px";
		}
	}
	return _createClass$13(DecimalCSS$1, [
		{
			key: "add",
			value: function add(other) {
				if (this.unit !== other.unit) return new DecimalCSS$1(NaN, "");
				return new DecimalCSS$1(this.num + other.num, this.unit);
			}
		},
		{
			key: "subtract",
			value: function subtract(other) {
				if (this.unit !== other.unit) return new DecimalCSS$1(NaN, "");
				return new DecimalCSS$1(this.num - other.num, this.unit);
			}
		},
		{
			key: "multiply",
			value: function multiply(other) {
				if (this.unit !== "" && other.unit !== "" && this.unit !== other.unit) return new DecimalCSS$1(NaN, "");
				return new DecimalCSS$1(this.num * other.num, this.unit || other.unit);
			}
		},
		{
			key: "divide",
			value: function divide(other) {
				if (this.unit !== "" && other.unit !== "" && this.unit !== other.unit) return new DecimalCSS$1(NaN, "");
				return new DecimalCSS$1(this.num / other.num, this.unit || other.unit);
			}
		},
		{
			key: "toString",
			value: function toString$4() {
				return "".concat(this.num).concat(this.unit);
			}
		},
		{
			key: "isNaN",
			value: function isNaN$2() {
				return Number.isNaN(this.num);
			}
		}
	], [{
		key: "parse",
		value: function parse(str) {
			var _NUM_SPLIT_REGEX$exec;
			var _ref2 = _slicedToArray$9((_NUM_SPLIT_REGEX$exec = NUM_SPLIT_REGEX.exec(str)) !== null && _NUM_SPLIT_REGEX$exec !== void 0 ? _NUM_SPLIT_REGEX$exec : [], 3), numStr = _ref2[1], unit$1 = _ref2[2];
			return new DecimalCSS$1(parseFloat(numStr), unit$1 !== null && unit$1 !== void 0 ? unit$1 : "");
		}
	}]);
}();
function calculateArithmetic(expr) {
	if (expr.includes(STR_NAN)) return STR_NAN;
	var newExpr = expr;
	while (newExpr.includes("*") || newExpr.includes("/")) {
		var _MULTIPLY_OR_DIVIDE_R;
		var _ref4 = _slicedToArray$9((_MULTIPLY_OR_DIVIDE_R = MULTIPLY_OR_DIVIDE_REGEX.exec(newExpr)) !== null && _MULTIPLY_OR_DIVIDE_R !== void 0 ? _MULTIPLY_OR_DIVIDE_R : [], 4), leftOperand = _ref4[1], operator = _ref4[2], rightOperand = _ref4[3];
		var lTs = DecimalCSS.parse(leftOperand !== null && leftOperand !== void 0 ? leftOperand : "");
		var rTs = DecimalCSS.parse(rightOperand !== null && rightOperand !== void 0 ? rightOperand : "");
		var result = operator === "*" ? lTs.multiply(rTs) : lTs.divide(rTs);
		if (result.isNaN()) return STR_NAN;
		newExpr = newExpr.replace(MULTIPLY_OR_DIVIDE_REGEX, result.toString());
	}
	while (newExpr.includes("+") || /.-\d+(?:\.\d+)?/.test(newExpr)) {
		var _ADD_OR_SUBTRACT_REGE;
		var _ref6 = _slicedToArray$9((_ADD_OR_SUBTRACT_REGE = ADD_OR_SUBTRACT_REGEX.exec(newExpr)) !== null && _ADD_OR_SUBTRACT_REGE !== void 0 ? _ADD_OR_SUBTRACT_REGE : [], 4), _leftOperand = _ref6[1], _operator = _ref6[2], _rightOperand = _ref6[3];
		var _lTs = DecimalCSS.parse(_leftOperand !== null && _leftOperand !== void 0 ? _leftOperand : "");
		var _rTs = DecimalCSS.parse(_rightOperand !== null && _rightOperand !== void 0 ? _rightOperand : "");
		var _result = _operator === "+" ? _lTs.add(_rTs) : _lTs.subtract(_rTs);
		if (_result.isNaN()) return STR_NAN;
		newExpr = newExpr.replace(ADD_OR_SUBTRACT_REGEX, _result.toString());
	}
	return newExpr;
}
var PARENTHESES_REGEX = /\(([^()]*)\)/;
function calculateParentheses(expr) {
	var newExpr = expr;
	while (newExpr.includes("(")) {
		var parentheticalExpression = _slicedToArray$9(PARENTHESES_REGEX.exec(newExpr), 2)[1];
		newExpr = newExpr.replace(PARENTHESES_REGEX, calculateArithmetic(parentheticalExpression));
	}
	return newExpr;
}
function evaluateExpression(expression) {
	var newExpr = expression.replace(/\s+/g, "");
	newExpr = calculateParentheses(newExpr);
	newExpr = calculateArithmetic(newExpr);
	return newExpr;
}
function safeEvaluateExpression(expression) {
	try {
		return evaluateExpression(expression);
	} catch (e) {
		/* istanbul ignore next */
		return STR_NAN;
	}
}
function reduceCSSCalc(expression) {
	var result = safeEvaluateExpression(expression.slice(5, -1));
	if (result === STR_NAN) return "";
	return result;
}
var import_isNil$6 = /* @__PURE__ */ __toESM(require_isNil());
var _excluded$11 = [
	"x",
	"y",
	"lineHeight",
	"capHeight",
	"scaleToFit",
	"textAnchor",
	"verticalAnchor",
	"fill"
], _excluded2$4 = [
	"dx",
	"dy",
	"angle",
	"className",
	"breakAll"
];
function _extends$20() {
	_extends$20 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$20.apply(this, arguments);
}
function _objectWithoutProperties$11(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$11(source, excluded);
	var key, i;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i = 0; i < sourceSymbolKeys.length; i++) {
			key = sourceSymbolKeys[i];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$11(source, excluded) {
	if (source == null) return {};
	var target = {};
	for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function _slicedToArray$8(arr, i) {
	return _arrayWithHoles$9(arr) || _iterableToArrayLimit$8(arr, i) || _unsupportedIterableToArray$15(arr, i) || _nonIterableRest$9();
}
function _nonIterableRest$9() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$15(o, minLen) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$15(o, minLen);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$15(o, minLen);
}
function _arrayLikeToArray$15(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$8(r, l) {
	var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a$1 = [], f = !0, o = !1;
		try {
			if (i = (t = t.call(r)).next, 0 === l) {
				if (Object(t) !== t) return;
				f = !1;
			} else for (; !(f = (e = i.call(t)).done) && (a$1.push(e.value), a$1.length !== l); f = !0);
		} catch (r$1) {
			o = !0, n = r$1;
		} finally {
			try {
				if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a$1;
	}
}
function _arrayWithHoles$9(arr) {
	if (Array.isArray(arr)) return arr;
}
var BREAKING_SPACES = /[ \f\n\r\t\v\u2028\u2029]+/;
var calculateWordWidths = function calculateWordWidths$1(_ref) {
	var children = _ref.children, breakAll = _ref.breakAll, style = _ref.style;
	try {
		var words = [];
		if (!(0, import_isNil$6.default)(children)) if (breakAll) words = children.toString().split("");
		else words = children.toString().split(BREAKING_SPACES);
		return {
			wordsWithComputedWidth: words.map(function(word) {
				return {
					word,
					width: getStringSize(word, style).width
				};
			}),
			spaceWidth: breakAll ? 0 : getStringSize("\xA0", style).width
		};
	} catch (e) {
		return null;
	}
};
var calculateWordsByLines = function calculateWordsByLines$1(_ref2, initialWordsWithComputedWith, spaceWidth, lineWidth, scaleToFit) {
	var maxLines = _ref2.maxLines, children = _ref2.children, style = _ref2.style, breakAll = _ref2.breakAll;
	var shouldLimitLines = isNumber(maxLines);
	var text = children;
	var calculate = function calculate$1() {
		return (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).reduce(function(result$1, _ref3) {
			var word = _ref3.word, width = _ref3.width;
			var currentLine = result$1[result$1.length - 1];
			if (currentLine && (lineWidth == null || scaleToFit || currentLine.width + width + spaceWidth < Number(lineWidth))) {
				currentLine.words.push(word);
				currentLine.width += width + spaceWidth;
			} else {
				var newLine = {
					words: [word],
					width
				};
				result$1.push(newLine);
			}
			return result$1;
		}, []);
	};
	var originalResult = calculate(initialWordsWithComputedWith);
	var findLongestLine = function findLongestLine$1(words) {
		return words.reduce(function(a$1, b) {
			return a$1.width > b.width ? a$1 : b;
		});
	};
	if (!shouldLimitLines) return originalResult;
	var suffix = "";
	var checkOverflow = function checkOverflow$1(index) {
		var words = calculateWordWidths({
			breakAll,
			style,
			children: text.slice(0, index) + suffix
		}).wordsWithComputedWidth;
		var result$1 = calculate(words);
		return [result$1.length > maxLines || findLongestLine(result$1).width > Number(lineWidth), result$1];
	};
	var start = 0;
	var end = text.length - 1;
	var iterations = 0;
	var trimmedResult;
	while (start <= end && iterations <= text.length - 1) {
		var middle = Math.floor((start + end) / 2);
		var _checkOverflow2 = _slicedToArray$8(checkOverflow(middle - 1), 2), doesPrevOverflow = _checkOverflow2[0], result = _checkOverflow2[1];
		var doesMiddleOverflow = _slicedToArray$8(checkOverflow(middle), 1)[0];
		if (!doesPrevOverflow && !doesMiddleOverflow) start = middle + 1;
		if (doesPrevOverflow && doesMiddleOverflow) end = middle - 1;
		if (!doesPrevOverflow && doesMiddleOverflow) {
			trimmedResult = result;
			break;
		}
		iterations++;
	}
	return trimmedResult || originalResult;
};
var getWordsWithoutCalculate = function getWordsWithoutCalculate$1(children) {
	return [{ words: !(0, import_isNil$6.default)(children) ? children.toString().split(BREAKING_SPACES) : [] }];
};
var getWordsByLines = function getWordsByLines$1(_ref4) {
	var width = _ref4.width, scaleToFit = _ref4.scaleToFit, children = _ref4.children, style = _ref4.style, breakAll = _ref4.breakAll, maxLines = _ref4.maxLines;
	if ((width || scaleToFit) && !Global.isSsr) {
		var wordsWithComputedWidth, spaceWidth;
		var wordWidths = calculateWordWidths({
			breakAll,
			children,
			style
		});
		if (wordWidths) {
			var wcw = wordWidths.wordsWithComputedWidth, sw = wordWidths.spaceWidth;
			wordsWithComputedWidth = wcw;
			spaceWidth = sw;
		} else return getWordsWithoutCalculate(children);
		return calculateWordsByLines({
			breakAll,
			children,
			maxLines,
			style
		}, wordsWithComputedWidth, spaceWidth, width, scaleToFit);
	}
	return getWordsWithoutCalculate(children);
};
var DEFAULT_FILL = "#808080";
var Text = function Text$1(_ref5) {
	var _ref5$x = _ref5.x, propsX = _ref5$x === void 0 ? 0 : _ref5$x, _ref5$y = _ref5.y, propsY = _ref5$y === void 0 ? 0 : _ref5$y, _ref5$lineHeight = _ref5.lineHeight, lineHeight = _ref5$lineHeight === void 0 ? "1em" : _ref5$lineHeight, _ref5$capHeight = _ref5.capHeight, capHeight = _ref5$capHeight === void 0 ? "0.71em" : _ref5$capHeight, _ref5$scaleToFit = _ref5.scaleToFit, scaleToFit = _ref5$scaleToFit === void 0 ? false : _ref5$scaleToFit, _ref5$textAnchor = _ref5.textAnchor, textAnchor = _ref5$textAnchor === void 0 ? "start" : _ref5$textAnchor, _ref5$verticalAnchor = _ref5.verticalAnchor, verticalAnchor = _ref5$verticalAnchor === void 0 ? "end" : _ref5$verticalAnchor, _ref5$fill = _ref5.fill, fill = _ref5$fill === void 0 ? DEFAULT_FILL : _ref5$fill, props = _objectWithoutProperties$11(_ref5, _excluded$11);
	var wordsByLines = (0, import_react.useMemo)(function() {
		return getWordsByLines({
			breakAll: props.breakAll,
			children: props.children,
			maxLines: props.maxLines,
			scaleToFit,
			style: props.style,
			width: props.width
		});
	}, [
		props.breakAll,
		props.children,
		props.maxLines,
		scaleToFit,
		props.style,
		props.width
	]);
	var dx = props.dx, dy = props.dy, angle = props.angle, className = props.className, breakAll = props.breakAll, textProps = _objectWithoutProperties$11(props, _excluded2$4);
	if (!isNumOrStr(propsX) || !isNumOrStr(propsY)) return null;
	var x$1 = propsX + (isNumber(dx) ? dx : 0);
	var y$1 = propsY + (isNumber(dy) ? dy : 0);
	var startDy;
	switch (verticalAnchor) {
		case "start":
			startDy = reduceCSSCalc("calc(".concat(capHeight, ")"));
			break;
		case "middle":
			startDy = reduceCSSCalc("calc(".concat((wordsByLines.length - 1) / 2, " * -").concat(lineHeight, " + (").concat(capHeight, " / 2))"));
			break;
		default:
			startDy = reduceCSSCalc("calc(".concat(wordsByLines.length - 1, " * -").concat(lineHeight, ")"));
			break;
	}
	var transforms = [];
	if (scaleToFit) {
		var lineWidth = wordsByLines[0].width;
		var width = props.width;
		transforms.push("scale(".concat((isNumber(width) ? width / lineWidth : 1) / lineWidth, ")"));
	}
	if (angle) transforms.push("rotate(".concat(angle, ", ").concat(x$1, ", ").concat(y$1, ")"));
	if (transforms.length) textProps.transform = transforms.join(" ");
	return /* @__PURE__ */ import_react.createElement("text", _extends$20({}, filterProps(textProps, true), {
		x: x$1,
		y: y$1,
		className: clsx_default("recharts-text", className),
		textAnchor,
		fill: fill.includes("url") ? DEFAULT_FILL : fill
	}), wordsByLines.map(function(line, index) {
		var words = line.words.join(breakAll ? "" : " ");
		return /* @__PURE__ */ import_react.createElement("tspan", {
			x: x$1,
			dy: index === 0 ? startDy : lineHeight,
			key: "".concat(words, "-").concat(index)
		}, words);
	}));
};
function ascending(a$1, b) {
	return a$1 == null || b == null ? NaN : a$1 < b ? -1 : a$1 > b ? 1 : a$1 >= b ? 0 : NaN;
}
function descending(a$1, b) {
	return a$1 == null || b == null ? NaN : b < a$1 ? -1 : b > a$1 ? 1 : b >= a$1 ? 0 : NaN;
}
function bisector(f) {
	let compare1, compare2, delta;
	if (f.length !== 2) {
		compare1 = ascending;
		compare2 = (d, x$1) => ascending(f(d), x$1);
		delta = (d, x$1) => f(d) - x$1;
	} else {
		compare1 = f === ascending || f === descending ? f : zero$1;
		compare2 = f;
		delta = f;
	}
	function left(a$1, x$1, lo = 0, hi = a$1.length) {
		if (lo < hi) {
			if (compare1(x$1, x$1) !== 0) return hi;
			do {
				const mid = lo + hi >>> 1;
				if (compare2(a$1[mid], x$1) < 0) lo = mid + 1;
				else hi = mid;
			} while (lo < hi);
		}
		return lo;
	}
	function right(a$1, x$1, lo = 0, hi = a$1.length) {
		if (lo < hi) {
			if (compare1(x$1, x$1) !== 0) return hi;
			do {
				const mid = lo + hi >>> 1;
				if (compare2(a$1[mid], x$1) <= 0) lo = mid + 1;
				else hi = mid;
			} while (lo < hi);
		}
		return lo;
	}
	function center(a$1, x$1, lo = 0, hi = a$1.length) {
		const i = left(a$1, x$1, lo, hi - 1);
		return i > lo && delta(a$1[i - 1], x$1) > -delta(a$1[i], x$1) ? i - 1 : i;
	}
	return {
		left,
		center,
		right
	};
}
function zero$1() {
	return 0;
}
function number$2(x$1) {
	return x$1 === null ? NaN : +x$1;
}
function* numbers(values, valueof) {
	if (valueof === void 0) {
		for (let value of values) if (value != null && (value = +value) >= value) yield value;
	} else {
		let index = -1;
		for (let value of values) if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) yield value;
	}
}
var ascendingBisect = bisector(ascending);
const bisectRight = ascendingBisect.right;
ascendingBisect.left;
bisector(number$2).center;
var bisect_default = bisectRight;
var InternMap = class extends Map {
	constructor(entries, key = keyof) {
		super();
		Object.defineProperties(this, {
			_intern: { value: /* @__PURE__ */ new Map() },
			_key: { value: key }
		});
		if (entries != null) for (const [key$1, value] of entries) this.set(key$1, value);
	}
	get(key) {
		return super.get(intern_get(this, key));
	}
	has(key) {
		return super.has(intern_get(this, key));
	}
	set(key, value) {
		return super.set(intern_set(this, key), value);
	}
	delete(key) {
		return super.delete(intern_delete(this, key));
	}
};
function intern_get({ _intern, _key }, value) {
	const key = _key(value);
	return _intern.has(key) ? _intern.get(key) : value;
}
function intern_set({ _intern, _key }, value) {
	const key = _key(value);
	if (_intern.has(key)) return _intern.get(key);
	_intern.set(key, value);
	return value;
}
function intern_delete({ _intern, _key }, value) {
	const key = _key(value);
	if (_intern.has(key)) {
		value = _intern.get(key);
		_intern.delete(key);
	}
	return value;
}
function keyof(value) {
	return value !== null && typeof value === "object" ? value.valueOf() : value;
}
function compareDefined(compare = ascending) {
	if (compare === ascending) return ascendingDefined;
	if (typeof compare !== "function") throw new TypeError("compare is not a function");
	return (a$1, b) => {
		const x$1 = compare(a$1, b);
		if (x$1 || x$1 === 0) return x$1;
		return (compare(b, b) === 0) - (compare(a$1, a$1) === 0);
	};
}
function ascendingDefined(a$1, b) {
	return (a$1 == null || !(a$1 >= a$1)) - (b == null || !(b >= b)) || (a$1 < b ? -1 : a$1 > b ? 1 : 0);
}
var e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
function tickSpec(start, stop, count) {
	const step = (stop - start) / Math.max(0, count), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
	let i1, i2, inc;
	if (power < 0) {
		inc = Math.pow(10, -power) / factor;
		i1 = Math.round(start * inc);
		i2 = Math.round(stop * inc);
		if (i1 / inc < start) ++i1;
		if (i2 / inc > stop) --i2;
		inc = -inc;
	} else {
		inc = Math.pow(10, power) * factor;
		i1 = Math.round(start / inc);
		i2 = Math.round(stop / inc);
		if (i1 * inc < start) ++i1;
		if (i2 * inc > stop) --i2;
	}
	if (i2 < i1 && .5 <= count && count < 2) return tickSpec(start, stop, count * 2);
	return [
		i1,
		i2,
		inc
	];
}
function ticks(start, stop, count) {
	stop = +stop, start = +start, count = +count;
	if (!(count > 0)) return [];
	if (start === stop) return [start];
	const reverse$1 = stop < start, [i1, i2, inc] = reverse$1 ? tickSpec(stop, start, count) : tickSpec(start, stop, count);
	if (!(i2 >= i1)) return [];
	const n = i2 - i1 + 1, ticks$1 = new Array(n);
	if (reverse$1) if (inc < 0) for (let i = 0; i < n; ++i) ticks$1[i] = (i2 - i) / -inc;
	else for (let i = 0; i < n; ++i) ticks$1[i] = (i2 - i) * inc;
	else if (inc < 0) for (let i = 0; i < n; ++i) ticks$1[i] = (i1 + i) / -inc;
	else for (let i = 0; i < n; ++i) ticks$1[i] = (i1 + i) * inc;
	return ticks$1;
}
function tickIncrement(start, stop, count) {
	stop = +stop, start = +start, count = +count;
	return tickSpec(start, stop, count)[2];
}
function tickStep(start, stop, count) {
	stop = +stop, start = +start, count = +count;
	const reverse$1 = stop < start, inc = reverse$1 ? tickIncrement(stop, start, count) : tickIncrement(start, stop, count);
	return (reverse$1 ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}
function max$2(values, valueof) {
	let max$3;
	if (valueof === void 0) {
		for (const value of values) if (value != null && (max$3 < value || max$3 === void 0 && value >= value)) max$3 = value;
	} else {
		let index = -1;
		for (let value of values) if ((value = valueof(value, ++index, values)) != null && (max$3 < value || max$3 === void 0 && value >= value)) max$3 = value;
	}
	return max$3;
}
function min$2(values, valueof) {
	let min$3;
	if (valueof === void 0) {
		for (const value of values) if (value != null && (min$3 > value || min$3 === void 0 && value >= value)) min$3 = value;
	} else {
		let index = -1;
		for (let value of values) if ((value = valueof(value, ++index, values)) != null && (min$3 > value || min$3 === void 0 && value >= value)) min$3 = value;
	}
	return min$3;
}
function quickselect(array, k$1, left = 0, right = Infinity, compare) {
	k$1 = Math.floor(k$1);
	left = Math.floor(Math.max(0, left));
	right = Math.floor(Math.min(array.length - 1, right));
	if (!(left <= k$1 && k$1 <= right)) return array;
	compare = compare === void 0 ? ascendingDefined : compareDefined(compare);
	while (right > left) {
		if (right - left > 600) {
			const n = right - left + 1;
			const m = k$1 - left + 1;
			const z = Math.log(n);
			const s$1 = .5 * Math.exp(2 * z / 3);
			const sd = .5 * Math.sqrt(z * s$1 * (n - s$1) / n) * (m - n / 2 < 0 ? -1 : 1);
			const newLeft = Math.max(left, Math.floor(k$1 - m * s$1 / n + sd));
			const newRight = Math.min(right, Math.floor(k$1 + (n - m) * s$1 / n + sd));
			quickselect(array, k$1, newLeft, newRight, compare);
		}
		const t = array[k$1];
		let i = left;
		let j = right;
		swap(array, left, k$1);
		if (compare(array[right], t) > 0) swap(array, left, right);
		while (i < j) {
			swap(array, i, j), ++i, --j;
			while (compare(array[i], t) < 0) ++i;
			while (compare(array[j], t) > 0) --j;
		}
		if (compare(array[left], t) === 0) swap(array, left, j);
		else ++j, swap(array, j, right);
		if (j <= k$1) left = j + 1;
		if (k$1 <= j) right = j - 1;
	}
	return array;
}
function swap(array, i, j) {
	const t = array[i];
	array[i] = array[j];
	array[j] = t;
}
function quantile(values, p, valueof) {
	values = Float64Array.from(numbers(values, valueof));
	if (!(n = values.length) || isNaN(p = +p)) return;
	if (p <= 0 || n < 2) return min$2(values);
	if (p >= 1) return max$2(values);
	var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = max$2(quickselect(values, i0).subarray(0, i0 + 1));
	return value0 + (min$2(values.subarray(i0 + 1)) - value0) * (i - i0);
}
function quantileSorted(values, p, valueof = number$2) {
	if (!(n = values.length) || isNaN(p = +p)) return;
	if (p <= 0 || n < 2) return +valueof(values[0], 0, values);
	if (p >= 1) return +valueof(values[n - 1], n - 1, values);
	var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values[i0], i0, values);
	return value0 + (+valueof(values[i0 + 1], i0 + 1, values) - value0) * (i - i0);
}
function range$4(start, stop, step) {
	start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
	var i = -1, n = Math.max(0, Math.ceil((stop - start) / step)) | 0, range$5 = new Array(n);
	while (++i < n) range$5[i] = start + i * step;
	return range$5;
}
function initRange(domain, range$5) {
	switch (arguments.length) {
		case 0: break;
		case 1:
			this.range(domain);
			break;
		default:
			this.range(range$5).domain(domain);
			break;
	}
	return this;
}
function initInterpolator(domain, interpolator) {
	switch (arguments.length) {
		case 0: break;
		case 1:
			if (typeof domain === "function") this.interpolator(domain);
			else this.range(domain);
			break;
		default:
			this.domain(domain);
			if (typeof interpolator === "function") this.interpolator(interpolator);
			else this.range(interpolator);
			break;
	}
	return this;
}
const implicit = Symbol("implicit");
function ordinal() {
	var index = new InternMap(), domain = [], range$5 = [], unknown = implicit;
	function scale(d) {
		let i = index.get(d);
		if (i === void 0) {
			if (unknown !== implicit) return unknown;
			index.set(d, i = domain.push(d) - 1);
		}
		return range$5[i % range$5.length];
	}
	scale.domain = function(_) {
		if (!arguments.length) return domain.slice();
		domain = [], index = new InternMap();
		for (const value of _) {
			if (index.has(value)) continue;
			index.set(value, domain.push(value) - 1);
		}
		return scale;
	};
	scale.range = function(_) {
		return arguments.length ? (range$5 = Array.from(_), scale) : range$5.slice();
	};
	scale.unknown = function(_) {
		return arguments.length ? (unknown = _, scale) : unknown;
	};
	scale.copy = function() {
		return ordinal(domain, range$5).unknown(unknown);
	};
	initRange.apply(scale, arguments);
	return scale;
}
function band() {
	var scale = ordinal().unknown(void 0), domain = scale.domain, ordinalRange = scale.range, r0 = 0, r1 = 1, step, bandwidth, round = false, paddingInner = 0, paddingOuter = 0, align = .5;
	delete scale.unknown;
	function rescale() {
		var n = domain().length, reverse$1 = r1 < r0, start = reverse$1 ? r1 : r0, stop = reverse$1 ? r0 : r1;
		step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
		if (round) step = Math.floor(step);
		start += (stop - start - step * (n - paddingInner)) * align;
		bandwidth = step * (1 - paddingInner);
		if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
		var values = range$4(n).map(function(i) {
			return start + step * i;
		});
		return ordinalRange(reverse$1 ? values.reverse() : values);
	}
	scale.domain = function(_) {
		return arguments.length ? (domain(_), rescale()) : domain();
	};
	scale.range = function(_) {
		return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
	};
	scale.rangeRound = function(_) {
		return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
	};
	scale.bandwidth = function() {
		return bandwidth;
	};
	scale.step = function() {
		return step;
	};
	scale.round = function(_) {
		return arguments.length ? (round = !!_, rescale()) : round;
	};
	scale.padding = function(_) {
		return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
	};
	scale.paddingInner = function(_) {
		return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
	};
	scale.paddingOuter = function(_) {
		return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
	};
	scale.align = function(_) {
		return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
	};
	scale.copy = function() {
		return band(domain(), [r0, r1]).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
	};
	return initRange.apply(rescale(), arguments);
}
function pointish(scale) {
	var copy$2 = scale.copy;
	scale.padding = scale.paddingOuter;
	delete scale.paddingInner;
	delete scale.paddingOuter;
	scale.copy = function() {
		return pointish(copy$2());
	};
	return scale;
}
function point() {
	return pointish(band.apply(null, arguments).paddingInner(1));
}
function define_default(constructor, factory, prototype) {
	constructor.prototype = factory.prototype = prototype;
	prototype.constructor = constructor;
}
function extend(parent, definition) {
	var prototype = Object.create(parent.prototype);
	for (var key in definition) prototype[key] = definition[key];
	return prototype;
}
function Color() {}
var darker = .7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = /* @__PURE__ */ new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = /* @__PURE__ */ new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = /* @__PURE__ */ new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = /* @__PURE__ */ new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = /* @__PURE__ */ new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = /* @__PURE__ */ new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
	aliceblue: 15792383,
	antiquewhite: 16444375,
	aqua: 65535,
	aquamarine: 8388564,
	azure: 15794175,
	beige: 16119260,
	bisque: 16770244,
	black: 0,
	blanchedalmond: 16772045,
	blue: 255,
	blueviolet: 9055202,
	brown: 10824234,
	burlywood: 14596231,
	cadetblue: 6266528,
	chartreuse: 8388352,
	chocolate: 13789470,
	coral: 16744272,
	cornflowerblue: 6591981,
	cornsilk: 16775388,
	crimson: 14423100,
	cyan: 65535,
	darkblue: 139,
	darkcyan: 35723,
	darkgoldenrod: 12092939,
	darkgray: 11119017,
	darkgreen: 25600,
	darkgrey: 11119017,
	darkkhaki: 12433259,
	darkmagenta: 9109643,
	darkolivegreen: 5597999,
	darkorange: 16747520,
	darkorchid: 10040012,
	darkred: 9109504,
	darksalmon: 15308410,
	darkseagreen: 9419919,
	darkslateblue: 4734347,
	darkslategray: 3100495,
	darkslategrey: 3100495,
	darkturquoise: 52945,
	darkviolet: 9699539,
	deeppink: 16716947,
	deepskyblue: 49151,
	dimgray: 6908265,
	dimgrey: 6908265,
	dodgerblue: 2003199,
	firebrick: 11674146,
	floralwhite: 16775920,
	forestgreen: 2263842,
	fuchsia: 16711935,
	gainsboro: 14474460,
	ghostwhite: 16316671,
	gold: 16766720,
	goldenrod: 14329120,
	gray: 8421504,
	green: 32768,
	greenyellow: 11403055,
	grey: 8421504,
	honeydew: 15794160,
	hotpink: 16738740,
	indianred: 13458524,
	indigo: 4915330,
	ivory: 16777200,
	khaki: 15787660,
	lavender: 15132410,
	lavenderblush: 16773365,
	lawngreen: 8190976,
	lemonchiffon: 16775885,
	lightblue: 11393254,
	lightcoral: 15761536,
	lightcyan: 14745599,
	lightgoldenrodyellow: 16448210,
	lightgray: 13882323,
	lightgreen: 9498256,
	lightgrey: 13882323,
	lightpink: 16758465,
	lightsalmon: 16752762,
	lightseagreen: 2142890,
	lightskyblue: 8900346,
	lightslategray: 7833753,
	lightslategrey: 7833753,
	lightsteelblue: 11584734,
	lightyellow: 16777184,
	lime: 65280,
	limegreen: 3329330,
	linen: 16445670,
	magenta: 16711935,
	maroon: 8388608,
	mediumaquamarine: 6737322,
	mediumblue: 205,
	mediumorchid: 12211667,
	mediumpurple: 9662683,
	mediumseagreen: 3978097,
	mediumslateblue: 8087790,
	mediumspringgreen: 64154,
	mediumturquoise: 4772300,
	mediumvioletred: 13047173,
	midnightblue: 1644912,
	mintcream: 16121850,
	mistyrose: 16770273,
	moccasin: 16770229,
	navajowhite: 16768685,
	navy: 128,
	oldlace: 16643558,
	olive: 8421376,
	olivedrab: 7048739,
	orange: 16753920,
	orangered: 16729344,
	orchid: 14315734,
	palegoldenrod: 15657130,
	palegreen: 10025880,
	paleturquoise: 11529966,
	palevioletred: 14381203,
	papayawhip: 16773077,
	peachpuff: 16767673,
	peru: 13468991,
	pink: 16761035,
	plum: 14524637,
	powderblue: 11591910,
	purple: 8388736,
	rebeccapurple: 6697881,
	red: 16711680,
	rosybrown: 12357519,
	royalblue: 4286945,
	saddlebrown: 9127187,
	salmon: 16416882,
	sandybrown: 16032864,
	seagreen: 3050327,
	seashell: 16774638,
	sienna: 10506797,
	silver: 12632256,
	skyblue: 8900331,
	slateblue: 6970061,
	slategray: 7372944,
	slategrey: 7372944,
	snow: 16775930,
	springgreen: 65407,
	steelblue: 4620980,
	tan: 13808780,
	teal: 32896,
	thistle: 14204888,
	tomato: 16737095,
	turquoise: 4251856,
	violet: 15631086,
	wheat: 16113331,
	white: 16777215,
	whitesmoke: 16119285,
	yellow: 16776960,
	yellowgreen: 10145074
};
define_default(Color, color, {
	copy(channels) {
		return Object.assign(new this.constructor(), this, channels);
	},
	displayable() {
		return this.rgb().displayable();
	},
	hex: color_formatHex,
	formatHex: color_formatHex,
	formatHex8: color_formatHex8,
	formatHsl: color_formatHsl,
	formatRgb: color_formatRgb,
	toString: color_formatRgb
});
function color_formatHex() {
	return this.rgb().formatHex();
}
function color_formatHex8() {
	return this.rgb().formatHex8();
}
function color_formatHsl() {
	return hslConvert(this).formatHsl();
}
function color_formatRgb() {
	return this.rgb().formatRgb();
}
function color(format$1) {
	var m, l;
	format$1 = (format$1 + "").trim().toLowerCase();
	return (m = reHex.exec(format$1)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format$1)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format$1)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format$1)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format$1)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format$1)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format$1)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format$1) ? rgbn(named[format$1]) : format$1 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
	return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a$1) {
	if (a$1 <= 0) r = g = b = NaN;
	return new Rgb(r, g, b, a$1);
}
function rgbConvert(o) {
	if (!(o instanceof Color)) o = color(o);
	if (!o) return new Rgb();
	o = o.rgb();
	return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
	return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
	this.r = +r;
	this.g = +g;
	this.b = +b;
	this.opacity = +opacity;
}
define_default(Rgb, rgb, extend(Color, {
	brighter(k$1) {
		k$1 = k$1 == null ? brighter : Math.pow(brighter, k$1);
		return new Rgb(this.r * k$1, this.g * k$1, this.b * k$1, this.opacity);
	},
	darker(k$1) {
		k$1 = k$1 == null ? darker : Math.pow(darker, k$1);
		return new Rgb(this.r * k$1, this.g * k$1, this.b * k$1, this.opacity);
	},
	rgb() {
		return this;
	},
	clamp() {
		return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
	},
	displayable() {
		return -.5 <= this.r && this.r < 255.5 && -.5 <= this.g && this.g < 255.5 && -.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
	},
	hex: rgb_formatHex,
	formatHex: rgb_formatHex,
	formatHex8: rgb_formatHex8,
	formatRgb: rgb_formatRgb,
	toString: rgb_formatRgb
}));
function rgb_formatHex() {
	return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
	return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
	const a$1 = clampa(this.opacity);
	return `${a$1 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a$1 === 1 ? ")" : `, ${a$1})`}`;
}
function clampa(opacity) {
	return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
	return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
	value = clampi(value);
	return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s$1, l, a$1) {
	if (a$1 <= 0) h = s$1 = l = NaN;
	else if (l <= 0 || l >= 1) h = s$1 = NaN;
	else if (s$1 <= 0) h = NaN;
	return new Hsl(h, s$1, l, a$1);
}
function hslConvert(o) {
	if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
	if (!(o instanceof Color)) o = color(o);
	if (!o) return new Hsl();
	if (o instanceof Hsl) return o;
	o = o.rgb();
	var r = o.r / 255, g = o.g / 255, b = o.b / 255, min$3 = Math.min(r, g, b), max$3 = Math.max(r, g, b), h = NaN, s$1 = max$3 - min$3, l = (max$3 + min$3) / 2;
	if (s$1) {
		if (r === max$3) h = (g - b) / s$1 + (g < b) * 6;
		else if (g === max$3) h = (b - r) / s$1 + 2;
		else h = (r - g) / s$1 + 4;
		s$1 /= l < .5 ? max$3 + min$3 : 2 - max$3 - min$3;
		h *= 60;
	} else s$1 = l > 0 && l < 1 ? 0 : h;
	return new Hsl(h, s$1, l, o.opacity);
}
function hsl(h, s$1, l, opacity) {
	return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s$1, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s$1, l, opacity) {
	this.h = +h;
	this.s = +s$1;
	this.l = +l;
	this.opacity = +opacity;
}
define_default(Hsl, hsl, extend(Color, {
	brighter(k$1) {
		k$1 = k$1 == null ? brighter : Math.pow(brighter, k$1);
		return new Hsl(this.h, this.s, this.l * k$1, this.opacity);
	},
	darker(k$1) {
		k$1 = k$1 == null ? darker : Math.pow(darker, k$1);
		return new Hsl(this.h, this.s, this.l * k$1, this.opacity);
	},
	rgb() {
		var h = this.h % 360 + (this.h < 0) * 360, s$1 = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < .5 ? l : 1 - l) * s$1, m1 = 2 * l - m2;
		return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
	},
	clamp() {
		return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
	},
	displayable() {
		return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
	},
	formatHsl() {
		const a$1 = clampa(this.opacity);
		return `${a$1 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a$1 === 1 ? ")" : `, ${a$1})`}`;
	}
}));
function clamph(value) {
	value = (value || 0) % 360;
	return value < 0 ? value + 360 : value;
}
function clampt(value) {
	return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h, m1, m2) {
	return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}
function basis(t1$1, v0, v1, v2, v3) {
	var t2 = t1$1 * t1$1, t3 = t2 * t1$1;
	return ((1 - 3 * t1$1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1$1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
}
function basis_default$1(values) {
	var n = values.length - 1;
	return function(t) {
		var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
		return basis((t - i / n) * n, v0, v1, v2, v3);
	};
}
function basisClosed_default$1(values) {
	var n = values.length;
	return function(t) {
		var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
		return basis((t - i / n) * n, v0, v1, v2, v3);
	};
}
var constant_default = (x$1) => () => x$1;
function linear$1(a$1, d) {
	return function(t) {
		return a$1 + t * d;
	};
}
function exponential(a$1, b, y$1) {
	return a$1 = Math.pow(a$1, y$1), b = Math.pow(b, y$1) - a$1, y$1 = 1 / y$1, function(t) {
		return Math.pow(a$1 + t * b, y$1);
	};
}
function gamma(y$1) {
	return (y$1 = +y$1) === 1 ? nogamma : function(a$1, b) {
		return b - a$1 ? exponential(a$1, b, y$1) : constant_default(isNaN(a$1) ? b : a$1);
	};
}
function nogamma(a$1, b) {
	var d = b - a$1;
	return d ? linear$1(a$1, d) : constant_default(isNaN(a$1) ? b : a$1);
}
var rgb_default = (function rgbGamma(y$1) {
	var color$1 = gamma(y$1);
	function rgb$1(start, end) {
		var r = color$1((start = rgb(start)).r, (end = rgb(end)).r), g = color$1(start.g, end.g), b = color$1(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
		return function(t) {
			start.r = r(t);
			start.g = g(t);
			start.b = b(t);
			start.opacity = opacity(t);
			return start + "";
		};
	}
	rgb$1.gamma = rgbGamma;
	return rgb$1;
})(1);
function rgbSpline(spline) {
	return function(colors) {
		var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color$1;
		for (i = 0; i < n; ++i) {
			color$1 = rgb(colors[i]);
			r[i] = color$1.r || 0;
			g[i] = color$1.g || 0;
			b[i] = color$1.b || 0;
		}
		r = spline(r);
		g = spline(g);
		b = spline(b);
		color$1.opacity = 1;
		return function(t) {
			color$1.r = r(t);
			color$1.g = g(t);
			color$1.b = b(t);
			return color$1 + "";
		};
	};
}
rgbSpline(basis_default$1);
rgbSpline(basisClosed_default$1);
function numberArray_default(a$1, b) {
	if (!b) b = [];
	var n = a$1 ? Math.min(b.length, a$1.length) : 0, c$1 = b.slice(), i;
	return function(t) {
		for (i = 0; i < n; ++i) c$1[i] = a$1[i] * (1 - t) + b[i] * t;
		return c$1;
	};
}
function isNumberArray(x$1) {
	return ArrayBuffer.isView(x$1) && !(x$1 instanceof DataView);
}
function genericArray(a$1, b) {
	var nb = b ? b.length : 0, na = a$1 ? Math.min(nb, a$1.length) : 0, x$1 = new Array(na), c$1 = new Array(nb), i;
	for (i = 0; i < na; ++i) x$1[i] = value_default(a$1[i], b[i]);
	for (; i < nb; ++i) c$1[i] = b[i];
	return function(t) {
		for (i = 0; i < na; ++i) c$1[i] = x$1[i](t);
		return c$1;
	};
}
function date_default(a$1, b) {
	var d = /* @__PURE__ */ new Date();
	return a$1 = +a$1, b = +b, function(t) {
		return d.setTime(a$1 * (1 - t) + b * t), d;
	};
}
function number_default(a$1, b) {
	return a$1 = +a$1, b = +b, function(t) {
		return a$1 * (1 - t) + b * t;
	};
}
function object_default(a$1, b) {
	var i = {}, c$1 = {}, k$1;
	if (a$1 === null || typeof a$1 !== "object") a$1 = {};
	if (b === null || typeof b !== "object") b = {};
	for (k$1 in b) if (k$1 in a$1) i[k$1] = value_default(a$1[k$1], b[k$1]);
	else c$1[k$1] = b[k$1];
	return function(t) {
		for (k$1 in i) c$1[k$1] = i[k$1](t);
		return c$1;
	};
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
function zero(b) {
	return function() {
		return b;
	};
}
function one(b) {
	return function(t) {
		return b(t) + "";
	};
}
function string_default(a$1, b) {
	var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s$1 = [], q = [];
	a$1 = a$1 + "", b = b + "";
	while ((am = reA.exec(a$1)) && (bm = reB.exec(b))) {
		if ((bs = bm.index) > bi) {
			bs = b.slice(bi, bs);
			if (s$1[i]) s$1[i] += bs;
			else s$1[++i] = bs;
		}
		if ((am = am[0]) === (bm = bm[0])) if (s$1[i]) s$1[i] += bm;
		else s$1[++i] = bm;
		else {
			s$1[++i] = null;
			q.push({
				i,
				x: number_default(am, bm)
			});
		}
		bi = reB.lastIndex;
	}
	if (bi < b.length) {
		bs = b.slice(bi);
		if (s$1[i]) s$1[i] += bs;
		else s$1[++i] = bs;
	}
	return s$1.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
		for (var i$1 = 0, o; i$1 < b; ++i$1) s$1[(o = q[i$1]).i] = o.x(t);
		return s$1.join("");
	});
}
function value_default(a$1, b) {
	var t = typeof b, c$1;
	return b == null || t === "boolean" ? constant_default(b) : (t === "number" ? number_default : t === "string" ? (c$1 = color(b)) ? (b = c$1, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default)(a$1, b);
}
function round_default(a$1, b) {
	return a$1 = +a$1, b = +b, function(t) {
		return Math.round(a$1 * (1 - t) + b * t);
	};
}
function piecewise(interpolate, values) {
	if (values === void 0) values = interpolate, interpolate = value_default;
	var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
	while (i < n) I[i] = interpolate(v, v = values[++i]);
	return function(t) {
		var i$1 = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
		return I[i$1](t - i$1);
	};
}
function constants(x$1) {
	return function() {
		return x$1;
	};
}
function number$1(x$1) {
	return +x$1;
}
var unit = [0, 1];
function identity$4(x$1) {
	return x$1;
}
function normalize(a$1, b) {
	return (b -= a$1 = +a$1) ? function(x$1) {
		return (x$1 - a$1) / b;
	} : constants(isNaN(b) ? NaN : .5);
}
function clamper(a$1, b) {
	var t;
	if (a$1 > b) t = a$1, a$1 = b, b = t;
	return function(x$1) {
		return Math.max(a$1, Math.min(b, x$1));
	};
}
function bimap(domain, range$5, interpolate) {
	var d0 = domain[0], d1 = domain[1], r0 = range$5[0], r1 = range$5[1];
	if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
	else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
	return function(x$1) {
		return r0(d0(x$1));
	};
}
function polymap(domain, range$5, interpolate) {
	var j = Math.min(domain.length, range$5.length) - 1, d = new Array(j), r = new Array(j), i = -1;
	if (domain[j] < domain[0]) {
		domain = domain.slice().reverse();
		range$5 = range$5.slice().reverse();
	}
	while (++i < j) {
		d[i] = normalize(domain[i], domain[i + 1]);
		r[i] = interpolate(range$5[i], range$5[i + 1]);
	}
	return function(x$1) {
		var i$1 = bisect_default(domain, x$1, 1, j) - 1;
		return r[i$1](d[i$1](x$1));
	};
}
function copy$1(source, target) {
	return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer$2() {
	var domain = unit, range$5 = unit, interpolate = value_default, transform, untransform, unknown, clamp = identity$4, piecewise$1, output, input;
	function rescale() {
		var n = Math.min(domain.length, range$5.length);
		if (clamp !== identity$4) clamp = clamper(domain[0], domain[n - 1]);
		piecewise$1 = n > 2 ? polymap : bimap;
		output = input = null;
		return scale;
	}
	function scale(x$1) {
		return x$1 == null || isNaN(x$1 = +x$1) ? unknown : (output || (output = piecewise$1(domain.map(transform), range$5, interpolate)))(transform(clamp(x$1)));
	}
	scale.invert = function(y$1) {
		return clamp(untransform((input || (input = piecewise$1(range$5, domain.map(transform), number_default)))(y$1)));
	};
	scale.domain = function(_) {
		return arguments.length ? (domain = Array.from(_, number$1), rescale()) : domain.slice();
	};
	scale.range = function(_) {
		return arguments.length ? (range$5 = Array.from(_), rescale()) : range$5.slice();
	};
	scale.rangeRound = function(_) {
		return range$5 = Array.from(_), interpolate = round_default, rescale();
	};
	scale.clamp = function(_) {
		return arguments.length ? (clamp = _ ? true : identity$4, rescale()) : clamp !== identity$4;
	};
	scale.interpolate = function(_) {
		return arguments.length ? (interpolate = _, rescale()) : interpolate;
	};
	scale.unknown = function(_) {
		return arguments.length ? (unknown = _, scale) : unknown;
	};
	return function(t, u) {
		transform = t, untransform = u;
		return rescale();
	};
}
function continuous() {
	return transformer$2()(identity$4, identity$4);
}
function formatDecimal_default(x$1) {
	return Math.abs(x$1 = Math.round(x$1)) >= 1e21 ? x$1.toLocaleString("en").replace(/,/g, "") : x$1.toString(10);
}
function formatDecimalParts(x$1, p) {
	if ((i = (x$1 = p ? x$1.toExponential(p - 1) : x$1.toExponential()).indexOf("e")) < 0) return null;
	var i, coefficient = x$1.slice(0, i);
	return [coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient, +x$1.slice(i + 1)];
}
function exponent_default(x$1) {
	return x$1 = formatDecimalParts(Math.abs(x$1)), x$1 ? x$1[1] : NaN;
}
function formatGroup_default(grouping, thousands) {
	return function(value, width) {
		var i = value.length, t = [], j = 0, g = grouping[0], length = 0;
		while (i > 0 && g > 0) {
			if (length + g + 1 > width) g = Math.max(1, width - length);
			t.push(value.substring(i -= g, i + g));
			if ((length += g + 1) > width) break;
			g = grouping[j = (j + 1) % grouping.length];
		}
		return t.reverse().join(thousands);
	};
}
function formatNumerals_default(numerals) {
	return function(value) {
		return value.replace(/[0-9]/g, function(i) {
			return numerals[+i];
		});
	};
}
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
	if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
	var match;
	return new FormatSpecifier({
		fill: match[1],
		align: match[2],
		sign: match[3],
		symbol: match[4],
		zero: match[5],
		width: match[6],
		comma: match[7],
		precision: match[8] && match[8].slice(1),
		trim: match[9],
		type: match[10]
	});
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
	this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
	this.align = specifier.align === void 0 ? ">" : specifier.align + "";
	this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
	this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
	this.zero = !!specifier.zero;
	this.width = specifier.width === void 0 ? void 0 : +specifier.width;
	this.comma = !!specifier.comma;
	this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
	this.trim = !!specifier.trim;
	this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
	return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function formatTrim_default(s$1) {
	out: for (var n = s$1.length, i = 1, i0 = -1, i1; i < n; ++i) switch (s$1[i]) {
		case ".":
			i0 = i1 = i;
			break;
		case "0":
			if (i0 === 0) i0 = i;
			i1 = i;
			break;
		default:
			if (!+s$1[i]) break out;
			if (i0 > 0) i0 = 0;
			break;
	}
	return i0 > 0 ? s$1.slice(0, i0) + s$1.slice(i1 + 1) : s$1;
}
var prefixExponent;
function formatPrefixAuto_default(x$1, p) {
	var d = formatDecimalParts(x$1, p);
	if (!d) return x$1 + "";
	var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
	return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x$1, Math.max(0, p + i - 1))[0];
}
function formatRounded_default(x$1, p) {
	var d = formatDecimalParts(x$1, p);
	if (!d) return x$1 + "";
	var coefficient = d[0], exponent = d[1];
	return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}
var formatTypes_default = {
	"%": (x$1, p) => (x$1 * 100).toFixed(p),
	"b": (x$1) => Math.round(x$1).toString(2),
	"c": (x$1) => x$1 + "",
	"d": formatDecimal_default,
	"e": (x$1, p) => x$1.toExponential(p),
	"f": (x$1, p) => x$1.toFixed(p),
	"g": (x$1, p) => x$1.toPrecision(p),
	"o": (x$1) => Math.round(x$1).toString(8),
	"p": (x$1, p) => formatRounded_default(x$1 * 100, p),
	"r": formatRounded_default,
	"s": formatPrefixAuto_default,
	"X": (x$1) => Math.round(x$1).toString(16).toUpperCase(),
	"x": (x$1) => Math.round(x$1).toString(16)
};
function identity_default(x$1) {
	return x$1;
}
var map$3 = Array.prototype.map, prefixes = [
	"y",
	"z",
	"a",
	"f",
	"p",
	"n",
	"",
	"m",
	"",
	"k",
	"M",
	"G",
	"T",
	"P",
	"E",
	"Z",
	"Y"
];
function locale_default(locale$2) {
	var group = locale$2.grouping === void 0 || locale$2.thousands === void 0 ? identity_default : formatGroup_default(map$3.call(locale$2.grouping, Number), locale$2.thousands + ""), currencyPrefix = locale$2.currency === void 0 ? "" : locale$2.currency[0] + "", currencySuffix = locale$2.currency === void 0 ? "" : locale$2.currency[1] + "", decimal = locale$2.decimal === void 0 ? "." : locale$2.decimal + "", numerals = locale$2.numerals === void 0 ? identity_default : formatNumerals_default(map$3.call(locale$2.numerals, String)), percent = locale$2.percent === void 0 ? "%" : locale$2.percent + "", minus = locale$2.minus === void 0 ? "" : locale$2.minus + "", nan = locale$2.nan === void 0 ? "NaN" : locale$2.nan + "";
	function newFormat(specifier) {
		specifier = formatSpecifier(specifier);
		var fill = specifier.fill, align = specifier.align, sign$1 = specifier.sign, symbol = specifier.symbol, zero$2 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
		if (type === "n") comma = true, type = "g";
		else if (!formatTypes_default[type]) precision === void 0 && (precision = 12), trim = true, type = "g";
		if (zero$2 || fill === "0" && align === "=") zero$2 = true, fill = "0", align = "=";
		var prefix$2 = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
		var formatType = formatTypes_default[type], maybeSuffix = /[defgprs%]/.test(type);
		precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
		function format$1(value) {
			var valuePrefix = prefix$2, valueSuffix = suffix, i, n, c$1;
			if (type === "c") {
				valueSuffix = formatType(value) + valueSuffix;
				value = "";
			} else {
				value = +value;
				var valueNegative = value < 0 || 1 / value < 0;
				value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
				if (trim) value = formatTrim_default(value);
				if (valueNegative && +value === 0 && sign$1 !== "+") valueNegative = false;
				valuePrefix = (valueNegative ? sign$1 === "(" ? sign$1 : minus : sign$1 === "-" || sign$1 === "(" ? "" : sign$1) + valuePrefix;
				valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign$1 === "(" ? ")" : "");
				if (maybeSuffix) {
					i = -1, n = value.length;
					while (++i < n) if (c$1 = value.charCodeAt(i), 48 > c$1 || c$1 > 57) {
						valueSuffix = (c$1 === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
						value = value.slice(0, i);
						break;
					}
				}
			}
			if (comma && !zero$2) value = group(value, Infinity);
			var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
			if (comma && zero$2) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
			switch (align) {
				case "<":
					value = valuePrefix + value + valueSuffix + padding;
					break;
				case "=":
					value = valuePrefix + padding + value + valueSuffix;
					break;
				case "^":
					value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
					break;
				default:
					value = padding + valuePrefix + value + valueSuffix;
					break;
			}
			return numerals(value);
		}
		format$1.toString = function() {
			return specifier + "";
		};
		return format$1;
	}
	function formatPrefix$1(specifier, value) {
		var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k$1 = Math.pow(10, -e), prefix$2 = prefixes[8 + e / 3];
		return function(value$1) {
			return f(k$1 * value$1) + prefix$2;
		};
	}
	return {
		format: newFormat,
		formatPrefix: formatPrefix$1
	};
}
var locale$1;
var format;
var formatPrefix;
defaultLocale$1({
	thousands: ",",
	grouping: [3],
	currency: ["$", ""]
});
function defaultLocale$1(definition) {
	locale$1 = locale_default(definition);
	format = locale$1.format;
	formatPrefix = locale$1.formatPrefix;
	return locale$1;
}
function precisionFixed_default(step) {
	return Math.max(0, -exponent_default(Math.abs(step)));
}
function precisionPrefix_default(step, value) {
	return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));
}
function precisionRound_default(step, max$3) {
	step = Math.abs(step), max$3 = Math.abs(max$3) - step;
	return Math.max(0, exponent_default(max$3) - exponent_default(step)) + 1;
}
function tickFormat(start, stop, count, specifier) {
	var step = tickStep(start, stop, count), precision;
	specifier = formatSpecifier(specifier == null ? ",f" : specifier);
	switch (specifier.type) {
		case "s":
			var value = Math.max(Math.abs(start), Math.abs(stop));
			if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value))) specifier.precision = precision;
			return formatPrefix(specifier, value);
		case "":
		case "e":
		case "g":
		case "p":
		case "r":
			if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
			break;
		case "f":
		case "%":
			if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step))) specifier.precision = precision - (specifier.type === "%") * 2;
			break;
	}
	return format(specifier);
}
function linearish(scale) {
	var domain = scale.domain;
	scale.ticks = function(count) {
		var d = domain();
		return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
	};
	scale.tickFormat = function(count, specifier) {
		var d = domain();
		return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
	};
	scale.nice = function(count) {
		if (count == null) count = 10;
		var d = domain();
		var i0 = 0;
		var i1 = d.length - 1;
		var start = d[i0];
		var stop = d[i1];
		var prestep;
		var step;
		var maxIter = 10;
		if (stop < start) {
			step = start, start = stop, stop = step;
			step = i0, i0 = i1, i1 = step;
		}
		while (maxIter-- > 0) {
			step = tickIncrement(start, stop, count);
			if (step === prestep) {
				d[i0] = start;
				d[i1] = stop;
				return domain(d);
			} else if (step > 0) {
				start = Math.floor(start / step) * step;
				stop = Math.ceil(stop / step) * step;
			} else if (step < 0) {
				start = Math.ceil(start * step) / step;
				stop = Math.floor(stop * step) / step;
			} else break;
			prestep = step;
		}
		return scale;
	};
	return scale;
}
function linear() {
	var scale = continuous();
	scale.copy = function() {
		return copy$1(scale, linear());
	};
	initRange.apply(scale, arguments);
	return linearish(scale);
}
function identity$5(domain) {
	var unknown;
	function scale(x$1) {
		return x$1 == null || isNaN(x$1 = +x$1) ? unknown : x$1;
	}
	scale.invert = scale;
	scale.domain = scale.range = function(_) {
		return arguments.length ? (domain = Array.from(_, number$1), scale) : domain.slice();
	};
	scale.unknown = function(_) {
		return arguments.length ? (unknown = _, scale) : unknown;
	};
	scale.copy = function() {
		return identity$5(domain).unknown(unknown);
	};
	domain = arguments.length ? Array.from(domain, number$1) : [0, 1];
	return linearish(scale);
}
function nice(domain, interval) {
	domain = domain.slice();
	var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], t;
	if (x1 < x0) {
		t = i0, i0 = i1, i1 = t;
		t = x0, x0 = x1, x1 = t;
	}
	domain[i0] = interval.floor(x0);
	domain[i1] = interval.ceil(x1);
	return domain;
}
function transformLog(x$1) {
	return Math.log(x$1);
}
function transformExp(x$1) {
	return Math.exp(x$1);
}
function transformLogn(x$1) {
	return -Math.log(-x$1);
}
function transformExpn(x$1) {
	return -Math.exp(-x$1);
}
function pow10(x$1) {
	return isFinite(x$1) ? +("1e" + x$1) : x$1 < 0 ? 0 : x$1;
}
function powp(base) {
	return base === 10 ? pow10 : base === Math.E ? Math.exp : (x$1) => Math.pow(base, x$1);
}
function logp(base) {
	return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), (x$1) => Math.log(x$1) / base);
}
function reflect(f) {
	return (x$1, k$1) => -f(-x$1, k$1);
}
function loggish(transform) {
	const scale = transform(transformLog, transformExp);
	const domain = scale.domain;
	let base = 10;
	let logs;
	let pows;
	function rescale() {
		logs = logp(base), pows = powp(base);
		if (domain()[0] < 0) {
			logs = reflect(logs), pows = reflect(pows);
			transform(transformLogn, transformExpn);
		} else transform(transformLog, transformExp);
		return scale;
	}
	scale.base = function(_) {
		return arguments.length ? (base = +_, rescale()) : base;
	};
	scale.domain = function(_) {
		return arguments.length ? (domain(_), rescale()) : domain();
	};
	scale.ticks = (count) => {
		const d = domain();
		let u = d[0];
		let v = d[d.length - 1];
		const r = v < u;
		if (r) [u, v] = [v, u];
		let i = logs(u);
		let j = logs(v);
		let k$1;
		let t;
		const n = count == null ? 10 : +count;
		let z = [];
		if (!(base % 1) && j - i < n) {
			i = Math.floor(i), j = Math.ceil(j);
			if (u > 0) for (; i <= j; ++i) for (k$1 = 1; k$1 < base; ++k$1) {
				t = i < 0 ? k$1 / pows(-i) : k$1 * pows(i);
				if (t < u) continue;
				if (t > v) break;
				z.push(t);
			}
			else for (; i <= j; ++i) for (k$1 = base - 1; k$1 >= 1; --k$1) {
				t = i > 0 ? k$1 / pows(-i) : k$1 * pows(i);
				if (t < u) continue;
				if (t > v) break;
				z.push(t);
			}
			if (z.length * 2 < n) z = ticks(u, v, n);
		} else z = ticks(i, j, Math.min(j - i, n)).map(pows);
		return r ? z.reverse() : z;
	};
	scale.tickFormat = (count, specifier) => {
		if (count == null) count = 10;
		if (specifier == null) specifier = base === 10 ? "s" : ",";
		if (typeof specifier !== "function") {
			if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null) specifier.trim = true;
			specifier = format(specifier);
		}
		if (count === Infinity) return specifier;
		const k$1 = Math.max(1, base * count / scale.ticks().length);
		return (d) => {
			let i = d / pows(Math.round(logs(d)));
			if (i * base < base - .5) i *= base;
			return i <= k$1 ? specifier(d) : "";
		};
	};
	scale.nice = () => {
		return domain(nice(domain(), {
			floor: (x$1) => pows(Math.floor(logs(x$1))),
			ceil: (x$1) => pows(Math.ceil(logs(x$1)))
		}));
	};
	return scale;
}
function log() {
	const scale = loggish(transformer$2()).domain([1, 10]);
	scale.copy = () => copy$1(scale, log()).base(scale.base());
	initRange.apply(scale, arguments);
	return scale;
}
function transformSymlog(c$1) {
	return function(x$1) {
		return Math.sign(x$1) * Math.log1p(Math.abs(x$1 / c$1));
	};
}
function transformSymexp(c$1) {
	return function(x$1) {
		return Math.sign(x$1) * Math.expm1(Math.abs(x$1)) * c$1;
	};
}
function symlogish(transform) {
	var c$1 = 1, scale = transform(transformSymlog(c$1), transformSymexp(c$1));
	scale.constant = function(_) {
		return arguments.length ? transform(transformSymlog(c$1 = +_), transformSymexp(c$1)) : c$1;
	};
	return linearish(scale);
}
function symlog() {
	var scale = symlogish(transformer$2());
	scale.copy = function() {
		return copy$1(scale, symlog()).constant(scale.constant());
	};
	return initRange.apply(scale, arguments);
}
function transformPow(exponent) {
	return function(x$1) {
		return x$1 < 0 ? -Math.pow(-x$1, exponent) : Math.pow(x$1, exponent);
	};
}
function transformSqrt(x$1) {
	return x$1 < 0 ? -Math.sqrt(-x$1) : Math.sqrt(x$1);
}
function transformSquare(x$1) {
	return x$1 < 0 ? -x$1 * x$1 : x$1 * x$1;
}
function powish(transform) {
	var scale = transform(identity$4, identity$4), exponent = 1;
	function rescale() {
		return exponent === 1 ? transform(identity$4, identity$4) : exponent === .5 ? transform(transformSqrt, transformSquare) : transform(transformPow(exponent), transformPow(1 / exponent));
	}
	scale.exponent = function(_) {
		return arguments.length ? (exponent = +_, rescale()) : exponent;
	};
	return linearish(scale);
}
function pow() {
	var scale = powish(transformer$2());
	scale.copy = function() {
		return copy$1(scale, pow()).exponent(scale.exponent());
	};
	initRange.apply(scale, arguments);
	return scale;
}
function sqrt() {
	return pow.apply(null, arguments).exponent(.5);
}
function square(x$1) {
	return Math.sign(x$1) * x$1 * x$1;
}
function unsquare(x$1) {
	return Math.sign(x$1) * Math.sqrt(Math.abs(x$1));
}
function radial() {
	var squared = continuous(), range$5 = [0, 1], round = false, unknown;
	function scale(x$1) {
		var y$1 = unsquare(squared(x$1));
		return isNaN(y$1) ? unknown : round ? Math.round(y$1) : y$1;
	}
	scale.invert = function(y$1) {
		return squared.invert(square(y$1));
	};
	scale.domain = function(_) {
		return arguments.length ? (squared.domain(_), scale) : squared.domain();
	};
	scale.range = function(_) {
		return arguments.length ? (squared.range((range$5 = Array.from(_, number$1)).map(square)), scale) : range$5.slice();
	};
	scale.rangeRound = function(_) {
		return scale.range(_).round(true);
	};
	scale.round = function(_) {
		return arguments.length ? (round = !!_, scale) : round;
	};
	scale.clamp = function(_) {
		return arguments.length ? (squared.clamp(_), scale) : squared.clamp();
	};
	scale.unknown = function(_) {
		return arguments.length ? (unknown = _, scale) : unknown;
	};
	scale.copy = function() {
		return radial(squared.domain(), range$5).round(round).clamp(squared.clamp()).unknown(unknown);
	};
	initRange.apply(scale, arguments);
	return linearish(scale);
}
function quantile$1() {
	var domain = [], range$5 = [], thresholds = [], unknown;
	function rescale() {
		var i = 0, n = Math.max(1, range$5.length);
		thresholds = new Array(n - 1);
		while (++i < n) thresholds[i - 1] = quantileSorted(domain, i / n);
		return scale;
	}
	function scale(x$1) {
		return x$1 == null || isNaN(x$1 = +x$1) ? unknown : range$5[bisect_default(thresholds, x$1)];
	}
	scale.invertExtent = function(y$1) {
		var i = range$5.indexOf(y$1);
		return i < 0 ? [NaN, NaN] : [i > 0 ? thresholds[i - 1] : domain[0], i < thresholds.length ? thresholds[i] : domain[domain.length - 1]];
	};
	scale.domain = function(_) {
		if (!arguments.length) return domain.slice();
		domain = [];
		for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
		domain.sort(ascending);
		return rescale();
	};
	scale.range = function(_) {
		return arguments.length ? (range$5 = Array.from(_), rescale()) : range$5.slice();
	};
	scale.unknown = function(_) {
		return arguments.length ? (unknown = _, scale) : unknown;
	};
	scale.quantiles = function() {
		return thresholds.slice();
	};
	scale.copy = function() {
		return quantile$1().domain(domain).range(range$5).unknown(unknown);
	};
	return initRange.apply(scale, arguments);
}
function quantize() {
	var x0 = 0, x1 = 1, n = 1, domain = [.5], range$5 = [0, 1], unknown;
	function scale(x$1) {
		return x$1 != null && x$1 <= x$1 ? range$5[bisect_default(domain, x$1, 0, n)] : unknown;
	}
	function rescale() {
		var i = -1;
		domain = new Array(n);
		while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
		return scale;
	}
	scale.domain = function(_) {
		return arguments.length ? ([x0, x1] = _, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
	};
	scale.range = function(_) {
		return arguments.length ? (n = (range$5 = Array.from(_)).length - 1, rescale()) : range$5.slice();
	};
	scale.invertExtent = function(y$1) {
		var i = range$5.indexOf(y$1);
		return i < 0 ? [NaN, NaN] : i < 1 ? [x0, domain[0]] : i >= n ? [domain[n - 1], x1] : [domain[i - 1], domain[i]];
	};
	scale.unknown = function(_) {
		return arguments.length ? (unknown = _, scale) : scale;
	};
	scale.thresholds = function() {
		return domain.slice();
	};
	scale.copy = function() {
		return quantize().domain([x0, x1]).range(range$5).unknown(unknown);
	};
	return initRange.apply(linearish(scale), arguments);
}
function threshold() {
	var domain = [.5], range$5 = [0, 1], unknown, n = 1;
	function scale(x$1) {
		return x$1 != null && x$1 <= x$1 ? range$5[bisect_default(domain, x$1, 0, n)] : unknown;
	}
	scale.domain = function(_) {
		return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range$5.length - 1), scale) : domain.slice();
	};
	scale.range = function(_) {
		return arguments.length ? (range$5 = Array.from(_), n = Math.min(domain.length, range$5.length - 1), scale) : range$5.slice();
	};
	scale.invertExtent = function(y$1) {
		var i = range$5.indexOf(y$1);
		return [domain[i - 1], domain[i]];
	};
	scale.unknown = function(_) {
		return arguments.length ? (unknown = _, scale) : unknown;
	};
	scale.copy = function() {
		return threshold().domain(domain).range(range$5).unknown(unknown);
	};
	return initRange.apply(scale, arguments);
}
var t0 = /* @__PURE__ */ new Date(), t1 = /* @__PURE__ */ new Date();
function timeInterval(floori, offseti, count, field) {
	function interval(date$1) {
		return floori(date$1 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date$1)), date$1;
	}
	interval.floor = (date$1) => {
		return floori(date$1 = /* @__PURE__ */ new Date(+date$1)), date$1;
	};
	interval.ceil = (date$1) => {
		return floori(date$1 = /* @__PURE__ */ new Date(date$1 - 1)), offseti(date$1, 1), floori(date$1), date$1;
	};
	interval.round = (date$1) => {
		const d0 = interval(date$1), d1 = interval.ceil(date$1);
		return date$1 - d0 < d1 - date$1 ? d0 : d1;
	};
	interval.offset = (date$1, step) => {
		return offseti(date$1 = /* @__PURE__ */ new Date(+date$1), step == null ? 1 : Math.floor(step)), date$1;
	};
	interval.range = (start, stop, step) => {
		const range$5 = [];
		start = interval.ceil(start);
		step = step == null ? 1 : Math.floor(step);
		if (!(start < stop) || !(step > 0)) return range$5;
		let previous;
		do
			range$5.push(previous = /* @__PURE__ */ new Date(+start)), offseti(start, step), floori(start);
		while (previous < start && start < stop);
		return range$5;
	};
	interval.filter = (test) => {
		return timeInterval((date$1) => {
			if (date$1 >= date$1) while (floori(date$1), !test(date$1)) date$1.setTime(date$1 - 1);
		}, (date$1, step) => {
			if (date$1 >= date$1) if (step < 0) while (++step <= 0) while (offseti(date$1, -1), !test(date$1));
			else while (--step >= 0) while (offseti(date$1, 1), !test(date$1));
		});
	};
	if (count) {
		interval.count = (start, end) => {
			t0.setTime(+start), t1.setTime(+end);
			floori(t0), floori(t1);
			return Math.floor(count(t0, t1));
		};
		interval.every = (step) => {
			step = Math.floor(step);
			return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? (d) => field(d) % step === 0 : (d) => interval.count(0, d) % step === 0);
		};
	}
	return interval;
}
const millisecond = timeInterval(() => {}, (date$1, step) => {
	date$1.setTime(+date$1 + step);
}, (start, end) => {
	return end - start;
});
millisecond.every = (k$1) => {
	k$1 = Math.floor(k$1);
	if (!isFinite(k$1) || !(k$1 > 0)) return null;
	if (!(k$1 > 1)) return millisecond;
	return timeInterval((date$1) => {
		date$1.setTime(Math.floor(date$1 / k$1) * k$1);
	}, (date$1, step) => {
		date$1.setTime(+date$1 + step * k$1);
	}, (start, end) => {
		return (end - start) / k$1;
	});
};
millisecond.range;
const durationSecond = 1e3;
const durationMinute = durationSecond * 60;
const durationHour = durationMinute * 60;
const durationDay = durationHour * 24;
const durationWeek = durationDay * 7;
const durationMonth = durationDay * 30;
const durationYear = durationDay * 365;
const second = timeInterval((date$1) => {
	date$1.setTime(date$1 - date$1.getMilliseconds());
}, (date$1, step) => {
	date$1.setTime(+date$1 + step * durationSecond);
}, (start, end) => {
	return (end - start) / durationSecond;
}, (date$1) => {
	return date$1.getUTCSeconds();
});
second.range;
const timeMinute = timeInterval((date$1) => {
	date$1.setTime(date$1 - date$1.getMilliseconds() - date$1.getSeconds() * durationSecond);
}, (date$1, step) => {
	date$1.setTime(+date$1 + step * durationMinute);
}, (start, end) => {
	return (end - start) / durationMinute;
}, (date$1) => {
	return date$1.getMinutes();
});
timeMinute.range;
const utcMinute = timeInterval((date$1) => {
	date$1.setUTCSeconds(0, 0);
}, (date$1, step) => {
	date$1.setTime(+date$1 + step * durationMinute);
}, (start, end) => {
	return (end - start) / durationMinute;
}, (date$1) => {
	return date$1.getUTCMinutes();
});
utcMinute.range;
const timeHour = timeInterval((date$1) => {
	date$1.setTime(date$1 - date$1.getMilliseconds() - date$1.getSeconds() * durationSecond - date$1.getMinutes() * durationMinute);
}, (date$1, step) => {
	date$1.setTime(+date$1 + step * durationHour);
}, (start, end) => {
	return (end - start) / durationHour;
}, (date$1) => {
	return date$1.getHours();
});
timeHour.range;
const utcHour = timeInterval((date$1) => {
	date$1.setUTCMinutes(0, 0, 0);
}, (date$1, step) => {
	date$1.setTime(+date$1 + step * durationHour);
}, (start, end) => {
	return (end - start) / durationHour;
}, (date$1) => {
	return date$1.getUTCHours();
});
utcHour.range;
const timeDay = timeInterval((date$1) => date$1.setHours(0, 0, 0, 0), (date$1, step) => date$1.setDate(date$1.getDate() + step), (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay, (date$1) => date$1.getDate() - 1);
timeDay.range;
const utcDay = timeInterval((date$1) => {
	date$1.setUTCHours(0, 0, 0, 0);
}, (date$1, step) => {
	date$1.setUTCDate(date$1.getUTCDate() + step);
}, (start, end) => {
	return (end - start) / durationDay;
}, (date$1) => {
	return date$1.getUTCDate() - 1;
});
utcDay.range;
const unixDay = timeInterval((date$1) => {
	date$1.setUTCHours(0, 0, 0, 0);
}, (date$1, step) => {
	date$1.setUTCDate(date$1.getUTCDate() + step);
}, (start, end) => {
	return (end - start) / durationDay;
}, (date$1) => {
	return Math.floor(date$1 / durationDay);
});
unixDay.range;
function timeWeekday(i) {
	return timeInterval((date$1) => {
		date$1.setDate(date$1.getDate() - (date$1.getDay() + 7 - i) % 7);
		date$1.setHours(0, 0, 0, 0);
	}, (date$1, step) => {
		date$1.setDate(date$1.getDate() + step * 7);
	}, (start, end) => {
		return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
	});
}
const timeSunday = timeWeekday(0);
const timeMonday = timeWeekday(1);
const timeTuesday = timeWeekday(2);
const timeWednesday = timeWeekday(3);
const timeThursday = timeWeekday(4);
const timeFriday = timeWeekday(5);
const timeSaturday = timeWeekday(6);
timeSunday.range;
timeMonday.range;
timeTuesday.range;
timeWednesday.range;
timeThursday.range;
timeFriday.range;
timeSaturday.range;
function utcWeekday(i) {
	return timeInterval((date$1) => {
		date$1.setUTCDate(date$1.getUTCDate() - (date$1.getUTCDay() + 7 - i) % 7);
		date$1.setUTCHours(0, 0, 0, 0);
	}, (date$1, step) => {
		date$1.setUTCDate(date$1.getUTCDate() + step * 7);
	}, (start, end) => {
		return (end - start) / durationWeek;
	});
}
const utcSunday = utcWeekday(0);
const utcMonday = utcWeekday(1);
const utcTuesday = utcWeekday(2);
const utcWednesday = utcWeekday(3);
const utcThursday = utcWeekday(4);
const utcFriday = utcWeekday(5);
const utcSaturday = utcWeekday(6);
utcSunday.range;
utcMonday.range;
utcTuesday.range;
utcWednesday.range;
utcThursday.range;
utcFriday.range;
utcSaturday.range;
const timeMonth = timeInterval((date$1) => {
	date$1.setDate(1);
	date$1.setHours(0, 0, 0, 0);
}, (date$1, step) => {
	date$1.setMonth(date$1.getMonth() + step);
}, (start, end) => {
	return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, (date$1) => {
	return date$1.getMonth();
});
timeMonth.range;
const utcMonth = timeInterval((date$1) => {
	date$1.setUTCDate(1);
	date$1.setUTCHours(0, 0, 0, 0);
}, (date$1, step) => {
	date$1.setUTCMonth(date$1.getUTCMonth() + step);
}, (start, end) => {
	return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, (date$1) => {
	return date$1.getUTCMonth();
});
utcMonth.range;
const timeYear = timeInterval((date$1) => {
	date$1.setMonth(0, 1);
	date$1.setHours(0, 0, 0, 0);
}, (date$1, step) => {
	date$1.setFullYear(date$1.getFullYear() + step);
}, (start, end) => {
	return end.getFullYear() - start.getFullYear();
}, (date$1) => {
	return date$1.getFullYear();
});
timeYear.every = (k$1) => {
	return !isFinite(k$1 = Math.floor(k$1)) || !(k$1 > 0) ? null : timeInterval((date$1) => {
		date$1.setFullYear(Math.floor(date$1.getFullYear() / k$1) * k$1);
		date$1.setMonth(0, 1);
		date$1.setHours(0, 0, 0, 0);
	}, (date$1, step) => {
		date$1.setFullYear(date$1.getFullYear() + step * k$1);
	});
};
timeYear.range;
const utcYear = timeInterval((date$1) => {
	date$1.setUTCMonth(0, 1);
	date$1.setUTCHours(0, 0, 0, 0);
}, (date$1, step) => {
	date$1.setUTCFullYear(date$1.getUTCFullYear() + step);
}, (start, end) => {
	return end.getUTCFullYear() - start.getUTCFullYear();
}, (date$1) => {
	return date$1.getUTCFullYear();
});
utcYear.every = (k$1) => {
	return !isFinite(k$1 = Math.floor(k$1)) || !(k$1 > 0) ? null : timeInterval((date$1) => {
		date$1.setUTCFullYear(Math.floor(date$1.getUTCFullYear() / k$1) * k$1);
		date$1.setUTCMonth(0, 1);
		date$1.setUTCHours(0, 0, 0, 0);
	}, (date$1, step) => {
		date$1.setUTCFullYear(date$1.getUTCFullYear() + step * k$1);
	});
};
utcYear.range;
function ticker(year, month, week, day, hour, minute) {
	const tickIntervals = [
		[
			second,
			1,
			durationSecond
		],
		[
			second,
			5,
			5 * durationSecond
		],
		[
			second,
			15,
			15 * durationSecond
		],
		[
			second,
			30,
			30 * durationSecond
		],
		[
			minute,
			1,
			durationMinute
		],
		[
			minute,
			5,
			5 * durationMinute
		],
		[
			minute,
			15,
			15 * durationMinute
		],
		[
			minute,
			30,
			30 * durationMinute
		],
		[
			hour,
			1,
			durationHour
		],
		[
			hour,
			3,
			3 * durationHour
		],
		[
			hour,
			6,
			6 * durationHour
		],
		[
			hour,
			12,
			12 * durationHour
		],
		[
			day,
			1,
			durationDay
		],
		[
			day,
			2,
			2 * durationDay
		],
		[
			week,
			1,
			durationWeek
		],
		[
			month,
			1,
			durationMonth
		],
		[
			month,
			3,
			3 * durationMonth
		],
		[
			year,
			1,
			durationYear
		]
	];
	function ticks$1(start, stop, count) {
		const reverse$1 = stop < start;
		if (reverse$1) [start, stop] = [stop, start];
		const interval = count && typeof count.range === "function" ? count : tickInterval(start, stop, count);
		const ticks$2 = interval ? interval.range(start, +stop + 1) : [];
		return reverse$1 ? ticks$2.reverse() : ticks$2;
	}
	function tickInterval(start, stop, count) {
		const target = Math.abs(stop - start) / count;
		const i = bisector(([, , step$1]) => step$1).right(tickIntervals, target);
		if (i === tickIntervals.length) return year.every(tickStep(start / durationYear, stop / durationYear, count));
		if (i === 0) return millisecond.every(Math.max(tickStep(start, stop, count), 1));
		const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
		return t.every(step);
	}
	return [ticks$1, tickInterval];
}
var [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
var [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);
function localDate(d) {
	if (0 <= d.y && d.y < 100) {
		var date$1 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
		date$1.setFullYear(d.y);
		return date$1;
	}
	return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate(d) {
	if (0 <= d.y && d.y < 100) {
		var date$1 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
		date$1.setUTCFullYear(d.y);
		return date$1;
	}
	return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate(y$1, m, d) {
	return {
		y: y$1,
		m,
		d,
		H: 0,
		M: 0,
		S: 0,
		L: 0
	};
}
function formatLocale(locale$2) {
	var locale_dateTime = locale$2.dateTime, locale_date = locale$2.date, locale_time = locale$2.time, locale_periods = locale$2.periods, locale_weekdays = locale$2.days, locale_shortWeekdays = locale$2.shortDays, locale_months = locale$2.months, locale_shortMonths = locale$2.shortMonths;
	var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
	var formats = {
		"a": formatShortWeekday,
		"A": formatWeekday,
		"b": formatShortMonth,
		"B": formatMonth,
		"c": null,
		"d": formatDayOfMonth,
		"e": formatDayOfMonth,
		"f": formatMicroseconds,
		"g": formatYearISO,
		"G": formatFullYearISO,
		"H": formatHour24,
		"I": formatHour12,
		"j": formatDayOfYear,
		"L": formatMilliseconds,
		"m": formatMonthNumber,
		"M": formatMinutes,
		"p": formatPeriod,
		"q": formatQuarter,
		"Q": formatUnixTimestamp,
		"s": formatUnixTimestampSeconds,
		"S": formatSeconds,
		"u": formatWeekdayNumberMonday,
		"U": formatWeekNumberSunday,
		"V": formatWeekNumberISO,
		"w": formatWeekdayNumberSunday,
		"W": formatWeekNumberMonday,
		"x": null,
		"X": null,
		"y": formatYear,
		"Y": formatFullYear,
		"Z": formatZone,
		"%": formatLiteralPercent
	};
	var utcFormats = {
		"a": formatUTCShortWeekday,
		"A": formatUTCWeekday,
		"b": formatUTCShortMonth,
		"B": formatUTCMonth,
		"c": null,
		"d": formatUTCDayOfMonth,
		"e": formatUTCDayOfMonth,
		"f": formatUTCMicroseconds,
		"g": formatUTCYearISO,
		"G": formatUTCFullYearISO,
		"H": formatUTCHour24,
		"I": formatUTCHour12,
		"j": formatUTCDayOfYear,
		"L": formatUTCMilliseconds,
		"m": formatUTCMonthNumber,
		"M": formatUTCMinutes,
		"p": formatUTCPeriod,
		"q": formatUTCQuarter,
		"Q": formatUnixTimestamp,
		"s": formatUnixTimestampSeconds,
		"S": formatUTCSeconds,
		"u": formatUTCWeekdayNumberMonday,
		"U": formatUTCWeekNumberSunday,
		"V": formatUTCWeekNumberISO,
		"w": formatUTCWeekdayNumberSunday,
		"W": formatUTCWeekNumberMonday,
		"x": null,
		"X": null,
		"y": formatUTCYear,
		"Y": formatUTCFullYear,
		"Z": formatUTCZone,
		"%": formatLiteralPercent
	};
	var parses = {
		"a": parseShortWeekday,
		"A": parseWeekday,
		"b": parseShortMonth,
		"B": parseMonth,
		"c": parseLocaleDateTime,
		"d": parseDayOfMonth,
		"e": parseDayOfMonth,
		"f": parseMicroseconds,
		"g": parseYear,
		"G": parseFullYear,
		"H": parseHour24,
		"I": parseHour24,
		"j": parseDayOfYear,
		"L": parseMilliseconds,
		"m": parseMonthNumber,
		"M": parseMinutes,
		"p": parsePeriod,
		"q": parseQuarter,
		"Q": parseUnixTimestamp,
		"s": parseUnixTimestampSeconds,
		"S": parseSeconds,
		"u": parseWeekdayNumberMonday,
		"U": parseWeekNumberSunday,
		"V": parseWeekNumberISO,
		"w": parseWeekdayNumberSunday,
		"W": parseWeekNumberMonday,
		"x": parseLocaleDate,
		"X": parseLocaleTime,
		"y": parseYear,
		"Y": parseFullYear,
		"Z": parseZone,
		"%": parseLiteralPercent
	};
	formats.x = newFormat(locale_date, formats);
	formats.X = newFormat(locale_time, formats);
	formats.c = newFormat(locale_dateTime, formats);
	utcFormats.x = newFormat(locale_date, utcFormats);
	utcFormats.X = newFormat(locale_time, utcFormats);
	utcFormats.c = newFormat(locale_dateTime, utcFormats);
	function newFormat(specifier, formats$1) {
		return function(date$1) {
			var string = [], i = -1, j = 0, n = specifier.length, c$1, pad$1, format$1;
			if (!(date$1 instanceof Date)) date$1 = /* @__PURE__ */ new Date(+date$1);
			while (++i < n) if (specifier.charCodeAt(i) === 37) {
				string.push(specifier.slice(j, i));
				if ((pad$1 = pads[c$1 = specifier.charAt(++i)]) != null) c$1 = specifier.charAt(++i);
				else pad$1 = c$1 === "e" ? " " : "0";
				if (format$1 = formats$1[c$1]) c$1 = format$1(date$1, pad$1);
				string.push(c$1);
				j = i + 1;
			}
			string.push(specifier.slice(j, i));
			return string.join("");
		};
	}
	function newParse(specifier, Z) {
		return function(string) {
			var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string += "", 0), week, day;
			if (i != string.length) return null;
			if ("Q" in d) return new Date(d.Q);
			if ("s" in d) return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
			if (Z && !("Z" in d)) d.Z = 0;
			if ("p" in d) d.H = d.H % 12 + d.p * 12;
			if (d.m === void 0) d.m = "q" in d ? d.q : 0;
			if ("V" in d) {
				if (d.V < 1 || d.V > 53) return null;
				if (!("w" in d)) d.w = 1;
				if ("Z" in d) {
					week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
					week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
					week = utcDay.offset(week, (d.V - 1) * 7);
					d.y = week.getUTCFullYear();
					d.m = week.getUTCMonth();
					d.d = week.getUTCDate() + (d.w + 6) % 7;
				} else {
					week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
					week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
					week = timeDay.offset(week, (d.V - 1) * 7);
					d.y = week.getFullYear();
					d.m = week.getMonth();
					d.d = week.getDate() + (d.w + 6) % 7;
				}
			} else if ("W" in d || "U" in d) {
				if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
				day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
				d.m = 0;
				d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
			}
			if ("Z" in d) {
				d.H += d.Z / 100 | 0;
				d.M += d.Z % 100;
				return utcDate(d);
			}
			return localDate(d);
		};
	}
	function parseSpecifier(d, specifier, string, j) {
		var i = 0, n = specifier.length, m = string.length, c$1, parse;
		while (i < n) {
			if (j >= m) return -1;
			c$1 = specifier.charCodeAt(i++);
			if (c$1 === 37) {
				c$1 = specifier.charAt(i++);
				parse = parses[c$1 in pads ? specifier.charAt(i++) : c$1];
				if (!parse || (j = parse(d, string, j)) < 0) return -1;
			} else if (c$1 != string.charCodeAt(j++)) return -1;
		}
		return j;
	}
	function parsePeriod(d, string, i) {
		var n = periodRe.exec(string.slice(i));
		return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	}
	function parseShortWeekday(d, string, i) {
		var n = shortWeekdayRe.exec(string.slice(i));
		return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	}
	function parseWeekday(d, string, i) {
		var n = weekdayRe.exec(string.slice(i));
		return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	}
	function parseShortMonth(d, string, i) {
		var n = shortMonthRe.exec(string.slice(i));
		return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	}
	function parseMonth(d, string, i) {
		var n = monthRe.exec(string.slice(i));
		return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	}
	function parseLocaleDateTime(d, string, i) {
		return parseSpecifier(d, locale_dateTime, string, i);
	}
	function parseLocaleDate(d, string, i) {
		return parseSpecifier(d, locale_date, string, i);
	}
	function parseLocaleTime(d, string, i) {
		return parseSpecifier(d, locale_time, string, i);
	}
	function formatShortWeekday(d) {
		return locale_shortWeekdays[d.getDay()];
	}
	function formatWeekday(d) {
		return locale_weekdays[d.getDay()];
	}
	function formatShortMonth(d) {
		return locale_shortMonths[d.getMonth()];
	}
	function formatMonth(d) {
		return locale_months[d.getMonth()];
	}
	function formatPeriod(d) {
		return locale_periods[+(d.getHours() >= 12)];
	}
	function formatQuarter(d) {
		return 1 + ~~(d.getMonth() / 3);
	}
	function formatUTCShortWeekday(d) {
		return locale_shortWeekdays[d.getUTCDay()];
	}
	function formatUTCWeekday(d) {
		return locale_weekdays[d.getUTCDay()];
	}
	function formatUTCShortMonth(d) {
		return locale_shortMonths[d.getUTCMonth()];
	}
	function formatUTCMonth(d) {
		return locale_months[d.getUTCMonth()];
	}
	function formatUTCPeriod(d) {
		return locale_periods[+(d.getUTCHours() >= 12)];
	}
	function formatUTCQuarter(d) {
		return 1 + ~~(d.getUTCMonth() / 3);
	}
	return {
		format: function(specifier) {
			var f = newFormat(specifier += "", formats);
			f.toString = function() {
				return specifier;
			};
			return f;
		},
		parse: function(specifier) {
			var p = newParse(specifier += "", false);
			p.toString = function() {
				return specifier;
			};
			return p;
		},
		utcFormat: function(specifier) {
			var f = newFormat(specifier += "", utcFormats);
			f.toString = function() {
				return specifier;
			};
			return f;
		},
		utcParse: function(specifier) {
			var p = newParse(specifier += "", true);
			p.toString = function() {
				return specifier;
			};
			return p;
		}
	};
}
var pads = {
	"-": "",
	"_": " ",
	"0": "0"
}, numberRe = /^\s*\d+/, percentRe = /^%/, requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad(value, fill, width) {
	var sign$1 = value < 0 ? "-" : "", string = (sign$1 ? -value : value) + "", length = string.length;
	return sign$1 + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}
function requote(s$1) {
	return s$1.replace(requoteRe, "\\$&");
}
function formatRe(names) {
	return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
	return new Map(names.map((name, i) => [name.toLowerCase(), i]));
}
function parseWeekdayNumberSunday(d, string, i) {
	var n = numberRe.exec(string.slice(i, i + 1));
	return n ? (d.w = +n[0], i + n[0].length) : -1;
}
function parseWeekdayNumberMonday(d, string, i) {
	var n = numberRe.exec(string.slice(i, i + 1));
	return n ? (d.u = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberSunday(d, string, i) {
	var n = numberRe.exec(string.slice(i, i + 2));
	return n ? (d.U = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberISO(d, string, i) {
	var n = numberRe.exec(string.slice(i, i + 2));
	return n ? (d.V = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberMonday(d, string, i) {
	var n = numberRe.exec(string.slice(i, i + 2));
	return n ? (d.W = +n[0], i + n[0].length) : -1;
}
function parseFullYear(d, string, i) {
	var n = numberRe.exec(string.slice(i, i + 4));
	return n ? (d.y = +n[0], i + n[0].length) : -1;
}
function parseYear(d, string, i) {
	var n = numberRe.exec(string.slice(i, i + 2));
	return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
}
function parseZone(d, string, i) {
	var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
	return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}
function parseQuarter(d, string, i) {
	var n = numberRe.exec(string.slice(i, i + 1));
	return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}
function parseMonthNumber(d, string, i) {
	var n = numberRe.exec(string.slice(i, i + 2));
	return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}
function parseDayOfMonth(d, string, i) {
	var n = numberRe.exec(string.slice(i, i + 2));
	return n ? (d.d = +n[0], i + n[0].length) : -1;
}
function parseDayOfYear(d, string, i) {
	var n = numberRe.exec(string.slice(i, i + 3));
	return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}
function parseHour24(d, string, i) {
	var n = numberRe.exec(string.slice(i, i + 2));
	return n ? (d.H = +n[0], i + n[0].length) : -1;
}
function parseMinutes(d, string, i) {
	var n = numberRe.exec(string.slice(i, i + 2));
	return n ? (d.M = +n[0], i + n[0].length) : -1;
}
function parseSeconds(d, string, i) {
	var n = numberRe.exec(string.slice(i, i + 2));
	return n ? (d.S = +n[0], i + n[0].length) : -1;
}
function parseMilliseconds(d, string, i) {
	var n = numberRe.exec(string.slice(i, i + 3));
	return n ? (d.L = +n[0], i + n[0].length) : -1;
}
function parseMicroseconds(d, string, i) {
	var n = numberRe.exec(string.slice(i, i + 6));
	return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
}
function parseLiteralPercent(d, string, i) {
	var n = percentRe.exec(string.slice(i, i + 1));
	return n ? i + n[0].length : -1;
}
function parseUnixTimestamp(d, string, i) {
	var n = numberRe.exec(string.slice(i));
	return n ? (d.Q = +n[0], i + n[0].length) : -1;
}
function parseUnixTimestampSeconds(d, string, i) {
	var n = numberRe.exec(string.slice(i));
	return n ? (d.s = +n[0], i + n[0].length) : -1;
}
function formatDayOfMonth(d, p) {
	return pad(d.getDate(), p, 2);
}
function formatHour24(d, p) {
	return pad(d.getHours(), p, 2);
}
function formatHour12(d, p) {
	return pad(d.getHours() % 12 || 12, p, 2);
}
function formatDayOfYear(d, p) {
	return pad(1 + timeDay.count(timeYear(d), d), p, 3);
}
function formatMilliseconds(d, p) {
	return pad(d.getMilliseconds(), p, 3);
}
function formatMicroseconds(d, p) {
	return formatMilliseconds(d, p) + "000";
}
function formatMonthNumber(d, p) {
	return pad(d.getMonth() + 1, p, 2);
}
function formatMinutes(d, p) {
	return pad(d.getMinutes(), p, 2);
}
function formatSeconds(d, p) {
	return pad(d.getSeconds(), p, 2);
}
function formatWeekdayNumberMonday(d) {
	var day = d.getDay();
	return day === 0 ? 7 : day;
}
function formatWeekNumberSunday(d, p) {
	return pad(timeSunday.count(timeYear(d) - 1, d), p, 2);
}
function dISO(d) {
	var day = d.getDay();
	return day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
}
function formatWeekNumberISO(d, p) {
	d = dISO(d);
	return pad(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
}
function formatWeekdayNumberSunday(d) {
	return d.getDay();
}
function formatWeekNumberMonday(d, p) {
	return pad(timeMonday.count(timeYear(d) - 1, d), p, 2);
}
function formatYear(d, p) {
	return pad(d.getFullYear() % 100, p, 2);
}
function formatYearISO(d, p) {
	d = dISO(d);
	return pad(d.getFullYear() % 100, p, 2);
}
function formatFullYear(d, p) {
	return pad(d.getFullYear() % 1e4, p, 4);
}
function formatFullYearISO(d, p) {
	var day = d.getDay();
	d = day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
	return pad(d.getFullYear() % 1e4, p, 4);
}
function formatZone(d) {
	var z = d.getTimezoneOffset();
	return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
}
function formatUTCDayOfMonth(d, p) {
	return pad(d.getUTCDate(), p, 2);
}
function formatUTCHour24(d, p) {
	return pad(d.getUTCHours(), p, 2);
}
function formatUTCHour12(d, p) {
	return pad(d.getUTCHours() % 12 || 12, p, 2);
}
function formatUTCDayOfYear(d, p) {
	return pad(1 + utcDay.count(utcYear(d), d), p, 3);
}
function formatUTCMilliseconds(d, p) {
	return pad(d.getUTCMilliseconds(), p, 3);
}
function formatUTCMicroseconds(d, p) {
	return formatUTCMilliseconds(d, p) + "000";
}
function formatUTCMonthNumber(d, p) {
	return pad(d.getUTCMonth() + 1, p, 2);
}
function formatUTCMinutes(d, p) {
	return pad(d.getUTCMinutes(), p, 2);
}
function formatUTCSeconds(d, p) {
	return pad(d.getUTCSeconds(), p, 2);
}
function formatUTCWeekdayNumberMonday(d) {
	var dow = d.getUTCDay();
	return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d, p) {
	return pad(utcSunday.count(utcYear(d) - 1, d), p, 2);
}
function UTCdISO(d) {
	var day = d.getUTCDay();
	return day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
}
function formatUTCWeekNumberISO(d, p) {
	d = UTCdISO(d);
	return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
}
function formatUTCWeekdayNumberSunday(d) {
	return d.getUTCDay();
}
function formatUTCWeekNumberMonday(d, p) {
	return pad(utcMonday.count(utcYear(d) - 1, d), p, 2);
}
function formatUTCYear(d, p) {
	return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCYearISO(d, p) {
	d = UTCdISO(d);
	return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCFullYear(d, p) {
	return pad(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCFullYearISO(d, p) {
	var day = d.getUTCDay();
	d = day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
	return pad(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCZone() {
	return "+0000";
}
function formatLiteralPercent() {
	return "%";
}
function formatUnixTimestamp(d) {
	return +d;
}
function formatUnixTimestampSeconds(d) {
	return Math.floor(+d / 1e3);
}
var locale;
var timeFormat;
var utcFormat;
defaultLocale({
	dateTime: "%x, %X",
	date: "%-m/%-d/%Y",
	time: "%-I:%M:%S %p",
	periods: ["AM", "PM"],
	days: [
		"Sunday",
		"Monday",
		"Tuesday",
		"Wednesday",
		"Thursday",
		"Friday",
		"Saturday"
	],
	shortDays: [
		"Sun",
		"Mon",
		"Tue",
		"Wed",
		"Thu",
		"Fri",
		"Sat"
	],
	months: [
		"January",
		"February",
		"March",
		"April",
		"May",
		"June",
		"July",
		"August",
		"September",
		"October",
		"November",
		"December"
	],
	shortMonths: [
		"Jan",
		"Feb",
		"Mar",
		"Apr",
		"May",
		"Jun",
		"Jul",
		"Aug",
		"Sep",
		"Oct",
		"Nov",
		"Dec"
	]
});
function defaultLocale(definition) {
	locale = formatLocale(definition);
	timeFormat = locale.format;
	locale.parse;
	utcFormat = locale.utcFormat;
	locale.utcParse;
	return locale;
}
function date(t) {
	return new Date(t);
}
function number(t) {
	return t instanceof Date ? +t : +/* @__PURE__ */ new Date(+t);
}
function calendar(ticks$1, tickInterval, year, month, week, day, hour, minute, second$1, format$1) {
	var scale = continuous(), invert = scale.invert, domain = scale.domain;
	var formatMillisecond = format$1(".%L"), formatSecond = format$1(":%S"), formatMinute = format$1("%I:%M"), formatHour = format$1("%I %p"), formatDay = format$1("%a %d"), formatWeek = format$1("%b %d"), formatMonth = format$1("%B"), formatYear$1 = format$1("%Y");
	function tickFormat$1(date$1) {
		return (second$1(date$1) < date$1 ? formatMillisecond : minute(date$1) < date$1 ? formatSecond : hour(date$1) < date$1 ? formatMinute : day(date$1) < date$1 ? formatHour : month(date$1) < date$1 ? week(date$1) < date$1 ? formatDay : formatWeek : year(date$1) < date$1 ? formatMonth : formatYear$1)(date$1);
	}
	scale.invert = function(y$1) {
		return new Date(invert(y$1));
	};
	scale.domain = function(_) {
		return arguments.length ? domain(Array.from(_, number)) : domain().map(date);
	};
	scale.ticks = function(interval) {
		var d = domain();
		return ticks$1(d[0], d[d.length - 1], interval == null ? 10 : interval);
	};
	scale.tickFormat = function(count, specifier) {
		return specifier == null ? tickFormat$1 : format$1(specifier);
	};
	scale.nice = function(interval) {
		var d = domain();
		if (!interval || typeof interval.range !== "function") interval = tickInterval(d[0], d[d.length - 1], interval == null ? 10 : interval);
		return interval ? domain(nice(d, interval)) : scale;
	};
	scale.copy = function() {
		return copy$1(scale, calendar(ticks$1, tickInterval, year, month, week, day, hour, minute, second$1, format$1));
	};
	return scale;
}
function time() {
	return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function utcTime() {
	return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}
function transformer$1() {
	var x0 = 0, x1 = 1, t0$1, t1$1, k10, transform, interpolator = identity$4, clamp = false, unknown;
	function scale(x$1) {
		return x$1 == null || isNaN(x$1 = +x$1) ? unknown : interpolator(k10 === 0 ? .5 : (x$1 = (transform(x$1) - t0$1) * k10, clamp ? Math.max(0, Math.min(1, x$1)) : x$1));
	}
	scale.domain = function(_) {
		return arguments.length ? ([x0, x1] = _, t0$1 = transform(x0 = +x0), t1$1 = transform(x1 = +x1), k10 = t0$1 === t1$1 ? 0 : 1 / (t1$1 - t0$1), scale) : [x0, x1];
	};
	scale.clamp = function(_) {
		return arguments.length ? (clamp = !!_, scale) : clamp;
	};
	scale.interpolator = function(_) {
		return arguments.length ? (interpolator = _, scale) : interpolator;
	};
	function range$5(interpolate) {
		return function(_) {
			var r0, r1;
			return arguments.length ? ([r0, r1] = _, interpolator = interpolate(r0, r1), scale) : [interpolator(0), interpolator(1)];
		};
	}
	scale.range = range$5(value_default);
	scale.rangeRound = range$5(round_default);
	scale.unknown = function(_) {
		return arguments.length ? (unknown = _, scale) : unknown;
	};
	return function(t) {
		transform = t, t0$1 = t(x0), t1$1 = t(x1), k10 = t0$1 === t1$1 ? 0 : 1 / (t1$1 - t0$1);
		return scale;
	};
}
function copy(source, target) {
	return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
}
function sequential() {
	var scale = linearish(transformer$1()(identity$4));
	scale.copy = function() {
		return copy(scale, sequential());
	};
	return initInterpolator.apply(scale, arguments);
}
function sequentialLog() {
	var scale = loggish(transformer$1()).domain([1, 10]);
	scale.copy = function() {
		return copy(scale, sequentialLog()).base(scale.base());
	};
	return initInterpolator.apply(scale, arguments);
}
function sequentialSymlog() {
	var scale = symlogish(transformer$1());
	scale.copy = function() {
		return copy(scale, sequentialSymlog()).constant(scale.constant());
	};
	return initInterpolator.apply(scale, arguments);
}
function sequentialPow() {
	var scale = powish(transformer$1());
	scale.copy = function() {
		return copy(scale, sequentialPow()).exponent(scale.exponent());
	};
	return initInterpolator.apply(scale, arguments);
}
function sequentialSqrt() {
	return sequentialPow.apply(null, arguments).exponent(.5);
}
function sequentialQuantile() {
	var domain = [], interpolator = identity$4;
	function scale(x$1) {
		if (x$1 != null && !isNaN(x$1 = +x$1)) return interpolator((bisect_default(domain, x$1, 1) - 1) / (domain.length - 1));
	}
	scale.domain = function(_) {
		if (!arguments.length) return domain.slice();
		domain = [];
		for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
		domain.sort(ascending);
		return scale;
	};
	scale.interpolator = function(_) {
		return arguments.length ? (interpolator = _, scale) : interpolator;
	};
	scale.range = function() {
		return domain.map((d, i) => interpolator(i / (domain.length - 1)));
	};
	scale.quantiles = function(n) {
		return Array.from({ length: n + 1 }, (_, i) => quantile(domain, i / n));
	};
	scale.copy = function() {
		return sequentialQuantile(interpolator).domain(domain);
	};
	return initInterpolator.apply(scale, arguments);
}
function transformer() {
	var x0 = 0, x1 = .5, x2 = 1, s$1 = 1, t0$1, t1$1, t2, k10, k21, interpolator = identity$4, transform, clamp = false, unknown;
	function scale(x$1) {
		return isNaN(x$1 = +x$1) ? unknown : (x$1 = .5 + ((x$1 = +transform(x$1)) - t1$1) * (s$1 * x$1 < s$1 * t1$1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x$1)) : x$1));
	}
	scale.domain = function(_) {
		return arguments.length ? ([x0, x1, x2] = _, t0$1 = transform(x0 = +x0), t1$1 = transform(x1 = +x1), t2 = transform(x2 = +x2), k10 = t0$1 === t1$1 ? 0 : .5 / (t1$1 - t0$1), k21 = t1$1 === t2 ? 0 : .5 / (t2 - t1$1), s$1 = t1$1 < t0$1 ? -1 : 1, scale) : [
			x0,
			x1,
			x2
		];
	};
	scale.clamp = function(_) {
		return arguments.length ? (clamp = !!_, scale) : clamp;
	};
	scale.interpolator = function(_) {
		return arguments.length ? (interpolator = _, scale) : interpolator;
	};
	function range$5(interpolate) {
		return function(_) {
			var r0, r1, r2;
			return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise(interpolate, [
				r0,
				r1,
				r2
			]), scale) : [
				interpolator(0),
				interpolator(.5),
				interpolator(1)
			];
		};
	}
	scale.range = range$5(value_default);
	scale.rangeRound = range$5(round_default);
	scale.unknown = function(_) {
		return arguments.length ? (unknown = _, scale) : unknown;
	};
	return function(t) {
		transform = t, t0$1 = t(x0), t1$1 = t(x1), t2 = t(x2), k10 = t0$1 === t1$1 ? 0 : .5 / (t1$1 - t0$1), k21 = t1$1 === t2 ? 0 : .5 / (t2 - t1$1), s$1 = t1$1 < t0$1 ? -1 : 1;
		return scale;
	};
}
function diverging() {
	var scale = linearish(transformer()(identity$4));
	scale.copy = function() {
		return copy(scale, diverging());
	};
	return initInterpolator.apply(scale, arguments);
}
function divergingLog() {
	var scale = loggish(transformer()).domain([
		.1,
		1,
		10
	]);
	scale.copy = function() {
		return copy(scale, divergingLog()).base(scale.base());
	};
	return initInterpolator.apply(scale, arguments);
}
function divergingSymlog() {
	var scale = symlogish(transformer());
	scale.copy = function() {
		return copy(scale, divergingSymlog()).constant(scale.constant());
	};
	return initInterpolator.apply(scale, arguments);
}
function divergingPow() {
	var scale = powish(transformer());
	scale.copy = function() {
		return copy(scale, divergingPow()).exponent(scale.exponent());
	};
	return initInterpolator.apply(scale, arguments);
}
function divergingSqrt() {
	return divergingPow.apply(null, arguments).exponent(.5);
}
var d3_scale_exports = /* @__PURE__ */ __export({
	scaleBand: () => band,
	scaleDiverging: () => diverging,
	scaleDivergingLog: () => divergingLog,
	scaleDivergingPow: () => divergingPow,
	scaleDivergingSqrt: () => divergingSqrt,
	scaleDivergingSymlog: () => divergingSymlog,
	scaleIdentity: () => identity$5,
	scaleImplicit: () => implicit,
	scaleLinear: () => linear,
	scaleLog: () => log,
	scaleOrdinal: () => ordinal,
	scalePoint: () => point,
	scalePow: () => pow,
	scaleQuantile: () => quantile$1,
	scaleQuantize: () => quantize,
	scaleRadial: () => radial,
	scaleSequential: () => sequential,
	scaleSequentialLog: () => sequentialLog,
	scaleSequentialPow: () => sequentialPow,
	scaleSequentialQuantile: () => sequentialQuantile,
	scaleSequentialSqrt: () => sequentialSqrt,
	scaleSequentialSymlog: () => sequentialSymlog,
	scaleSqrt: () => sqrt,
	scaleSymlog: () => symlog,
	scaleThreshold: () => threshold,
	scaleTime: () => time,
	scaleUtc: () => utcTime,
	tickFormat: () => tickFormat
}, 1);
var require__baseExtremum = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var isSymbol = require_isSymbol();
	function baseExtremum$2(array, iteratee, comparator) {
		var index = -1, length = array.length;
		while (++index < length) {
			var value = array[index], current = iteratee(value);
			if (current != null && (computed === void 0 ? current === current && !isSymbol(current) : comparator(current, computed))) var computed = current, result = value;
		}
		return result;
	}
	module.exports = baseExtremum$2;
}));
var require__baseGt = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function baseGt$1(value, other) {
		return value > other;
	}
	module.exports = baseGt$1;
}));
var require_max = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseExtremum$1 = require__baseExtremum(), baseGt = require__baseGt(), identity$3 = require_identity();
	function max$1(array) {
		return array && array.length ? baseExtremum$1(array, identity$3, baseGt) : void 0;
	}
	module.exports = max$1;
}));
var require__baseLt = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function baseLt$1(value, other) {
		return value < other;
	}
	module.exports = baseLt$1;
}));
var require_min = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseExtremum = require__baseExtremum(), baseLt = require__baseLt(), identity$2 = require_identity();
	function min$1(array) {
		return array && array.length ? baseExtremum(array, identity$2, baseLt) : void 0;
	}
	module.exports = min$1;
}));
var require_map = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var arrayMap = require__arrayMap(), baseIteratee$5 = require__baseIteratee(), baseMap = require__baseMap(), isArray$2 = require_isArray();
	function map$2(collection, iteratee) {
		return (isArray$2(collection) ? arrayMap : baseMap)(collection, baseIteratee$5(iteratee, 3));
	}
	module.exports = map$2;
}));
var require_flatMap = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseFlatten = require__baseFlatten(), map$1 = require_map();
	function flatMap$1(collection, iteratee) {
		return baseFlatten(map$1(collection, iteratee), 1);
	}
	module.exports = flatMap$1;
}));
var require_isEqual = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseIsEqual = require__baseIsEqual();
	function isEqual$3(value, other) {
		return baseIsEqual(value, other);
	}
	module.exports = isEqual$3;
}));
var require_decimal = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(function(globalScope) {
		"use strict";
		var MAX_DIGITS = 1e9, Decimal$2 = {
			precision: 20,
			rounding: 4,
			toExpNeg: -7,
			toExpPos: 21,
			LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286"
		}, external = true, decimalError = "[DecimalError] ", invalidArgument = decimalError + "Invalid argument: ", exponentOutOfRange = decimalError + "Exponent out of range: ", mathfloor = Math.floor, mathpow = Math.pow, isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, ONE, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER$2 = 9007199254740991, MAX_E = mathfloor(MAX_SAFE_INTEGER$2 / LOG_BASE), P = {};
		P.absoluteValue = P.abs = function() {
			var x$1 = new this.constructor(this);
			if (x$1.s) x$1.s = 1;
			return x$1;
		};
		P.comparedTo = P.cmp = function(y$1) {
			var i, j, xdL, ydL, x$1 = this;
			y$1 = new x$1.constructor(y$1);
			if (x$1.s !== y$1.s) return x$1.s || -y$1.s;
			if (x$1.e !== y$1.e) return x$1.e > y$1.e ^ x$1.s < 0 ? 1 : -1;
			xdL = x$1.d.length;
			ydL = y$1.d.length;
			for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) if (x$1.d[i] !== y$1.d[i]) return x$1.d[i] > y$1.d[i] ^ x$1.s < 0 ? 1 : -1;
			return xdL === ydL ? 0 : xdL > ydL ^ x$1.s < 0 ? 1 : -1;
		};
		P.decimalPlaces = P.dp = function() {
			var x$1 = this, w = x$1.d.length - 1, dp = (w - x$1.e) * LOG_BASE;
			w = x$1.d[w];
			if (w) for (; w % 10 == 0; w /= 10) dp--;
			return dp < 0 ? 0 : dp;
		};
		P.dividedBy = P.div = function(y$1) {
			return divide(this, new this.constructor(y$1));
		};
		P.dividedToIntegerBy = P.idiv = function(y$1) {
			var x$1 = this, Ctor = x$1.constructor;
			return round(divide(x$1, new Ctor(y$1), 0, 1), Ctor.precision);
		};
		P.equals = P.eq = function(y$1) {
			return !this.cmp(y$1);
		};
		P.exponent = function() {
			return getBase10Exponent(this);
		};
		P.greaterThan = P.gt = function(y$1) {
			return this.cmp(y$1) > 0;
		};
		P.greaterThanOrEqualTo = P.gte = function(y$1) {
			return this.cmp(y$1) >= 0;
		};
		P.isInteger = P.isint = function() {
			return this.e > this.d.length - 2;
		};
		P.isNegative = P.isneg = function() {
			return this.s < 0;
		};
		P.isPositive = P.ispos = function() {
			return this.s > 0;
		};
		P.isZero = function() {
			return this.s === 0;
		};
		P.lessThan = P.lt = function(y$1) {
			return this.cmp(y$1) < 0;
		};
		P.lessThanOrEqualTo = P.lte = function(y$1) {
			return this.cmp(y$1) < 1;
		};
		P.logarithm = P.log = function(base) {
			var r, x$1 = this, Ctor = x$1.constructor, pr = Ctor.precision, wpr = pr + 5;
			if (base === void 0) base = new Ctor(10);
			else {
				base = new Ctor(base);
				if (base.s < 1 || base.eq(ONE)) throw Error(decimalError + "NaN");
			}
			if (x$1.s < 1) throw Error(decimalError + (x$1.s ? "NaN" : "-Infinity"));
			if (x$1.eq(ONE)) return new Ctor(0);
			external = false;
			r = divide(ln(x$1, wpr), ln(base, wpr), wpr);
			external = true;
			return round(r, pr);
		};
		P.minus = P.sub = function(y$1) {
			var x$1 = this;
			y$1 = new x$1.constructor(y$1);
			return x$1.s == y$1.s ? subtract(x$1, y$1) : add(x$1, (y$1.s = -y$1.s, y$1));
		};
		P.modulo = P.mod = function(y$1) {
			var q, x$1 = this, Ctor = x$1.constructor, pr = Ctor.precision;
			y$1 = new Ctor(y$1);
			if (!y$1.s) throw Error(decimalError + "NaN");
			if (!x$1.s) return round(new Ctor(x$1), pr);
			external = false;
			q = divide(x$1, y$1, 0, 1).times(y$1);
			external = true;
			return x$1.minus(q);
		};
		P.naturalExponential = P.exp = function() {
			return exp(this);
		};
		P.naturalLogarithm = P.ln = function() {
			return ln(this);
		};
		P.negated = P.neg = function() {
			var x$1 = new this.constructor(this);
			x$1.s = -x$1.s || 0;
			return x$1;
		};
		P.plus = P.add = function(y$1) {
			var x$1 = this;
			y$1 = new x$1.constructor(y$1);
			return x$1.s == y$1.s ? add(x$1, y$1) : subtract(x$1, (y$1.s = -y$1.s, y$1));
		};
		P.precision = P.sd = function(z) {
			var e, sd, w, x$1 = this;
			if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);
			e = getBase10Exponent(x$1) + 1;
			w = x$1.d.length - 1;
			sd = w * LOG_BASE + 1;
			w = x$1.d[w];
			if (w) {
				for (; w % 10 == 0; w /= 10) sd--;
				for (w = x$1.d[0]; w >= 10; w /= 10) sd++;
			}
			return z && e > sd ? e : sd;
		};
		P.squareRoot = P.sqrt = function() {
			var e, n, pr, r, s$1, t, wpr, x$1 = this, Ctor = x$1.constructor;
			if (x$1.s < 1) {
				if (!x$1.s) return new Ctor(0);
				throw Error(decimalError + "NaN");
			}
			e = getBase10Exponent(x$1);
			external = false;
			s$1 = Math.sqrt(+x$1);
			if (s$1 == 0 || s$1 == Infinity) {
				n = digitsToString(x$1.d);
				if ((n.length + e) % 2 == 0) n += "0";
				s$1 = Math.sqrt(n);
				e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
				if (s$1 == Infinity) n = "5e" + e;
				else {
					n = s$1.toExponential();
					n = n.slice(0, n.indexOf("e") + 1) + e;
				}
				r = new Ctor(n);
			} else r = new Ctor(s$1.toString());
			pr = Ctor.precision;
			s$1 = wpr = pr + 3;
			for (;;) {
				t = r;
				r = t.plus(divide(x$1, t, wpr + 2)).times(.5);
				if (digitsToString(t.d).slice(0, wpr) === (n = digitsToString(r.d)).slice(0, wpr)) {
					n = n.slice(wpr - 3, wpr + 1);
					if (s$1 == wpr && n == "4999") {
						round(t, pr + 1, 0);
						if (t.times(t).eq(x$1)) {
							r = t;
							break;
						}
					} else if (n != "9999") break;
					wpr += 4;
				}
			}
			external = true;
			return round(r, pr);
		};
		P.times = P.mul = function(y$1) {
			var carry, e, i, k$1, r, rL, t, xdL, ydL, x$1 = this, Ctor = x$1.constructor, xd = x$1.d, yd = (y$1 = new Ctor(y$1)).d;
			if (!x$1.s || !y$1.s) return new Ctor(0);
			y$1.s *= x$1.s;
			e = x$1.e + y$1.e;
			xdL = xd.length;
			ydL = yd.length;
			if (xdL < ydL) {
				r = xd;
				xd = yd;
				yd = r;
				rL = xdL;
				xdL = ydL;
				ydL = rL;
			}
			r = [];
			rL = xdL + ydL;
			for (i = rL; i--;) r.push(0);
			for (i = ydL; --i >= 0;) {
				carry = 0;
				for (k$1 = xdL + i; k$1 > i;) {
					t = r[k$1] + yd[i] * xd[k$1 - i - 1] + carry;
					r[k$1--] = t % BASE | 0;
					carry = t / BASE | 0;
				}
				r[k$1] = (r[k$1] + carry) % BASE | 0;
			}
			for (; !r[--rL];) r.pop();
			if (carry) ++e;
			else r.shift();
			y$1.d = r;
			y$1.e = e;
			return external ? round(y$1, Ctor.precision) : y$1;
		};
		P.toDecimalPlaces = P.todp = function(dp, rm) {
			var x$1 = this, Ctor = x$1.constructor;
			x$1 = new Ctor(x$1);
			if (dp === void 0) return x$1;
			checkInt32(dp, 0, MAX_DIGITS);
			if (rm === void 0) rm = Ctor.rounding;
			else checkInt32(rm, 0, 8);
			return round(x$1, dp + getBase10Exponent(x$1) + 1, rm);
		};
		P.toExponential = function(dp, rm) {
			var str, x$1 = this, Ctor = x$1.constructor;
			if (dp === void 0) str = toString$4(x$1, true);
			else {
				checkInt32(dp, 0, MAX_DIGITS);
				if (rm === void 0) rm = Ctor.rounding;
				else checkInt32(rm, 0, 8);
				x$1 = round(new Ctor(x$1), dp + 1, rm);
				str = toString$4(x$1, true, dp + 1);
			}
			return str;
		};
		P.toFixed = function(dp, rm) {
			var str, y$1, x$1 = this, Ctor = x$1.constructor;
			if (dp === void 0) return toString$4(x$1);
			checkInt32(dp, 0, MAX_DIGITS);
			if (rm === void 0) rm = Ctor.rounding;
			else checkInt32(rm, 0, 8);
			y$1 = round(new Ctor(x$1), dp + getBase10Exponent(x$1) + 1, rm);
			str = toString$4(y$1.abs(), false, dp + getBase10Exponent(y$1) + 1);
			return x$1.isneg() && !x$1.isZero() ? "-" + str : str;
		};
		P.toInteger = P.toint = function() {
			var x$1 = this, Ctor = x$1.constructor;
			return round(new Ctor(x$1), getBase10Exponent(x$1) + 1, Ctor.rounding);
		};
		P.toNumber = function() {
			return +this;
		};
		P.toPower = P.pow = function(y$1) {
			var e, k$1, pr, r, sign$1, yIsInt, x$1 = this, Ctor = x$1.constructor, guard = 12, yn = +(y$1 = new Ctor(y$1));
			if (!y$1.s) return new Ctor(ONE);
			x$1 = new Ctor(x$1);
			if (!x$1.s) {
				if (y$1.s < 1) throw Error(decimalError + "Infinity");
				return x$1;
			}
			if (x$1.eq(ONE)) return x$1;
			pr = Ctor.precision;
			if (y$1.eq(ONE)) return round(x$1, pr);
			e = y$1.e;
			k$1 = y$1.d.length - 1;
			yIsInt = e >= k$1;
			sign$1 = x$1.s;
			if (!yIsInt) {
				if (sign$1 < 0) throw Error(decimalError + "NaN");
			} else if ((k$1 = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER$2) {
				r = new Ctor(ONE);
				e = Math.ceil(pr / LOG_BASE + 4);
				external = false;
				for (;;) {
					if (k$1 % 2) {
						r = r.times(x$1);
						truncate(r.d, e);
					}
					k$1 = mathfloor(k$1 / 2);
					if (k$1 === 0) break;
					x$1 = x$1.times(x$1);
					truncate(x$1.d, e);
				}
				external = true;
				return y$1.s < 0 ? new Ctor(ONE).div(r) : round(r, pr);
			}
			sign$1 = sign$1 < 0 && y$1.d[Math.max(e, k$1)] & 1 ? -1 : 1;
			x$1.s = 1;
			external = false;
			r = y$1.times(ln(x$1, pr + guard));
			external = true;
			r = exp(r);
			r.s = sign$1;
			return r;
		};
		P.toPrecision = function(sd, rm) {
			var e, str, x$1 = this, Ctor = x$1.constructor;
			if (sd === void 0) {
				e = getBase10Exponent(x$1);
				str = toString$4(x$1, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
			} else {
				checkInt32(sd, 1, MAX_DIGITS);
				if (rm === void 0) rm = Ctor.rounding;
				else checkInt32(rm, 0, 8);
				x$1 = round(new Ctor(x$1), sd, rm);
				e = getBase10Exponent(x$1);
				str = toString$4(x$1, sd <= e || e <= Ctor.toExpNeg, sd);
			}
			return str;
		};
		P.toSignificantDigits = P.tosd = function(sd, rm) {
			var x$1 = this, Ctor = x$1.constructor;
			if (sd === void 0) {
				sd = Ctor.precision;
				rm = Ctor.rounding;
			} else {
				checkInt32(sd, 1, MAX_DIGITS);
				if (rm === void 0) rm = Ctor.rounding;
				else checkInt32(rm, 0, 8);
			}
			return round(new Ctor(x$1), sd, rm);
		};
		P.toString = P.valueOf = P.val = P.toJSON = function() {
			var x$1 = this, e = getBase10Exponent(x$1), Ctor = x$1.constructor;
			return toString$4(x$1, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
		};
		function add(x$1, y$1) {
			var carry, d, e, i, k$1, len, xd, yd, Ctor = x$1.constructor, pr = Ctor.precision;
			if (!x$1.s || !y$1.s) {
				if (!y$1.s) y$1 = new Ctor(x$1);
				return external ? round(y$1, pr) : y$1;
			}
			xd = x$1.d;
			yd = y$1.d;
			k$1 = x$1.e;
			e = y$1.e;
			xd = xd.slice();
			i = k$1 - e;
			if (i) {
				if (i < 0) {
					d = xd;
					i = -i;
					len = yd.length;
				} else {
					d = yd;
					e = k$1;
					len = xd.length;
				}
				k$1 = Math.ceil(pr / LOG_BASE);
				len = k$1 > len ? k$1 + 1 : len + 1;
				if (i > len) {
					i = len;
					d.length = 1;
				}
				d.reverse();
				for (; i--;) d.push(0);
				d.reverse();
			}
			len = xd.length;
			i = yd.length;
			if (len - i < 0) {
				i = len;
				d = yd;
				yd = xd;
				xd = d;
			}
			for (carry = 0; i;) {
				carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
				xd[i] %= BASE;
			}
			if (carry) {
				xd.unshift(carry);
				++e;
			}
			for (len = xd.length; xd[--len] == 0;) xd.pop();
			y$1.d = xd;
			y$1.e = e;
			return external ? round(y$1, pr) : y$1;
		}
		function checkInt32(i, min$3, max$3) {
			if (i !== ~~i || i < min$3 || i > max$3) throw Error(invalidArgument + i);
		}
		function digitsToString(d) {
			var i, k$1, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
			if (indexOfLastWord > 0) {
				str += w;
				for (i = 1; i < indexOfLastWord; i++) {
					ws = d[i] + "";
					k$1 = LOG_BASE - ws.length;
					if (k$1) str += getZeroString(k$1);
					str += ws;
				}
				w = d[i];
				ws = w + "";
				k$1 = LOG_BASE - ws.length;
				if (k$1) str += getZeroString(k$1);
			} else if (w === 0) return "0";
			for (; w % 10 === 0;) w /= 10;
			return str + w;
		}
		var divide = (function() {
			function multiplyInteger(x$1, k$1) {
				var temp, carry = 0, i = x$1.length;
				for (x$1 = x$1.slice(); i--;) {
					temp = x$1[i] * k$1 + carry;
					x$1[i] = temp % BASE | 0;
					carry = temp / BASE | 0;
				}
				if (carry) x$1.unshift(carry);
				return x$1;
			}
			function compare(a$1, b, aL, bL) {
				var i, r;
				if (aL != bL) r = aL > bL ? 1 : -1;
				else for (i = r = 0; i < aL; i++) if (a$1[i] != b[i]) {
					r = a$1[i] > b[i] ? 1 : -1;
					break;
				}
				return r;
			}
			function subtract$1(a$1, b, aL) {
				var i = 0;
				for (; aL--;) {
					a$1[aL] -= i;
					i = a$1[aL] < b[aL] ? 1 : 0;
					a$1[aL] = i * BASE + a$1[aL] - b[aL];
				}
				for (; !a$1[0] && a$1.length > 1;) a$1.shift();
			}
			return function(x$1, y$1, pr, dp) {
				var cmp, e, i, k$1, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x$1.constructor, sign$1 = x$1.s == y$1.s ? 1 : -1, xd = x$1.d, yd = y$1.d;
				if (!x$1.s) return new Ctor(x$1);
				if (!y$1.s) throw Error(decimalError + "Division by zero");
				e = x$1.e - y$1.e;
				yL = yd.length;
				xL = xd.length;
				q = new Ctor(sign$1);
				qd = q.d = [];
				for (i = 0; yd[i] == (xd[i] || 0);) ++i;
				if (yd[i] > (xd[i] || 0)) --e;
				if (pr == null) sd = pr = Ctor.precision;
				else if (dp) sd = pr + (getBase10Exponent(x$1) - getBase10Exponent(y$1)) + 1;
				else sd = pr;
				if (sd < 0) return new Ctor(0);
				sd = sd / LOG_BASE + 2 | 0;
				i = 0;
				if (yL == 1) {
					k$1 = 0;
					yd = yd[0];
					sd++;
					for (; (i < xL || k$1) && sd--; i++) {
						t = k$1 * BASE + (xd[i] || 0);
						qd[i] = t / yd | 0;
						k$1 = t % yd | 0;
					}
				} else {
					k$1 = BASE / (yd[0] + 1) | 0;
					if (k$1 > 1) {
						yd = multiplyInteger(yd, k$1);
						xd = multiplyInteger(xd, k$1);
						yL = yd.length;
						xL = xd.length;
					}
					xi = yL;
					rem = xd.slice(0, yL);
					remL = rem.length;
					for (; remL < yL;) rem[remL++] = 0;
					yz = yd.slice();
					yz.unshift(0);
					yd0 = yd[0];
					if (yd[1] >= BASE / 2) ++yd0;
					do {
						k$1 = 0;
						cmp = compare(yd, rem, yL, remL);
						if (cmp < 0) {
							rem0 = rem[0];
							if (yL != remL) rem0 = rem0 * BASE + (rem[1] || 0);
							k$1 = rem0 / yd0 | 0;
							if (k$1 > 1) {
								if (k$1 >= BASE) k$1 = BASE - 1;
								prod = multiplyInteger(yd, k$1);
								prodL = prod.length;
								remL = rem.length;
								cmp = compare(prod, rem, prodL, remL);
								if (cmp == 1) {
									k$1--;
									subtract$1(prod, yL < prodL ? yz : yd, prodL);
								}
							} else {
								if (k$1 == 0) cmp = k$1 = 1;
								prod = yd.slice();
							}
							prodL = prod.length;
							if (prodL < remL) prod.unshift(0);
							subtract$1(rem, prod, remL);
							if (cmp == -1) {
								remL = rem.length;
								cmp = compare(yd, rem, yL, remL);
								if (cmp < 1) {
									k$1++;
									subtract$1(rem, yL < remL ? yz : yd, remL);
								}
							}
							remL = rem.length;
						} else if (cmp === 0) {
							k$1++;
							rem = [0];
						}
						qd[i++] = k$1;
						if (cmp && rem[0]) rem[remL++] = xd[xi] || 0;
						else {
							rem = [xd[xi]];
							remL = 1;
						}
					} while ((xi++ < xL || rem[0] !== void 0) && sd--);
				}
				if (!qd[0]) qd.shift();
				q.e = e;
				return round(q, dp ? pr + getBase10Exponent(q) + 1 : pr);
			};
		})();
		function exp(x$1, sd) {
			var denominator, guard, pow$1, sum, t, wpr, i = 0, k$1 = 0, Ctor = x$1.constructor, pr = Ctor.precision;
			if (getBase10Exponent(x$1) > 16) throw Error(exponentOutOfRange + getBase10Exponent(x$1));
			if (!x$1.s) return new Ctor(ONE);
			if (sd == null) {
				external = false;
				wpr = pr;
			} else wpr = sd;
			t = new Ctor(.03125);
			while (x$1.abs().gte(.1)) {
				x$1 = x$1.times(t);
				k$1 += 5;
			}
			guard = Math.log(mathpow(2, k$1)) / Math.LN10 * 2 + 5 | 0;
			wpr += guard;
			denominator = pow$1 = sum = new Ctor(ONE);
			Ctor.precision = wpr;
			for (;;) {
				pow$1 = round(pow$1.times(x$1), wpr);
				denominator = denominator.times(++i);
				t = sum.plus(divide(pow$1, denominator, wpr));
				if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
					while (k$1--) sum = round(sum.times(sum), wpr);
					Ctor.precision = pr;
					return sd == null ? (external = true, round(sum, pr)) : sum;
				}
				sum = t;
			}
		}
		function getBase10Exponent(x$1) {
			var e = x$1.e * LOG_BASE, w = x$1.d[0];
			for (; w >= 10; w /= 10) e++;
			return e;
		}
		function getLn10(Ctor, sd, pr) {
			if (sd > Ctor.LN10.sd()) {
				external = true;
				if (pr) Ctor.precision = pr;
				throw Error(decimalError + "LN10 precision limit exceeded");
			}
			return round(new Ctor(Ctor.LN10), sd);
		}
		function getZeroString(k$1) {
			var zs = "";
			for (; k$1--;) zs += "0";
			return zs;
		}
		function ln(y$1, sd) {
			var c$1, c0, denominator, e, numerator, sum, t, wpr, x2, n = 1, guard = 10, x$1 = y$1, xd = x$1.d, Ctor = x$1.constructor, pr = Ctor.precision;
			if (x$1.s < 1) throw Error(decimalError + (x$1.s ? "NaN" : "-Infinity"));
			if (x$1.eq(ONE)) return new Ctor(0);
			if (sd == null) {
				external = false;
				wpr = pr;
			} else wpr = sd;
			if (x$1.eq(10)) {
				if (sd == null) external = true;
				return getLn10(Ctor, wpr);
			}
			wpr += guard;
			Ctor.precision = wpr;
			c$1 = digitsToString(xd);
			c0 = c$1.charAt(0);
			e = getBase10Exponent(x$1);
			if (Math.abs(e) < 0x5543df729c000) {
				while (c0 < 7 && c0 != 1 || c0 == 1 && c$1.charAt(1) > 3) {
					x$1 = x$1.times(y$1);
					c$1 = digitsToString(x$1.d);
					c0 = c$1.charAt(0);
					n++;
				}
				e = getBase10Exponent(x$1);
				if (c0 > 1) {
					x$1 = new Ctor("0." + c$1);
					e++;
				} else x$1 = new Ctor(c0 + "." + c$1.slice(1));
			} else {
				t = getLn10(Ctor, wpr + 2, pr).times(e + "");
				x$1 = ln(new Ctor(c0 + "." + c$1.slice(1)), wpr - guard).plus(t);
				Ctor.precision = pr;
				return sd == null ? (external = true, round(x$1, pr)) : x$1;
			}
			sum = numerator = x$1 = divide(x$1.minus(ONE), x$1.plus(ONE), wpr);
			x2 = round(x$1.times(x$1), wpr);
			denominator = 3;
			for (;;) {
				numerator = round(numerator.times(x2), wpr);
				t = sum.plus(divide(numerator, new Ctor(denominator), wpr));
				if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
					sum = sum.times(2);
					if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
					sum = divide(sum, new Ctor(n), wpr);
					Ctor.precision = pr;
					return sd == null ? (external = true, round(sum, pr)) : sum;
				}
				sum = t;
				denominator += 2;
			}
		}
		function parseDecimal(x$1, str) {
			var e, i, len;
			if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
			if ((i = str.search(/e/i)) > 0) {
				if (e < 0) e = i;
				e += +str.slice(i + 1);
				str = str.substring(0, i);
			} else if (e < 0) e = str.length;
			for (i = 0; str.charCodeAt(i) === 48;) ++i;
			for (len = str.length; str.charCodeAt(len - 1) === 48;) --len;
			str = str.slice(i, len);
			if (str) {
				len -= i;
				e = e - i - 1;
				x$1.e = mathfloor(e / LOG_BASE);
				x$1.d = [];
				i = (e + 1) % LOG_BASE;
				if (e < 0) i += LOG_BASE;
				if (i < len) {
					if (i) x$1.d.push(+str.slice(0, i));
					for (len -= LOG_BASE; i < len;) x$1.d.push(+str.slice(i, i += LOG_BASE));
					str = str.slice(i);
					i = LOG_BASE - str.length;
				} else i -= len;
				for (; i--;) str += "0";
				x$1.d.push(+str);
				if (external && (x$1.e > MAX_E || x$1.e < -MAX_E)) throw Error(exponentOutOfRange + e);
			} else {
				x$1.s = 0;
				x$1.e = 0;
				x$1.d = [0];
			}
			return x$1;
		}
		function round(x$1, sd, rm) {
			var i, j, k$1, n, rd, doRound, w, xdi, xd = x$1.d;
			for (n = 1, k$1 = xd[0]; k$1 >= 10; k$1 /= 10) n++;
			i = sd - n;
			if (i < 0) {
				i += LOG_BASE;
				j = sd;
				w = xd[xdi = 0];
			} else {
				xdi = Math.ceil((i + 1) / LOG_BASE);
				k$1 = xd.length;
				if (xdi >= k$1) return x$1;
				w = k$1 = xd[xdi];
				for (n = 1; k$1 >= 10; k$1 /= 10) n++;
				i %= LOG_BASE;
				j = i - LOG_BASE + n;
			}
			if (rm !== void 0) {
				k$1 = mathpow(10, n - j - 1);
				rd = w / k$1 % 10 | 0;
				doRound = sd < 0 || xd[xdi + 1] !== void 0 || w % k$1;
				doRound = rm < 4 ? (rd || doRound) && (rm == 0 || rm == (x$1.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || doRound || rm == 6 && (i > 0 ? j > 0 ? w / mathpow(10, n - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x$1.s < 0 ? 8 : 7));
			}
			if (sd < 1 || !xd[0]) {
				if (doRound) {
					k$1 = getBase10Exponent(x$1);
					xd.length = 1;
					sd = sd - k$1 - 1;
					xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
					x$1.e = mathfloor(-sd / LOG_BASE) || 0;
				} else {
					xd.length = 1;
					xd[0] = x$1.e = x$1.s = 0;
				}
				return x$1;
			}
			if (i == 0) {
				xd.length = xdi;
				k$1 = 1;
				xdi--;
			} else {
				xd.length = xdi + 1;
				k$1 = mathpow(10, LOG_BASE - i);
				xd[xdi] = j > 0 ? (w / mathpow(10, n - j) % mathpow(10, j) | 0) * k$1 : 0;
			}
			if (doRound) for (;;) if (xdi == 0) {
				if ((xd[0] += k$1) == BASE) {
					xd[0] = 1;
					++x$1.e;
				}
				break;
			} else {
				xd[xdi] += k$1;
				if (xd[xdi] != BASE) break;
				xd[xdi--] = 0;
				k$1 = 1;
			}
			for (i = xd.length; xd[--i] === 0;) xd.pop();
			if (external && (x$1.e > MAX_E || x$1.e < -MAX_E)) throw Error(exponentOutOfRange + getBase10Exponent(x$1));
			return x$1;
		}
		function subtract(x$1, y$1) {
			var d, e, i, j, k$1, len, xd, xe, xLTy, yd, Ctor = x$1.constructor, pr = Ctor.precision;
			if (!x$1.s || !y$1.s) {
				if (y$1.s) y$1.s = -y$1.s;
				else y$1 = new Ctor(x$1);
				return external ? round(y$1, pr) : y$1;
			}
			xd = x$1.d;
			yd = y$1.d;
			e = y$1.e;
			xe = x$1.e;
			xd = xd.slice();
			k$1 = xe - e;
			if (k$1) {
				xLTy = k$1 < 0;
				if (xLTy) {
					d = xd;
					k$1 = -k$1;
					len = yd.length;
				} else {
					d = yd;
					e = xe;
					len = xd.length;
				}
				i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
				if (k$1 > i) {
					k$1 = i;
					d.length = 1;
				}
				d.reverse();
				for (i = k$1; i--;) d.push(0);
				d.reverse();
			} else {
				i = xd.length;
				len = yd.length;
				xLTy = i < len;
				if (xLTy) len = i;
				for (i = 0; i < len; i++) if (xd[i] != yd[i]) {
					xLTy = xd[i] < yd[i];
					break;
				}
				k$1 = 0;
			}
			if (xLTy) {
				d = xd;
				xd = yd;
				yd = d;
				y$1.s = -y$1.s;
			}
			len = xd.length;
			for (i = yd.length - len; i > 0; --i) xd[len++] = 0;
			for (i = yd.length; i > k$1;) {
				if (xd[--i] < yd[i]) {
					for (j = i; j && xd[--j] === 0;) xd[j] = BASE - 1;
					--xd[j];
					xd[i] += BASE;
				}
				xd[i] -= yd[i];
			}
			for (; xd[--len] === 0;) xd.pop();
			for (; xd[0] === 0; xd.shift()) --e;
			if (!xd[0]) return new Ctor(0);
			y$1.d = xd;
			y$1.e = e;
			return external ? round(y$1, pr) : y$1;
		}
		function toString$4(x$1, isExp, sd) {
			var k$1, e = getBase10Exponent(x$1), str = digitsToString(x$1.d), len = str.length;
			if (isExp) {
				if (sd && (k$1 = sd - len) > 0) str = str.charAt(0) + "." + str.slice(1) + getZeroString(k$1);
				else if (len > 1) str = str.charAt(0) + "." + str.slice(1);
				str = str + (e < 0 ? "e" : "e+") + e;
			} else if (e < 0) {
				str = "0." + getZeroString(-e - 1) + str;
				if (sd && (k$1 = sd - len) > 0) str += getZeroString(k$1);
			} else if (e >= len) {
				str += getZeroString(e + 1 - len);
				if (sd && (k$1 = sd - e - 1) > 0) str = str + "." + getZeroString(k$1);
			} else {
				if ((k$1 = e + 1) < len) str = str.slice(0, k$1) + "." + str.slice(k$1);
				if (sd && (k$1 = sd - len) > 0) {
					if (e + 1 === len) str += ".";
					str += getZeroString(k$1);
				}
			}
			return x$1.s < 0 ? "-" + str : str;
		}
		function truncate(arr, len) {
			if (arr.length > len) {
				arr.length = len;
				return true;
			}
		}
		function clone(obj) {
			var i, p, ps;
			function Decimal$3(value) {
				var x$1 = this;
				if (!(x$1 instanceof Decimal$3)) return new Decimal$3(value);
				x$1.constructor = Decimal$3;
				if (value instanceof Decimal$3) {
					x$1.s = value.s;
					x$1.e = value.e;
					x$1.d = (value = value.d) ? value.slice() : value;
					return;
				}
				if (typeof value === "number") {
					if (value * 0 !== 0) throw Error(invalidArgument + value);
					if (value > 0) x$1.s = 1;
					else if (value < 0) {
						value = -value;
						x$1.s = -1;
					} else {
						x$1.s = 0;
						x$1.e = 0;
						x$1.d = [0];
						return;
					}
					if (value === ~~value && value < 1e7) {
						x$1.e = 0;
						x$1.d = [value];
						return;
					}
					return parseDecimal(x$1, value.toString());
				} else if (typeof value !== "string") throw Error(invalidArgument + value);
				if (value.charCodeAt(0) === 45) {
					value = value.slice(1);
					x$1.s = -1;
				} else x$1.s = 1;
				if (isDecimal.test(value)) parseDecimal(x$1, value);
				else throw Error(invalidArgument + value);
			}
			Decimal$3.prototype = P;
			Decimal$3.ROUND_UP = 0;
			Decimal$3.ROUND_DOWN = 1;
			Decimal$3.ROUND_CEIL = 2;
			Decimal$3.ROUND_FLOOR = 3;
			Decimal$3.ROUND_HALF_UP = 4;
			Decimal$3.ROUND_HALF_DOWN = 5;
			Decimal$3.ROUND_HALF_EVEN = 6;
			Decimal$3.ROUND_HALF_CEIL = 7;
			Decimal$3.ROUND_HALF_FLOOR = 8;
			Decimal$3.clone = clone;
			Decimal$3.config = Decimal$3.set = config;
			if (obj === void 0) obj = {};
			if (obj) {
				ps = [
					"precision",
					"rounding",
					"toExpNeg",
					"toExpPos",
					"LN10"
				];
				for (i = 0; i < ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
			}
			Decimal$3.config(obj);
			return Decimal$3;
		}
		function config(obj) {
			if (!obj || typeof obj !== "object") throw Error(decimalError + "Object expected");
			var i, p, v, ps = [
				"precision",
				1,
				MAX_DIGITS,
				"rounding",
				0,
				8,
				"toExpNeg",
				-Infinity,
				0,
				"toExpPos",
				0,
				Infinity
			];
			for (i = 0; i < ps.length; i += 3) if ((v = obj[p = ps[i]]) !== void 0) if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;
			else throw Error(invalidArgument + p + ": " + v);
			if ((v = obj[p = "LN10"]) !== void 0) if (v == Math.LN10) this[p] = new this(v);
			else throw Error(invalidArgument + p + ": " + v);
			return this;
		}
		Decimal$2 = clone(Decimal$2);
		Decimal$2["default"] = Decimal$2.Decimal = Decimal$2;
		ONE = new Decimal$2(1);
		if (typeof define == "function" && define.amd) define(function() {
			return Decimal$2;
		});
		else if (typeof module != "undefined" && module.exports) module.exports = Decimal$2;
		else {
			if (!globalScope) globalScope = typeof self != "undefined" && self && self.self == self ? self : Function("return this")();
			globalScope.Decimal = Decimal$2;
		}
	})(exports);
}));
function _toConsumableArray$9(arr) {
	return _arrayWithoutHoles$9(arr) || _iterableToArray$10(arr) || _unsupportedIterableToArray$14(arr) || _nonIterableSpread$9();
}
function _nonIterableSpread$9() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$14(o, minLen) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$14(o, minLen);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$14(o, minLen);
}
function _iterableToArray$10(iter) {
	if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}
function _arrayWithoutHoles$9(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray$14(arr);
}
function _arrayLikeToArray$14(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
var identity$1 = function identity$11(i) {
	return i;
};
var PLACE_HOLDER = { "@@functional/placeholder": true };
var isPlaceHolder = function isPlaceHolder$1(val) {
	return val === PLACE_HOLDER;
};
var curry0 = function curry0$1(fn) {
	return function _curried() {
		if (arguments.length === 0 || arguments.length === 1 && isPlaceHolder(arguments.length <= 0 ? void 0 : arguments[0])) return _curried;
		return fn.apply(void 0, arguments);
	};
};
var curryN = function curryN$1(n, fn) {
	if (n === 1) return fn;
	return curry0(function() {
		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
		var argsLength = args.filter(function(arg) {
			return arg !== PLACE_HOLDER;
		}).length;
		if (argsLength >= n) return fn.apply(void 0, args);
		return curryN$1(n - argsLength, curry0(function() {
			for (var _len2 = arguments.length, restArgs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) restArgs[_key2] = arguments[_key2];
			var newArgs = args.map(function(arg) {
				return isPlaceHolder(arg) ? restArgs.shift() : arg;
			});
			return fn.apply(void 0, _toConsumableArray$9(newArgs).concat(restArgs));
		}));
	});
};
var curry = function curry$1(fn) {
	return curryN(fn.length, fn);
};
var range$3 = function range$5(begin, end) {
	var arr = [];
	for (var i = begin; i < end; ++i) arr[i - begin] = i;
	return arr;
};
var map = curry(function(fn, arr) {
	if (Array.isArray(arr)) return arr.map(fn);
	return Object.keys(arr).map(function(key) {
		return arr[key];
	}).map(fn);
});
var compose = function compose$1() {
	for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) args[_key3] = arguments[_key3];
	if (!args.length) return identity$1;
	var fns = args.reverse();
	var firstFn = fns[0];
	var tailsFn = fns.slice(1);
	return function() {
		return tailsFn.reduce(function(res, fn) {
			return fn(res);
		}, firstFn.apply(void 0, arguments));
	};
};
var reverse = function reverse$1(arr) {
	if (Array.isArray(arr)) return arr.reverse();
	return arr.split("").reverse.join("");
};
var memoize$1 = function memoize$4(fn) {
	var lastArgs = null;
	var lastResult$1 = null;
	return function() {
		for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) args[_key4] = arguments[_key4];
		if (lastArgs && args.every(function(val, i) {
			return val === lastArgs[i];
		})) return lastResult$1;
		lastArgs = args;
		lastResult$1 = fn.apply(void 0, args);
		return lastResult$1;
	};
};
var import_decimal$1 = /* @__PURE__ */ __toESM(require_decimal());
function getDigitCount(value) {
	var result;
	if (value === 0) result = 1;
	else result = Math.floor(new import_decimal$1.default(value).abs().log(10).toNumber()) + 1;
	return result;
}
function rangeStep(start, end, step) {
	var num = new import_decimal$1.default(start);
	var i = 0;
	var result = [];
	while (num.lt(end) && i < 1e5) {
		result.push(num.toNumber());
		num = num.add(step);
		i++;
	}
	return result;
}
var arithmetic_default = {
	rangeStep,
	getDigitCount,
	interpolateNumber: curry(function(a$1, b, t) {
		var newA = +a$1;
		return newA + t * (+b - newA);
	}),
	uninterpolateNumber: curry(function(a$1, b, x$1) {
		var diff = b - +a$1;
		diff = diff || Infinity;
		return (x$1 - a$1) / diff;
	}),
	uninterpolateTruncation: curry(function(a$1, b, x$1) {
		var diff = b - +a$1;
		diff = diff || Infinity;
		return Math.max(0, Math.min(1, (x$1 - a$1) / diff));
	})
};
var import_decimal = /* @__PURE__ */ __toESM(require_decimal());
function _toConsumableArray$8(arr) {
	return _arrayWithoutHoles$8(arr) || _iterableToArray$9(arr) || _unsupportedIterableToArray$13(arr) || _nonIterableSpread$8();
}
function _nonIterableSpread$8() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray$9(iter) {
	if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}
function _arrayWithoutHoles$8(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray$13(arr);
}
function _slicedToArray$7(arr, i) {
	return _arrayWithHoles$8(arr) || _iterableToArrayLimit$7(arr, i) || _unsupportedIterableToArray$13(arr, i) || _nonIterableRest$8();
}
function _nonIterableRest$8() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$13(o, minLen) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$13(o, minLen);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$13(o, minLen);
}
function _arrayLikeToArray$13(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$7(arr, i) {
	if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
	var _arr = [];
	var _n = true;
	var _d = false;
	var _e = void 0;
	try {
		for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
			_arr.push(_s.value);
			if (i && _arr.length === i) break;
		}
	} catch (err) {
		_d = true;
		_e = err;
	} finally {
		try {
			if (!_n && _i["return"] != null) _i["return"]();
		} finally {
			if (_d) throw _e;
		}
	}
	return _arr;
}
function _arrayWithHoles$8(arr) {
	if (Array.isArray(arr)) return arr;
}
function getValidInterval(_ref) {
	var _ref2 = _slicedToArray$7(_ref, 2), min$3 = _ref2[0], max$3 = _ref2[1];
	var validMin = min$3, validMax = max$3;
	if (min$3 > max$3) {
		validMin = max$3;
		validMax = min$3;
	}
	return [validMin, validMax];
}
function getFormatStep(roughStep, allowDecimals, correctionFactor) {
	if (roughStep.lte(0)) return new import_decimal.default(0);
	var digitCount = arithmetic_default.getDigitCount(roughStep.toNumber());
	var digitCountValue = new import_decimal.default(10).pow(digitCount);
	var stepRatio = roughStep.div(digitCountValue);
	var stepRatioScale = digitCount !== 1 ? .05 : .1;
	var formatStep = new import_decimal.default(Math.ceil(stepRatio.div(stepRatioScale).toNumber())).add(correctionFactor).mul(stepRatioScale).mul(digitCountValue);
	return allowDecimals ? formatStep : new import_decimal.default(Math.ceil(formatStep));
}
function getTickOfSingleValue(value, tickCount, allowDecimals) {
	var step = 1;
	var middle = new import_decimal.default(value);
	if (!middle.isint() && allowDecimals) {
		var absVal = Math.abs(value);
		if (absVal < 1) {
			step = new import_decimal.default(10).pow(arithmetic_default.getDigitCount(value) - 1);
			middle = new import_decimal.default(Math.floor(middle.div(step).toNumber())).mul(step);
		} else if (absVal > 1) middle = new import_decimal.default(Math.floor(value));
	} else if (value === 0) middle = new import_decimal.default(Math.floor((tickCount - 1) / 2));
	else if (!allowDecimals) middle = new import_decimal.default(Math.floor(value));
	var middleIndex = Math.floor((tickCount - 1) / 2);
	return compose(map(function(n) {
		return middle.add(new import_decimal.default(n - middleIndex).mul(step)).toNumber();
	}), range$3)(0, tickCount);
}
function calculateStep(min$3, max$3, tickCount, allowDecimals) {
	var correctionFactor = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
	if (!Number.isFinite((max$3 - min$3) / (tickCount - 1))) return {
		step: new import_decimal.default(0),
		tickMin: new import_decimal.default(0),
		tickMax: new import_decimal.default(0)
	};
	var step = getFormatStep(new import_decimal.default(max$3).sub(min$3).div(tickCount - 1), allowDecimals, correctionFactor);
	var middle;
	if (min$3 <= 0 && max$3 >= 0) middle = new import_decimal.default(0);
	else {
		middle = new import_decimal.default(min$3).add(max$3).div(2);
		middle = middle.sub(new import_decimal.default(middle).mod(step));
	}
	var belowCount = Math.ceil(middle.sub(min$3).div(step).toNumber());
	var upCount = Math.ceil(new import_decimal.default(max$3).sub(middle).div(step).toNumber());
	var scaleCount = belowCount + upCount + 1;
	if (scaleCount > tickCount) return calculateStep(min$3, max$3, tickCount, allowDecimals, correctionFactor + 1);
	if (scaleCount < tickCount) {
		upCount = max$3 > 0 ? upCount + (tickCount - scaleCount) : upCount;
		belowCount = max$3 > 0 ? belowCount : belowCount + (tickCount - scaleCount);
	}
	return {
		step,
		tickMin: middle.sub(new import_decimal.default(belowCount).mul(step)),
		tickMax: middle.add(new import_decimal.default(upCount).mul(step))
	};
}
function getNiceTickValuesFn(_ref3) {
	var _ref4 = _slicedToArray$7(_ref3, 2), min$3 = _ref4[0], max$3 = _ref4[1];
	var tickCount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 6;
	var allowDecimals = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
	var count = Math.max(tickCount, 2);
	var _getValidInterval2 = _slicedToArray$7(getValidInterval([min$3, max$3]), 2), cormin = _getValidInterval2[0], cormax = _getValidInterval2[1];
	if (cormin === -Infinity || cormax === Infinity) {
		var _values = cormax === Infinity ? [cormin].concat(_toConsumableArray$8(range$3(0, tickCount - 1).map(function() {
			return Infinity;
		}))) : [].concat(_toConsumableArray$8(range$3(0, tickCount - 1).map(function() {
			return -Infinity;
		})), [cormax]);
		return min$3 > max$3 ? reverse(_values) : _values;
	}
	if (cormin === cormax) return getTickOfSingleValue(cormin, tickCount, allowDecimals);
	var _calculateStep = calculateStep(cormin, cormax, count, allowDecimals), step = _calculateStep.step, tickMin = _calculateStep.tickMin, tickMax = _calculateStep.tickMax;
	var values = arithmetic_default.rangeStep(tickMin, tickMax.add(new import_decimal.default(.1).mul(step)), step);
	return min$3 > max$3 ? reverse(values) : values;
}
function getTickValuesFn(_ref5) {
	var _ref6 = _slicedToArray$7(_ref5, 2), min$3 = _ref6[0], max$3 = _ref6[1];
	var tickCount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 6;
	var allowDecimals = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
	var count = Math.max(tickCount, 2);
	var _getValidInterval4 = _slicedToArray$7(getValidInterval([min$3, max$3]), 2), cormin = _getValidInterval4[0], cormax = _getValidInterval4[1];
	if (cormin === -Infinity || cormax === Infinity) return [min$3, max$3];
	if (cormin === cormax) return getTickOfSingleValue(cormin, tickCount, allowDecimals);
	var step = getFormatStep(new import_decimal.default(cormax).sub(cormin).div(count - 1), allowDecimals, 0);
	var values = compose(map(function(n) {
		return new import_decimal.default(cormin).add(new import_decimal.default(n).mul(step)).toNumber();
	}), range$3)(0, count).filter(function(entry) {
		return entry >= cormin && entry <= cormax;
	});
	return min$3 > max$3 ? reverse(values) : values;
}
function getTickValuesFixedDomainFn(_ref7, tickCount) {
	var _ref8 = _slicedToArray$7(_ref7, 2), min$3 = _ref8[0], max$3 = _ref8[1];
	var allowDecimals = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
	var _getValidInterval6 = _slicedToArray$7(getValidInterval([min$3, max$3]), 2), cormin = _getValidInterval6[0], cormax = _getValidInterval6[1];
	if (cormin === -Infinity || cormax === Infinity) return [min$3, max$3];
	if (cormin === cormax) return [cormin];
	var count = Math.max(tickCount, 2);
	var step = getFormatStep(new import_decimal.default(cormax).sub(cormin).div(count - 1), allowDecimals, 0);
	var values = [].concat(_toConsumableArray$8(arithmetic_default.rangeStep(new import_decimal.default(cormin), new import_decimal.default(cormax).sub(new import_decimal.default(.99).mul(step)), step)), [cormax]);
	return min$3 > max$3 ? reverse(values) : values;
}
var getNiceTickValues = memoize$1(getNiceTickValuesFn);
memoize$1(getTickValuesFn);
var getTickValuesFixedDomain = memoize$1(getTickValuesFixedDomainFn);
var isProduction = false;
var prefix$1 = "Invariant failed";
function invariant(condition, message) {
	if (condition) return;
	if (isProduction) throw new Error(prefix$1);
	var provided = typeof message === "function" ? message() : message;
	var value = provided ? "".concat(prefix$1, ": ").concat(provided) : prefix$1;
	throw new Error(value);
}
var _excluded$10 = [
	"offset",
	"layout",
	"width",
	"dataKey",
	"data",
	"dataPointFormatter",
	"xAxis",
	"yAxis"
];
function _typeof$32(o) {
	"@babel/helpers - typeof";
	return _typeof$32 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$32(o);
}
function _extends$19() {
	_extends$19 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$19.apply(this, arguments);
}
function _slicedToArray$6(arr, i) {
	return _arrayWithHoles$7(arr) || _iterableToArrayLimit$6(arr, i) || _unsupportedIterableToArray$12(arr, i) || _nonIterableRest$7();
}
function _nonIterableRest$7() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$12(o, minLen) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$12(o, minLen);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$12(o, minLen);
}
function _arrayLikeToArray$12(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$6(r, l) {
	var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a$1 = [], f = !0, o = !1;
		try {
			if (i = (t = t.call(r)).next, 0 === l) {
				if (Object(t) !== t) return;
				f = !1;
			} else for (; !(f = (e = i.call(t)).done) && (a$1.push(e.value), a$1.length !== l); f = !0);
		} catch (r$1) {
			o = !0, n = r$1;
		} finally {
			try {
				if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a$1;
	}
}
function _arrayWithHoles$7(arr) {
	if (Array.isArray(arr)) return arr;
}
function _objectWithoutProperties$10(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$10(source, excluded);
	var key, i;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i = 0; i < sourceSymbolKeys.length; i++) {
			key = sourceSymbolKeys[i];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$10(source, excluded) {
	if (source == null) return {};
	var target = {};
	for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function _classCallCheck$12(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$12(target, props) {
	for (var i = 0; i < props.length; i++) {
		var descriptor = props[i];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$30(descriptor.key), descriptor);
	}
}
function _createClass$12(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$12(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$12(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _callSuper$9(t, o, e) {
	return o = _getPrototypeOf$10(o), _possibleConstructorReturn$10(t, _isNativeReflectConstruct$10() ? Reflect.construct(o, e || [], _getPrototypeOf$10(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn$10(self$1, call) {
	if (call && (_typeof$32(call) === "object" || typeof call === "function")) return call;
	else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
	return _assertThisInitialized$10(self$1);
}
function _assertThisInitialized$10(self$1) {
	if (self$1 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return self$1;
}
function _isNativeReflectConstruct$10() {
	try {
		var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
	} catch (t$1) {}
	return (_isNativeReflectConstruct$10 = function _isNativeReflectConstruct$15() {
		return !!t;
	})();
}
function _getPrototypeOf$10(o) {
	_getPrototypeOf$10 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf$15(o$1) {
		return o$1.__proto__ || Object.getPrototypeOf(o$1);
	};
	return _getPrototypeOf$10(o);
}
function _inherits$10(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
	subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
		value: subClass,
		writable: true,
		configurable: true
	} });
	Object.defineProperty(subClass, "prototype", { writable: false });
	if (superClass) _setPrototypeOf$10(subClass, superClass);
}
function _setPrototypeOf$10(o, p) {
	_setPrototypeOf$10 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf$15(o$1, p$1) {
		o$1.__proto__ = p$1;
		return o$1;
	};
	return _setPrototypeOf$10(o, p);
}
function _defineProperty$30(obj, key, value) {
	key = _toPropertyKey$30(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$30(t) {
	var i = _toPrimitive$30(t, "string");
	return "symbol" == _typeof$32(i) ? i : i + "";
}
function _toPrimitive$30(t, r) {
	if ("object" != _typeof$32(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$32(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
var ErrorBar = /* @__PURE__ */ function(_React$Component) {
	function ErrorBar$1() {
		_classCallCheck$12(this, ErrorBar$1);
		return _callSuper$9(this, ErrorBar$1, arguments);
	}
	_inherits$10(ErrorBar$1, _React$Component);
	return _createClass$12(ErrorBar$1, [{
		key: "render",
		value: function render() {
			var _this$props = this.props, offset = _this$props.offset, layout = _this$props.layout, width = _this$props.width, dataKey = _this$props.dataKey, data = _this$props.data, dataPointFormatter = _this$props.dataPointFormatter, xAxis = _this$props.xAxis, yAxis = _this$props.yAxis;
			var svgProps = filterProps(_objectWithoutProperties$10(_this$props, _excluded$10), false);
			this.props.direction === "x" && xAxis.type !== "number" && invariant(false, "ErrorBar requires Axis type property to be \"number\".");
			var errorBars = data.map(function(entry) {
				var _dataPointFormatter = dataPointFormatter(entry, dataKey), x$1 = _dataPointFormatter.x, y$1 = _dataPointFormatter.y, value = _dataPointFormatter.value, errorVal = _dataPointFormatter.errorVal;
				if (!errorVal) return null;
				var lineCoordinates = [];
				var lowBound, highBound;
				if (Array.isArray(errorVal)) {
					var _errorVal = _slicedToArray$6(errorVal, 2);
					lowBound = _errorVal[0];
					highBound = _errorVal[1];
				} else lowBound = highBound = errorVal;
				if (layout === "vertical") {
					var scale = xAxis.scale;
					var yMid = y$1 + offset;
					var yMin = yMid + width;
					var yMax = yMid - width;
					var xMin = scale(value - lowBound);
					var xMax = scale(value + highBound);
					lineCoordinates.push({
						x1: xMax,
						y1: yMin,
						x2: xMax,
						y2: yMax
					});
					lineCoordinates.push({
						x1: xMin,
						y1: yMid,
						x2: xMax,
						y2: yMid
					});
					lineCoordinates.push({
						x1: xMin,
						y1: yMin,
						x2: xMin,
						y2: yMax
					});
				} else if (layout === "horizontal") {
					var _scale = yAxis.scale;
					var xMid = x$1 + offset;
					var _xMin = xMid - width;
					var _xMax = xMid + width;
					var _yMin = _scale(value - lowBound);
					var _yMax = _scale(value + highBound);
					lineCoordinates.push({
						x1: _xMin,
						y1: _yMax,
						x2: _xMax,
						y2: _yMax
					});
					lineCoordinates.push({
						x1: xMid,
						y1: _yMin,
						x2: xMid,
						y2: _yMax
					});
					lineCoordinates.push({
						x1: _xMin,
						y1: _yMin,
						x2: _xMax,
						y2: _yMin
					});
				}
				return /* @__PURE__ */ import_react.createElement(Layer, _extends$19({
					className: "recharts-errorBar",
					key: "bar-".concat(lineCoordinates.map(function(c$1) {
						return "".concat(c$1.x1, "-").concat(c$1.x2, "-").concat(c$1.y1, "-").concat(c$1.y2);
					}))
				}, svgProps), lineCoordinates.map(function(coordinates) {
					return /* @__PURE__ */ import_react.createElement("line", _extends$19({}, coordinates, { key: "line-".concat(coordinates.x1, "-").concat(coordinates.x2, "-").concat(coordinates.y1, "-").concat(coordinates.y2) }));
				}));
			});
			return /* @__PURE__ */ import_react.createElement(Layer, { className: "recharts-errorBars" }, errorBars);
		}
	}]);
}(import_react.Component);
_defineProperty$30(ErrorBar, "defaultProps", {
	stroke: "black",
	strokeWidth: 1.5,
	width: 5,
	offset: 0,
	layout: "horizontal"
});
_defineProperty$30(ErrorBar, "displayName", "ErrorBar");
function _typeof$31(o) {
	"@babel/helpers - typeof";
	return _typeof$31 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$31(o);
}
function ownKeys$26(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$26(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$26(Object(t), !0).forEach(function(r$1) {
			_defineProperty$29(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$26(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}
function _defineProperty$29(obj, key, value) {
	key = _toPropertyKey$29(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$29(t) {
	var i = _toPrimitive$29(t, "string");
	return "symbol" == _typeof$31(i) ? i : i + "";
}
function _toPrimitive$29(t, r) {
	if ("object" != _typeof$31(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$31(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
var getLegendProps = function getLegendProps$1(_ref) {
	var children = _ref.children, formattedGraphicalItems = _ref.formattedGraphicalItems, legendWidth = _ref.legendWidth, legendContent = _ref.legendContent;
	var legendItem = findChildByType(children, Legend);
	if (!legendItem) return null;
	var legendDefaultProps = Legend.defaultProps;
	var legendProps = legendDefaultProps !== void 0 ? _objectSpread$26(_objectSpread$26({}, legendDefaultProps), legendItem.props) : {};
	var legendData;
	if (legendItem.props && legendItem.props.payload) legendData = legendItem.props && legendItem.props.payload;
	else if (legendContent === "children") legendData = (formattedGraphicalItems || []).reduce(function(result, _ref2) {
		var item = _ref2.item, props = _ref2.props;
		var data = props.sectors || props.data || [];
		return result.concat(data.map(function(entry) {
			return {
				type: legendItem.props.iconType || item.props.legendType,
				value: entry.name,
				color: entry.fill,
				payload: entry
			};
		}));
	}, []);
	else legendData = (formattedGraphicalItems || []).map(function(_ref3) {
		var item = _ref3.item;
		var itemDefaultProps = item.type.defaultProps;
		var itemProps = itemDefaultProps !== void 0 ? _objectSpread$26(_objectSpread$26({}, itemDefaultProps), item.props) : {};
		var dataKey = itemProps.dataKey, name = itemProps.name, legendType = itemProps.legendType;
		return {
			inactive: itemProps.hide,
			dataKey,
			type: legendProps.iconType || legendType || "square",
			color: getMainColorOfGraphicItem(item),
			value: name || dataKey,
			payload: itemProps
		};
	});
	return _objectSpread$26(_objectSpread$26(_objectSpread$26({}, legendProps), Legend.getWithHeight(legendItem, legendWidth)), {}, {
		payload: legendData,
		item: legendItem
	});
};
var import_max = /* @__PURE__ */ __toESM(require_max());
var import_min = /* @__PURE__ */ __toESM(require_min());
var import_isNil$5 = /* @__PURE__ */ __toESM(require_isNil());
var import_isFunction$13 = /* @__PURE__ */ __toESM(require_isFunction());
var import_isString = /* @__PURE__ */ __toESM(require_isString());
var import_get$2 = /* @__PURE__ */ __toESM(require_get());
var import_flatMap = /* @__PURE__ */ __toESM(require_flatMap());
var import_isNaN = /* @__PURE__ */ __toESM(require_isNaN());
var import_upperFirst$1 = /* @__PURE__ */ __toESM(require_upperFirst());
var import_isEqual$2 = /* @__PURE__ */ __toESM(require_isEqual());
var import_sortBy$1 = /* @__PURE__ */ __toESM(require_sortBy());
function _typeof$30(o) {
	"@babel/helpers - typeof";
	return _typeof$30 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$30(o);
}
function _toConsumableArray$7(arr) {
	return _arrayWithoutHoles$7(arr) || _iterableToArray$8(arr) || _unsupportedIterableToArray$11(arr) || _nonIterableSpread$7();
}
function _nonIterableSpread$7() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$11(o, minLen) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$11(o, minLen);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$11(o, minLen);
}
function _iterableToArray$8(iter) {
	if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$7(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray$11(arr);
}
function _arrayLikeToArray$11(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function ownKeys$25(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$25(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$25(Object(t), !0).forEach(function(r$1) {
			_defineProperty$28(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$25(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}
function _defineProperty$28(obj, key, value) {
	key = _toPropertyKey$28(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$28(t) {
	var i = _toPrimitive$28(t, "string");
	return "symbol" == _typeof$30(i) ? i : i + "";
}
function _toPrimitive$28(t, r) {
	if ("object" != _typeof$30(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$30(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
function getValueByDataKey(obj, dataKey, defaultValue) {
	if ((0, import_isNil$5.default)(obj) || (0, import_isNil$5.default)(dataKey)) return defaultValue;
	if (isNumOrStr(dataKey)) return (0, import_get$2.default)(obj, dataKey, defaultValue);
	if ((0, import_isFunction$13.default)(dataKey)) return dataKey(obj);
	return defaultValue;
}
function getDomainOfDataByKey(data, key, type, filterNil) {
	var flattenData = (0, import_flatMap.default)(data, function(entry) {
		return getValueByDataKey(entry, key);
	});
	if (type === "number") {
		var domain = flattenData.filter(function(entry) {
			return isNumber(entry) || parseFloat(entry);
		});
		return domain.length ? [(0, import_min.default)(domain), (0, import_max.default)(domain)] : [Infinity, -Infinity];
	}
	return (filterNil ? flattenData.filter(function(entry) {
		return !(0, import_isNil$5.default)(entry);
	}) : flattenData).map(function(entry) {
		return isNumOrStr(entry) || entry instanceof Date ? entry : "";
	});
}
var calculateActiveTickIndex = function calculateActiveTickIndex$1(coordinate) {
	var _ticks$length;
	var ticks$1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
	var unsortedTicks = arguments.length > 2 ? arguments[2] : void 0;
	var axis = arguments.length > 3 ? arguments[3] : void 0;
	var index = -1;
	var len = (_ticks$length = ticks$1 === null || ticks$1 === void 0 ? void 0 : ticks$1.length) !== null && _ticks$length !== void 0 ? _ticks$length : 0;
	if (len <= 1) return 0;
	if (axis && axis.axisType === "angleAxis" && Math.abs(Math.abs(axis.range[1] - axis.range[0]) - 360) <= 1e-6) {
		var range$5 = axis.range;
		for (var i = 0; i < len; i++) {
			var before = i > 0 ? unsortedTicks[i - 1].coordinate : unsortedTicks[len - 1].coordinate;
			var cur = unsortedTicks[i].coordinate;
			var after = i >= len - 1 ? unsortedTicks[0].coordinate : unsortedTicks[i + 1].coordinate;
			var sameDirectionCoord = void 0;
			if (mathSign(cur - before) !== mathSign(after - cur)) {
				var diffInterval = [];
				if (mathSign(after - cur) === mathSign(range$5[1] - range$5[0])) {
					sameDirectionCoord = after;
					var curInRange = cur + range$5[1] - range$5[0];
					diffInterval[0] = Math.min(curInRange, (curInRange + before) / 2);
					diffInterval[1] = Math.max(curInRange, (curInRange + before) / 2);
				} else {
					sameDirectionCoord = before;
					var afterInRange = after + range$5[1] - range$5[0];
					diffInterval[0] = Math.min(cur, (afterInRange + cur) / 2);
					diffInterval[1] = Math.max(cur, (afterInRange + cur) / 2);
				}
				var sameInterval = [Math.min(cur, (sameDirectionCoord + cur) / 2), Math.max(cur, (sameDirectionCoord + cur) / 2)];
				if (coordinate > sameInterval[0] && coordinate <= sameInterval[1] || coordinate >= diffInterval[0] && coordinate <= diffInterval[1]) {
					index = unsortedTicks[i].index;
					break;
				}
			} else {
				var minValue = Math.min(before, after);
				var maxValue = Math.max(before, after);
				if (coordinate > (minValue + cur) / 2 && coordinate <= (maxValue + cur) / 2) {
					index = unsortedTicks[i].index;
					break;
				}
			}
		}
	} else for (var _i = 0; _i < len; _i++) if (_i === 0 && coordinate <= (ticks$1[_i].coordinate + ticks$1[_i + 1].coordinate) / 2 || _i > 0 && _i < len - 1 && coordinate > (ticks$1[_i].coordinate + ticks$1[_i - 1].coordinate) / 2 && coordinate <= (ticks$1[_i].coordinate + ticks$1[_i + 1].coordinate) / 2 || _i === len - 1 && coordinate > (ticks$1[_i].coordinate + ticks$1[_i - 1].coordinate) / 2) {
		index = ticks$1[_i].index;
		break;
	}
	return index;
};
var getMainColorOfGraphicItem = function getMainColorOfGraphicItem$1(item) {
	var _item$type;
	var displayName = item.type.displayName;
	var defaultedProps = (_item$type = item.type) !== null && _item$type !== void 0 && _item$type.defaultProps ? _objectSpread$25(_objectSpread$25({}, item.type.defaultProps), item.props) : item.props;
	var stroke = defaultedProps.stroke, fill = defaultedProps.fill;
	var result;
	switch (displayName) {
		case "Line":
			result = stroke;
			break;
		case "Area":
		case "Radar":
			result = stroke && stroke !== "none" ? stroke : fill;
			break;
		default:
			result = fill;
			break;
	}
	return result;
};
var getBarSizeList = function getBarSizeList$1(_ref2) {
	var globalSize = _ref2.barSize, totalSize = _ref2.totalSize, _ref2$stackGroups = _ref2.stackGroups, stackGroups = _ref2$stackGroups === void 0 ? {} : _ref2$stackGroups;
	if (!stackGroups) return {};
	var result = {};
	var numericAxisIds = Object.keys(stackGroups);
	for (var i = 0, len = numericAxisIds.length; i < len; i++) {
		var sgs = stackGroups[numericAxisIds[i]].stackGroups;
		var stackIds = Object.keys(sgs);
		for (var j = 0, sLen = stackIds.length; j < sLen; j++) {
			var _sgs$stackIds$j = sgs[stackIds[j]], items = _sgs$stackIds$j.items, cateAxisId = _sgs$stackIds$j.cateAxisId;
			var barItems = items.filter(function(item) {
				return getDisplayName(item.type).indexOf("Bar") >= 0;
			});
			if (barItems && barItems.length) {
				var barItemDefaultProps = barItems[0].type.defaultProps;
				var barItemProps = barItemDefaultProps !== void 0 ? _objectSpread$25(_objectSpread$25({}, barItemDefaultProps), barItems[0].props) : barItems[0].props;
				var selfSize = barItemProps.barSize;
				var cateId = barItemProps[cateAxisId];
				if (!result[cateId]) result[cateId] = [];
				var barSize = (0, import_isNil$5.default)(selfSize) ? globalSize : selfSize;
				result[cateId].push({
					item: barItems[0],
					stackList: barItems.slice(1),
					barSize: (0, import_isNil$5.default)(barSize) ? void 0 : getPercentValue(barSize, totalSize, 0)
				});
			}
		}
	}
	return result;
};
var getBarPosition = function getBarPosition$1(_ref3) {
	var barGap = _ref3.barGap, barCategoryGap = _ref3.barCategoryGap, bandSize = _ref3.bandSize, _ref3$sizeList = _ref3.sizeList, sizeList = _ref3$sizeList === void 0 ? [] : _ref3$sizeList, maxBarSize = _ref3.maxBarSize;
	var len = sizeList.length;
	if (len < 1) return null;
	var realBarGap = getPercentValue(barGap, bandSize, 0, true);
	var result;
	var initialValue = [];
	if (sizeList[0].barSize === +sizeList[0].barSize) {
		var useFull = false;
		var fullBarSize = bandSize / len;
		var sum = sizeList.reduce(function(res, entry) {
			return res + entry.barSize || 0;
		}, 0);
		sum += (len - 1) * realBarGap;
		if (sum >= bandSize) {
			sum -= (len - 1) * realBarGap;
			realBarGap = 0;
		}
		if (sum >= bandSize && fullBarSize > 0) {
			useFull = true;
			fullBarSize *= .9;
			sum = len * fullBarSize;
		}
		var prev = {
			offset: ((bandSize - sum) / 2 >> 0) - realBarGap,
			size: 0
		};
		result = sizeList.reduce(function(res, entry) {
			var newPosition = {
				item: entry.item,
				position: {
					offset: prev.offset + prev.size + realBarGap,
					size: useFull ? fullBarSize : entry.barSize
				}
			};
			var newRes = [].concat(_toConsumableArray$7(res), [newPosition]);
			prev = newRes[newRes.length - 1].position;
			if (entry.stackList && entry.stackList.length) entry.stackList.forEach(function(item) {
				newRes.push({
					item,
					position: prev
				});
			});
			return newRes;
		}, initialValue);
	} else {
		var _offset = getPercentValue(barCategoryGap, bandSize, 0, true);
		if (bandSize - 2 * _offset - (len - 1) * realBarGap <= 0) realBarGap = 0;
		var originalSize = (bandSize - 2 * _offset - (len - 1) * realBarGap) / len;
		if (originalSize > 1) originalSize >>= 0;
		var size = maxBarSize === +maxBarSize ? Math.min(originalSize, maxBarSize) : originalSize;
		result = sizeList.reduce(function(res, entry, i) {
			var newRes = [].concat(_toConsumableArray$7(res), [{
				item: entry.item,
				position: {
					offset: _offset + (originalSize + realBarGap) * i + (originalSize - size) / 2,
					size
				}
			}]);
			if (entry.stackList && entry.stackList.length) entry.stackList.forEach(function(item) {
				newRes.push({
					item,
					position: newRes[newRes.length - 1].position
				});
			});
			return newRes;
		}, initialValue);
	}
	return result;
};
var appendOffsetOfLegend = function appendOffsetOfLegend$1(offset, _unused, props, legendBox) {
	var children = props.children, width = props.width, margin = props.margin;
	var legendProps = getLegendProps({
		children,
		legendWidth: width - (margin.left || 0) - (margin.right || 0)
	});
	if (legendProps) {
		var _ref4 = legendBox || {}, boxWidth = _ref4.width, boxHeight = _ref4.height;
		var align = legendProps.align, verticalAlign = legendProps.verticalAlign, layout = legendProps.layout;
		if ((layout === "vertical" || layout === "horizontal" && verticalAlign === "middle") && align !== "center" && isNumber(offset[align])) return _objectSpread$25(_objectSpread$25({}, offset), {}, _defineProperty$28({}, align, offset[align] + (boxWidth || 0)));
		if ((layout === "horizontal" || layout === "vertical" && align === "center") && verticalAlign !== "middle" && isNumber(offset[verticalAlign])) return _objectSpread$25(_objectSpread$25({}, offset), {}, _defineProperty$28({}, verticalAlign, offset[verticalAlign] + (boxHeight || 0)));
	}
	return offset;
};
var isErrorBarRelevantForAxis = function isErrorBarRelevantForAxis$1(layout, axisType, direction) {
	if ((0, import_isNil$5.default)(axisType)) return true;
	if (layout === "horizontal") return axisType === "yAxis";
	if (layout === "vertical") return axisType === "xAxis";
	if (direction === "x") return axisType === "xAxis";
	if (direction === "y") return axisType === "yAxis";
	return true;
};
var getDomainOfErrorBars = function getDomainOfErrorBars$1(data, item, dataKey, layout, axisType) {
	var children = item.props.children;
	var errorBars = findAllByType(children, ErrorBar).filter(function(errorBarChild) {
		return isErrorBarRelevantForAxis(layout, axisType, errorBarChild.props.direction);
	});
	if (errorBars && errorBars.length) {
		var keys$6 = errorBars.map(function(errorBarChild) {
			return errorBarChild.props.dataKey;
		});
		return data.reduce(function(result, entry) {
			var entryValue = getValueByDataKey(entry, dataKey);
			if ((0, import_isNil$5.default)(entryValue)) return result;
			var mainValue = Array.isArray(entryValue) ? [(0, import_min.default)(entryValue), (0, import_max.default)(entryValue)] : [entryValue, entryValue];
			var errorDomain = keys$6.reduce(function(prevErrorArr, k$1) {
				var errorValue = getValueByDataKey(entry, k$1, 0);
				var lowerValue = mainValue[0] - Math.abs(Array.isArray(errorValue) ? errorValue[0] : errorValue);
				var upperValue = mainValue[1] + Math.abs(Array.isArray(errorValue) ? errorValue[1] : errorValue);
				return [Math.min(lowerValue, prevErrorArr[0]), Math.max(upperValue, prevErrorArr[1])];
			}, [Infinity, -Infinity]);
			return [Math.min(errorDomain[0], result[0]), Math.max(errorDomain[1], result[1])];
		}, [Infinity, -Infinity]);
	}
	return null;
};
var parseErrorBarsOfAxis = function parseErrorBarsOfAxis$1(data, items, dataKey, axisType, layout) {
	var domains = items.map(function(item) {
		return getDomainOfErrorBars(data, item, dataKey, layout, axisType);
	}).filter(function(entry) {
		return !(0, import_isNil$5.default)(entry);
	});
	if (domains && domains.length) return domains.reduce(function(result, entry) {
		return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];
	}, [Infinity, -Infinity]);
	return null;
};
var getDomainOfItemsWithSameAxis = function getDomainOfItemsWithSameAxis$1(data, items, type, layout, filterNil) {
	var domains = items.map(function(item) {
		var dataKey = item.props.dataKey;
		if (type === "number" && dataKey) return getDomainOfErrorBars(data, item, dataKey, layout) || getDomainOfDataByKey(data, dataKey, type, filterNil);
		return getDomainOfDataByKey(data, dataKey, type, filterNil);
	});
	if (type === "number") return domains.reduce(function(result, entry) {
		return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];
	}, [Infinity, -Infinity]);
	var tag = {};
	return domains.reduce(function(result, entry) {
		for (var i = 0, len = entry.length; i < len; i++) if (!tag[entry[i]]) {
			tag[entry[i]] = true;
			result.push(entry[i]);
		}
		return result;
	}, []);
};
var isCategoricalAxis = function isCategoricalAxis$1(layout, axisType) {
	return layout === "horizontal" && axisType === "xAxis" || layout === "vertical" && axisType === "yAxis" || layout === "centric" && axisType === "angleAxis" || layout === "radial" && axisType === "radiusAxis";
};
var getCoordinatesOfGrid = function getCoordinatesOfGrid$1(ticks$1, minValue, maxValue, syncWithTicks) {
	if (syncWithTicks) return ticks$1.map(function(entry) {
		return entry.coordinate;
	});
	var hasMin, hasMax;
	var values = ticks$1.map(function(entry) {
		if (entry.coordinate === minValue) hasMin = true;
		if (entry.coordinate === maxValue) hasMax = true;
		return entry.coordinate;
	});
	if (!hasMin) values.push(minValue);
	if (!hasMax) values.push(maxValue);
	return values;
};
var getTicksOfAxis = function getTicksOfAxis$1(axis, isGrid, isAll) {
	if (!axis) return null;
	var scale = axis.scale;
	var duplicateDomain = axis.duplicateDomain, type = axis.type, range$5 = axis.range;
	var offsetForBand = axis.realScaleType === "scaleBand" ? scale.bandwidth() / 2 : 2;
	var offset = (isGrid || isAll) && type === "category" && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;
	offset = axis.axisType === "angleAxis" && (range$5 === null || range$5 === void 0 ? void 0 : range$5.length) >= 2 ? mathSign(range$5[0] - range$5[1]) * 2 * offset : offset;
	if (isGrid && (axis.ticks || axis.niceTicks)) return (axis.ticks || axis.niceTicks).map(function(entry) {
		return {
			coordinate: scale(duplicateDomain ? duplicateDomain.indexOf(entry) : entry) + offset,
			value: entry,
			offset
		};
	}).filter(function(row) {
		return !(0, import_isNaN.default)(row.coordinate);
	});
	if (axis.isCategorical && axis.categoricalDomain) return axis.categoricalDomain.map(function(entry, index) {
		return {
			coordinate: scale(entry) + offset,
			value: entry,
			index,
			offset
		};
	});
	if (scale.ticks && !isAll) return scale.ticks(axis.tickCount).map(function(entry) {
		return {
			coordinate: scale(entry) + offset,
			value: entry,
			offset
		};
	});
	return scale.domain().map(function(entry, index) {
		return {
			coordinate: scale(entry) + offset,
			value: duplicateDomain ? duplicateDomain[entry] : entry,
			index,
			offset
		};
	});
};
var handlerWeakMap = /* @__PURE__ */ new WeakMap();
var combineEventHandlers = function combineEventHandlers$1(defaultHandler, childHandler) {
	if (typeof childHandler !== "function") return defaultHandler;
	if (!handlerWeakMap.has(defaultHandler)) handlerWeakMap.set(defaultHandler, /* @__PURE__ */ new WeakMap());
	var childWeakMap = handlerWeakMap.get(defaultHandler);
	if (childWeakMap.has(childHandler)) return childWeakMap.get(childHandler);
	var combineHandler = function combineHandler$1() {
		defaultHandler.apply(void 0, arguments);
		childHandler.apply(void 0, arguments);
	};
	childWeakMap.set(childHandler, combineHandler);
	return combineHandler;
};
var parseScale = function parseScale$1(axis, chartType, hasBar) {
	var scale = axis.scale, type = axis.type, layout = axis.layout, axisType = axis.axisType;
	if (scale === "auto") {
		if (layout === "radial" && axisType === "radiusAxis") return {
			scale: band(),
			realScaleType: "band"
		};
		if (layout === "radial" && axisType === "angleAxis") return {
			scale: linear(),
			realScaleType: "linear"
		};
		if (type === "category" && chartType && (chartType.indexOf("LineChart") >= 0 || chartType.indexOf("AreaChart") >= 0 || chartType.indexOf("ComposedChart") >= 0 && !hasBar)) return {
			scale: point(),
			realScaleType: "point"
		};
		if (type === "category") return {
			scale: band(),
			realScaleType: "band"
		};
		return {
			scale: linear(),
			realScaleType: "linear"
		};
	}
	if ((0, import_isString.default)(scale)) {
		var name = "scale".concat((0, import_upperFirst$1.default)(scale));
		return {
			scale: (d3_scale_exports[name] || point)(),
			realScaleType: d3_scale_exports[name] ? name : "point"
		};
	}
	return (0, import_isFunction$13.default)(scale) ? { scale } : {
		scale: point(),
		realScaleType: "point"
	};
};
var EPS = 1e-4;
var checkDomainOfScale = function checkDomainOfScale$1(scale) {
	var domain = scale.domain();
	if (!domain || domain.length <= 2) return;
	var len = domain.length;
	var range$5 = scale.range();
	var minValue = Math.min(range$5[0], range$5[1]) - EPS;
	var maxValue = Math.max(range$5[0], range$5[1]) + EPS;
	var first = scale(domain[0]);
	var last$2 = scale(domain[len - 1]);
	if (first < minValue || first > maxValue || last$2 < minValue || last$2 > maxValue) scale.domain([domain[0], domain[len - 1]]);
};
var findPositionOfBar = function findPositionOfBar$1(barPosition, child) {
	if (!barPosition) return null;
	for (var i = 0, len = barPosition.length; i < len; i++) if (barPosition[i].item === child) return barPosition[i].position;
	return null;
};
var truncateByDomain = function truncateByDomain$1(value, domain) {
	if (!domain || domain.length !== 2 || !isNumber(domain[0]) || !isNumber(domain[1])) return value;
	var minValue = Math.min(domain[0], domain[1]);
	var maxValue = Math.max(domain[0], domain[1]);
	var result = [value[0], value[1]];
	if (!isNumber(value[0]) || value[0] < minValue) result[0] = minValue;
	if (!isNumber(value[1]) || value[1] > maxValue) result[1] = maxValue;
	if (result[0] > maxValue) result[0] = maxValue;
	if (result[1] < minValue) result[1] = minValue;
	return result;
};
var STACK_OFFSET_MAP = {
	sign: function offsetSign$1(series) {
		var n = series.length;
		if (n <= 0) return;
		for (var j = 0, m = series[0].length; j < m; ++j) {
			var positive = 0;
			var negative = 0;
			for (var i = 0; i < n; ++i) {
				var value = (0, import_isNaN.default)(series[i][j][1]) ? series[i][j][0] : series[i][j][1];
				if (value >= 0) {
					series[i][j][0] = positive;
					series[i][j][1] = positive + value;
					positive = series[i][j][1];
				} else {
					series[i][j][0] = negative;
					series[i][j][1] = negative + value;
					negative = series[i][j][1];
				}
			}
		}
	},
	expand: expand_default,
	none: none_default,
	silhouette: silhouette_default,
	wiggle: wiggle_default,
	positive: function offsetPositive$1(series) {
		var n = series.length;
		if (n <= 0) return;
		for (var j = 0, m = series[0].length; j < m; ++j) {
			var positive = 0;
			for (var i = 0; i < n; ++i) {
				var value = (0, import_isNaN.default)(series[i][j][1]) ? series[i][j][0] : series[i][j][1];
				if (value >= 0) {
					series[i][j][0] = positive;
					series[i][j][1] = positive + value;
					positive = series[i][j][1];
				} else {
					series[i][j][0] = 0;
					series[i][j][1] = 0;
				}
			}
		}
	}
};
var getStackedData = function getStackedData$1(data, stackItems, offsetType) {
	var dataKeys = stackItems.map(function(item) {
		return item.props.dataKey;
	});
	var offsetAccessor = STACK_OFFSET_MAP[offsetType];
	return stack_default().keys(dataKeys).value(function(d, key) {
		return +getValueByDataKey(d, key, 0);
	}).order(none_default$1).offset(offsetAccessor)(data);
};
var getStackGroupsByAxisId = function getStackGroupsByAxisId$1(data, _items, numericAxisId, cateAxisId, offsetType, reverseStackOrder) {
	if (!data) return null;
	var stackGroups = (reverseStackOrder ? _items.reverse() : _items).reduce(function(result, item) {
		var _item$type2;
		var defaultedProps = (_item$type2 = item.type) !== null && _item$type2 !== void 0 && _item$type2.defaultProps ? _objectSpread$25(_objectSpread$25({}, item.type.defaultProps), item.props) : item.props;
		var stackId = defaultedProps.stackId;
		if (defaultedProps.hide) return result;
		var axisId = defaultedProps[numericAxisId];
		var parentGroup = result[axisId] || {
			hasStack: false,
			stackGroups: {}
		};
		if (isNumOrStr(stackId)) {
			var childGroup = parentGroup.stackGroups[stackId] || {
				numericAxisId,
				cateAxisId,
				items: []
			};
			childGroup.items.push(item);
			parentGroup.hasStack = true;
			parentGroup.stackGroups[stackId] = childGroup;
		} else parentGroup.stackGroups[uniqueId("_stackId_")] = {
			numericAxisId,
			cateAxisId,
			items: [item]
		};
		return _objectSpread$25(_objectSpread$25({}, result), {}, _defineProperty$28({}, axisId, parentGroup));
	}, {});
	return Object.keys(stackGroups).reduce(function(result, axisId) {
		var group = stackGroups[axisId];
		if (group.hasStack) group.stackGroups = Object.keys(group.stackGroups).reduce(function(res, stackId) {
			var g = group.stackGroups[stackId];
			return _objectSpread$25(_objectSpread$25({}, res), {}, _defineProperty$28({}, stackId, {
				numericAxisId,
				cateAxisId,
				items: g.items,
				stackedData: getStackedData(data, g.items, offsetType)
			}));
		}, {});
		return _objectSpread$25(_objectSpread$25({}, result), {}, _defineProperty$28({}, axisId, group));
	}, {});
};
var getTicksOfScale = function getTicksOfScale$1(scale, opts) {
	var realScaleType = opts.realScaleType, type = opts.type, tickCount = opts.tickCount, originalDomain = opts.originalDomain, allowDecimals = opts.allowDecimals;
	var scaleType = realScaleType || opts.scale;
	if (scaleType !== "auto" && scaleType !== "linear") return null;
	if (tickCount && type === "number" && originalDomain && (originalDomain[0] === "auto" || originalDomain[1] === "auto")) {
		var domain = scale.domain();
		if (!domain.length) return null;
		var tickValues = getNiceTickValues(domain, tickCount, allowDecimals);
		scale.domain([(0, import_min.default)(tickValues), (0, import_max.default)(tickValues)]);
		return { niceTicks: tickValues };
	}
	if (tickCount && type === "number") return { niceTicks: getTickValuesFixedDomain(scale.domain(), tickCount, allowDecimals) };
	return null;
};
var getCateCoordinateOfBar = function getCateCoordinateOfBar$1(_ref6) {
	var axis = _ref6.axis, ticks$1 = _ref6.ticks, offset = _ref6.offset, bandSize = _ref6.bandSize, entry = _ref6.entry, index = _ref6.index;
	if (axis.type === "category") return ticks$1[index] ? ticks$1[index].coordinate + offset : null;
	var value = getValueByDataKey(entry, axis.dataKey, axis.domain[index]);
	return !(0, import_isNil$5.default)(value) ? axis.scale(value) - bandSize / 2 + offset : null;
};
var getBaseValueOfBar = function getBaseValueOfBar$1(_ref7) {
	var numericAxis = _ref7.numericAxis;
	var domain = numericAxis.scale.domain();
	if (numericAxis.type === "number") {
		var minValue = Math.min(domain[0], domain[1]);
		var maxValue = Math.max(domain[0], domain[1]);
		if (minValue <= 0 && maxValue >= 0) return 0;
		if (maxValue < 0) return maxValue;
		return minValue;
	}
	return domain[0];
};
var getStackedDataOfItem = function getStackedDataOfItem$1(item, stackGroups) {
	var _item$type3;
	var stackId = ((_item$type3 = item.type) !== null && _item$type3 !== void 0 && _item$type3.defaultProps ? _objectSpread$25(_objectSpread$25({}, item.type.defaultProps), item.props) : item.props).stackId;
	if (isNumOrStr(stackId)) {
		var group = stackGroups[stackId];
		if (group) {
			var itemIndex = group.items.indexOf(item);
			return itemIndex >= 0 ? group.stackedData[itemIndex] : null;
		}
	}
	return null;
};
var getDomainOfSingle = function getDomainOfSingle$1(data) {
	return data.reduce(function(result, entry) {
		return [(0, import_min.default)(entry.concat([result[0]]).filter(isNumber)), (0, import_max.default)(entry.concat([result[1]]).filter(isNumber))];
	}, [Infinity, -Infinity]);
};
var getDomainOfStackGroups = function getDomainOfStackGroups$1(stackGroups, startIndex, endIndex) {
	return Object.keys(stackGroups).reduce(function(result, stackId) {
		var domain = stackGroups[stackId].stackedData.reduce(function(res, entry) {
			var s$1 = getDomainOfSingle(entry.slice(startIndex, endIndex + 1));
			return [Math.min(res[0], s$1[0]), Math.max(res[1], s$1[1])];
		}, [Infinity, -Infinity]);
		return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];
	}, [Infinity, -Infinity]).map(function(result) {
		return result === Infinity || result === -Infinity ? 0 : result;
	});
};
var MIN_VALUE_REG = /^dataMin[\s]*-[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;
var MAX_VALUE_REG = /^dataMax[\s]*\+[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;
var parseSpecifiedDomain = function parseSpecifiedDomain$1(specifiedDomain, dataDomain, allowDataOverflow) {
	if ((0, import_isFunction$13.default)(specifiedDomain)) return specifiedDomain(dataDomain, allowDataOverflow);
	if (!Array.isArray(specifiedDomain)) return dataDomain;
	var domain = [];
	if (isNumber(specifiedDomain[0])) domain[0] = allowDataOverflow ? specifiedDomain[0] : Math.min(specifiedDomain[0], dataDomain[0]);
	else if (MIN_VALUE_REG.test(specifiedDomain[0])) {
		var value = +MIN_VALUE_REG.exec(specifiedDomain[0])[1];
		domain[0] = dataDomain[0] - value;
	} else if ((0, import_isFunction$13.default)(specifiedDomain[0])) domain[0] = specifiedDomain[0](dataDomain[0]);
	else domain[0] = dataDomain[0];
	if (isNumber(specifiedDomain[1])) domain[1] = allowDataOverflow ? specifiedDomain[1] : Math.max(specifiedDomain[1], dataDomain[1]);
	else if (MAX_VALUE_REG.test(specifiedDomain[1])) {
		var _value = +MAX_VALUE_REG.exec(specifiedDomain[1])[1];
		domain[1] = dataDomain[1] + _value;
	} else if ((0, import_isFunction$13.default)(specifiedDomain[1])) domain[1] = specifiedDomain[1](dataDomain[1]);
	else domain[1] = dataDomain[1];
	return domain;
};
var getBandSizeOfAxis = function getBandSizeOfAxis$1(axis, ticks$1, isBar) {
	if (axis && axis.scale && axis.scale.bandwidth) {
		var bandWidth = axis.scale.bandwidth();
		if (!isBar || bandWidth > 0) return bandWidth;
	}
	if (axis && ticks$1 && ticks$1.length >= 2) {
		var orderedTicks = (0, import_sortBy$1.default)(ticks$1, function(o) {
			return o.coordinate;
		});
		var bandSize = Infinity;
		for (var i = 1, len = orderedTicks.length; i < len; i++) {
			var cur = orderedTicks[i];
			var prev = orderedTicks[i - 1];
			bandSize = Math.min((cur.coordinate || 0) - (prev.coordinate || 0), bandSize);
		}
		return bandSize === Infinity ? 0 : bandSize;
	}
	return isBar ? void 0 : 0;
};
var parseDomainOfCategoryAxis = function parseDomainOfCategoryAxis$1(specifiedDomain, calculatedDomain, axisChild) {
	if (!specifiedDomain || !specifiedDomain.length) return calculatedDomain;
	if ((0, import_isEqual$2.default)(specifiedDomain, (0, import_get$2.default)(axisChild, "type.defaultProps.domain"))) return calculatedDomain;
	return specifiedDomain;
};
var getTooltipItem = function getTooltipItem$1(graphicalItem, payload) {
	var defaultedProps = graphicalItem.type.defaultProps ? _objectSpread$25(_objectSpread$25({}, graphicalItem.type.defaultProps), graphicalItem.props) : graphicalItem.props;
	var dataKey = defaultedProps.dataKey, name = defaultedProps.name, unit$1 = defaultedProps.unit, formatter = defaultedProps.formatter, tooltipType = defaultedProps.tooltipType, chartType = defaultedProps.chartType, hide = defaultedProps.hide;
	return _objectSpread$25(_objectSpread$25({}, filterProps(graphicalItem, false)), {}, {
		dataKey,
		unit: unit$1,
		formatter,
		name: name || dataKey,
		color: getMainColorOfGraphicItem(graphicalItem),
		value: getValueByDataKey(payload, dataKey),
		type: tooltipType,
		payload,
		chartType,
		hide
	});
};
require_isNil();
require_isFunction();
function _typeof$29(o) {
	"@babel/helpers - typeof";
	return _typeof$29 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$29(o);
}
function ownKeys$24(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$24(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$24(Object(t), !0).forEach(function(r$1) {
			_defineProperty$27(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$24(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}
function _defineProperty$27(obj, key, value) {
	key = _toPropertyKey$27(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$27(t) {
	var i = _toPrimitive$27(t, "string");
	return "symbol" == _typeof$29(i) ? i : i + "";
}
function _toPrimitive$27(t, r) {
	if ("object" != _typeof$29(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$29(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
var RADIAN = Math.PI / 180;
var radianToDegree = function radianToDegree$1(angleInRadian) {
	return angleInRadian * 180 / Math.PI;
};
var polarToCartesian = function polarToCartesian$1(cx, cy, radius, angle) {
	return {
		x: cx + Math.cos(-RADIAN * angle) * radius,
		y: cy + Math.sin(-RADIAN * angle) * radius
	};
};
var distanceBetweenPoints = function distanceBetweenPoints$1(point$3, anotherPoint) {
	var x1 = point$3.x, y1 = point$3.y;
	var x2 = anotherPoint.x, y2 = anotherPoint.y;
	return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
};
var getAngleOfPoint = function getAngleOfPoint$1(_ref, _ref2) {
	var x$1 = _ref.x, y$1 = _ref.y;
	var cx = _ref2.cx, cy = _ref2.cy;
	var radius = distanceBetweenPoints({
		x: x$1,
		y: y$1
	}, {
		x: cx,
		y: cy
	});
	if (radius <= 0) return { radius };
	var cos$1 = (x$1 - cx) / radius;
	var angleInRadian = Math.acos(cos$1);
	if (y$1 > cy) angleInRadian = 2 * Math.PI - angleInRadian;
	return {
		radius,
		angle: radianToDegree(angleInRadian),
		angleInRadian
	};
};
var formatAngleOfSector = function formatAngleOfSector$1(_ref3) {
	var startAngle = _ref3.startAngle, endAngle = _ref3.endAngle;
	var startCnt = Math.floor(startAngle / 360);
	var endCnt = Math.floor(endAngle / 360);
	var min$3 = Math.min(startCnt, endCnt);
	return {
		startAngle: startAngle - min$3 * 360,
		endAngle: endAngle - min$3 * 360
	};
};
var reverseFormatAngleOfSetor = function reverseFormatAngleOfSetor$1(angle, _ref4) {
	var startAngle = _ref4.startAngle, endAngle = _ref4.endAngle;
	var startCnt = Math.floor(startAngle / 360);
	var endCnt = Math.floor(endAngle / 360);
	return angle + Math.min(startCnt, endCnt) * 360;
};
var inRangeOfSector = function inRangeOfSector$1(_ref5, sector) {
	var x$1 = _ref5.x, y$1 = _ref5.y;
	var _getAngleOfPoint = getAngleOfPoint({
		x: x$1,
		y: y$1
	}, sector), radius = _getAngleOfPoint.radius, angle = _getAngleOfPoint.angle;
	var innerRadius = sector.innerRadius, outerRadius = sector.outerRadius;
	if (radius < innerRadius || radius > outerRadius) return false;
	if (radius === 0) return true;
	var _formatAngleOfSector = formatAngleOfSector(sector), startAngle = _formatAngleOfSector.startAngle, endAngle = _formatAngleOfSector.endAngle;
	var formatAngle = angle;
	var inRange;
	if (startAngle <= endAngle) {
		while (formatAngle > endAngle) formatAngle -= 360;
		while (formatAngle < startAngle) formatAngle += 360;
		inRange = formatAngle >= startAngle && formatAngle <= endAngle;
	} else {
		while (formatAngle > startAngle) formatAngle -= 360;
		while (formatAngle < endAngle) formatAngle += 360;
		inRange = formatAngle >= endAngle && formatAngle <= startAngle;
	}
	if (inRange) return _objectSpread$24(_objectSpread$24({}, sector), {}, {
		radius,
		angle: reverseFormatAngleOfSetor(formatAngle, sector)
	});
	return null;
};
var import_isNil$3 = /* @__PURE__ */ __toESM(require_isNil());
var import_isFunction$11 = /* @__PURE__ */ __toESM(require_isFunction());
var import_isObject$1 = /* @__PURE__ */ __toESM(require_isObject());
function _typeof$28(o) {
	"@babel/helpers - typeof";
	return _typeof$28 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$28(o);
}
var _excluded$9 = ["offset"];
function _toConsumableArray$6(arr) {
	return _arrayWithoutHoles$6(arr) || _iterableToArray$7(arr) || _unsupportedIterableToArray$10(arr) || _nonIterableSpread$6();
}
function _nonIterableSpread$6() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$10(o, minLen) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$10(o, minLen);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$10(o, minLen);
}
function _iterableToArray$7(iter) {
	if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$6(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray$10(arr);
}
function _arrayLikeToArray$10(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _objectWithoutProperties$9(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$9(source, excluded);
	var key, i;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i = 0; i < sourceSymbolKeys.length; i++) {
			key = sourceSymbolKeys[i];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$9(source, excluded) {
	if (source == null) return {};
	var target = {};
	for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function ownKeys$23(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$23(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$23(Object(t), !0).forEach(function(r$1) {
			_defineProperty$26(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$23(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}
function _defineProperty$26(obj, key, value) {
	key = _toPropertyKey$26(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$26(t) {
	var i = _toPrimitive$26(t, "string");
	return "symbol" == _typeof$28(i) ? i : i + "";
}
function _toPrimitive$26(t, r) {
	if ("object" != _typeof$28(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$28(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
function _extends$18() {
	_extends$18 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$18.apply(this, arguments);
}
var getLabel = function getLabel$1(props) {
	var value = props.value, formatter = props.formatter;
	var label = (0, import_isNil$3.default)(props.children) ? value : props.children;
	if ((0, import_isFunction$11.default)(formatter)) return formatter(label);
	return label;
};
var getDeltaAngle$1 = function getDeltaAngle$2(startAngle, endAngle) {
	return mathSign(endAngle - startAngle) * Math.min(Math.abs(endAngle - startAngle), 360);
};
var renderRadialLabel = function renderRadialLabel$1(labelProps, label, attrs) {
	var position = labelProps.position, viewBox = labelProps.viewBox, offset = labelProps.offset, className = labelProps.className;
	var _ref = viewBox, cx = _ref.cx, cy = _ref.cy, innerRadius = _ref.innerRadius, outerRadius = _ref.outerRadius, startAngle = _ref.startAngle, endAngle = _ref.endAngle, clockWise = _ref.clockWise;
	var radius = (innerRadius + outerRadius) / 2;
	var deltaAngle = getDeltaAngle$1(startAngle, endAngle);
	var sign$1 = deltaAngle >= 0 ? 1 : -1;
	var labelAngle, direction;
	if (position === "insideStart") {
		labelAngle = startAngle + sign$1 * offset;
		direction = clockWise;
	} else if (position === "insideEnd") {
		labelAngle = endAngle - sign$1 * offset;
		direction = !clockWise;
	} else if (position === "end") {
		labelAngle = endAngle + sign$1 * offset;
		direction = clockWise;
	}
	direction = deltaAngle <= 0 ? direction : !direction;
	var startPoint = polarToCartesian(cx, cy, radius, labelAngle);
	var endPoint = polarToCartesian(cx, cy, radius, labelAngle + (direction ? 1 : -1) * 359);
	var path$1 = "M".concat(startPoint.x, ",").concat(startPoint.y, "\n    A").concat(radius, ",").concat(radius, ",0,1,").concat(direction ? 0 : 1, ",\n    ").concat(endPoint.x, ",").concat(endPoint.y);
	var id = (0, import_isNil$3.default)(labelProps.id) ? uniqueId("recharts-radial-line-") : labelProps.id;
	return /* @__PURE__ */ import_react.createElement("text", _extends$18({}, attrs, {
		dominantBaseline: "central",
		className: clsx_default("recharts-radial-bar-label", className)
	}), /* @__PURE__ */ import_react.createElement("defs", null, /* @__PURE__ */ import_react.createElement("path", {
		id,
		d: path$1
	})), /* @__PURE__ */ import_react.createElement("textPath", { xlinkHref: "#".concat(id) }, label));
};
var getAttrsOfPolarLabel = function getAttrsOfPolarLabel$1(props) {
	var viewBox = props.viewBox, offset = props.offset, position = props.position;
	var _ref2 = viewBox, cx = _ref2.cx, cy = _ref2.cy, innerRadius = _ref2.innerRadius, outerRadius = _ref2.outerRadius;
	var midAngle = (_ref2.startAngle + _ref2.endAngle) / 2;
	if (position === "outside") {
		var _polarToCartesian = polarToCartesian(cx, cy, outerRadius + offset, midAngle), _x = _polarToCartesian.x;
		return {
			x: _x,
			y: _polarToCartesian.y,
			textAnchor: _x >= cx ? "start" : "end",
			verticalAnchor: "middle"
		};
	}
	if (position === "center") return {
		x: cx,
		y: cy,
		textAnchor: "middle",
		verticalAnchor: "middle"
	};
	if (position === "centerTop") return {
		x: cx,
		y: cy,
		textAnchor: "middle",
		verticalAnchor: "start"
	};
	if (position === "centerBottom") return {
		x: cx,
		y: cy,
		textAnchor: "middle",
		verticalAnchor: "end"
	};
	var _polarToCartesian2 = polarToCartesian(cx, cy, (innerRadius + outerRadius) / 2, midAngle);
	return {
		x: _polarToCartesian2.x,
		y: _polarToCartesian2.y,
		textAnchor: "middle",
		verticalAnchor: "middle"
	};
};
var getAttrsOfCartesianLabel = function getAttrsOfCartesianLabel$1(props) {
	var viewBox = props.viewBox, parentViewBox = props.parentViewBox, offset = props.offset, position = props.position;
	var _ref3 = viewBox, x$1 = _ref3.x, y$1 = _ref3.y, width = _ref3.width, height = _ref3.height;
	var verticalSign = height >= 0 ? 1 : -1;
	var verticalOffset = verticalSign * offset;
	var verticalEnd = verticalSign > 0 ? "end" : "start";
	var verticalStart = verticalSign > 0 ? "start" : "end";
	var horizontalSign = width >= 0 ? 1 : -1;
	var horizontalOffset = horizontalSign * offset;
	var horizontalEnd = horizontalSign > 0 ? "end" : "start";
	var horizontalStart = horizontalSign > 0 ? "start" : "end";
	if (position === "top") return _objectSpread$23(_objectSpread$23({}, {
		x: x$1 + width / 2,
		y: y$1 - verticalSign * offset,
		textAnchor: "middle",
		verticalAnchor: verticalEnd
	}), parentViewBox ? {
		height: Math.max(y$1 - parentViewBox.y, 0),
		width
	} : {});
	if (position === "bottom") return _objectSpread$23(_objectSpread$23({}, {
		x: x$1 + width / 2,
		y: y$1 + height + verticalOffset,
		textAnchor: "middle",
		verticalAnchor: verticalStart
	}), parentViewBox ? {
		height: Math.max(parentViewBox.y + parentViewBox.height - (y$1 + height), 0),
		width
	} : {});
	if (position === "left") {
		var _attrs2 = {
			x: x$1 - horizontalOffset,
			y: y$1 + height / 2,
			textAnchor: horizontalEnd,
			verticalAnchor: "middle"
		};
		return _objectSpread$23(_objectSpread$23({}, _attrs2), parentViewBox ? {
			width: Math.max(_attrs2.x - parentViewBox.x, 0),
			height
		} : {});
	}
	if (position === "right") {
		var _attrs3 = {
			x: x$1 + width + horizontalOffset,
			y: y$1 + height / 2,
			textAnchor: horizontalStart,
			verticalAnchor: "middle"
		};
		return _objectSpread$23(_objectSpread$23({}, _attrs3), parentViewBox ? {
			width: Math.max(parentViewBox.x + parentViewBox.width - _attrs3.x, 0),
			height
		} : {});
	}
	var sizeAttrs = parentViewBox ? {
		width,
		height
	} : {};
	if (position === "insideLeft") return _objectSpread$23({
		x: x$1 + horizontalOffset,
		y: y$1 + height / 2,
		textAnchor: horizontalStart,
		verticalAnchor: "middle"
	}, sizeAttrs);
	if (position === "insideRight") return _objectSpread$23({
		x: x$1 + width - horizontalOffset,
		y: y$1 + height / 2,
		textAnchor: horizontalEnd,
		verticalAnchor: "middle"
	}, sizeAttrs);
	if (position === "insideTop") return _objectSpread$23({
		x: x$1 + width / 2,
		y: y$1 + verticalOffset,
		textAnchor: "middle",
		verticalAnchor: verticalStart
	}, sizeAttrs);
	if (position === "insideBottom") return _objectSpread$23({
		x: x$1 + width / 2,
		y: y$1 + height - verticalOffset,
		textAnchor: "middle",
		verticalAnchor: verticalEnd
	}, sizeAttrs);
	if (position === "insideTopLeft") return _objectSpread$23({
		x: x$1 + horizontalOffset,
		y: y$1 + verticalOffset,
		textAnchor: horizontalStart,
		verticalAnchor: verticalStart
	}, sizeAttrs);
	if (position === "insideTopRight") return _objectSpread$23({
		x: x$1 + width - horizontalOffset,
		y: y$1 + verticalOffset,
		textAnchor: horizontalEnd,
		verticalAnchor: verticalStart
	}, sizeAttrs);
	if (position === "insideBottomLeft") return _objectSpread$23({
		x: x$1 + horizontalOffset,
		y: y$1 + height - verticalOffset,
		textAnchor: horizontalStart,
		verticalAnchor: verticalEnd
	}, sizeAttrs);
	if (position === "insideBottomRight") return _objectSpread$23({
		x: x$1 + width - horizontalOffset,
		y: y$1 + height - verticalOffset,
		textAnchor: horizontalEnd,
		verticalAnchor: verticalEnd
	}, sizeAttrs);
	if ((0, import_isObject$1.default)(position) && (isNumber(position.x) || isPercent(position.x)) && (isNumber(position.y) || isPercent(position.y))) return _objectSpread$23({
		x: x$1 + getPercentValue(position.x, width),
		y: y$1 + getPercentValue(position.y, height),
		textAnchor: "end",
		verticalAnchor: "end"
	}, sizeAttrs);
	return _objectSpread$23({
		x: x$1 + width / 2,
		y: y$1 + height / 2,
		textAnchor: "middle",
		verticalAnchor: "middle"
	}, sizeAttrs);
};
var isPolar = function isPolar$1(viewBox) {
	return "cx" in viewBox && isNumber(viewBox.cx);
};
function Label(_ref4) {
	var _ref4$offset = _ref4.offset, offset = _ref4$offset === void 0 ? 5 : _ref4$offset, restProps = _objectWithoutProperties$9(_ref4, _excluded$9);
	var props = _objectSpread$23({ offset }, restProps);
	var viewBox = props.viewBox, position = props.position, value = props.value, children = props.children, content = props.content, _props$className = props.className, className = _props$className === void 0 ? "" : _props$className, textBreakAll = props.textBreakAll;
	if (!viewBox || (0, import_isNil$3.default)(value) && (0, import_isNil$3.default)(children) && !/* @__PURE__ */ (0, import_react.isValidElement)(content) && !(0, import_isFunction$11.default)(content)) return null;
	if (/* @__PURE__ */ (0, import_react.isValidElement)(content)) return /* @__PURE__ */ (0, import_react.cloneElement)(content, props);
	var label;
	if ((0, import_isFunction$11.default)(content)) {
		label = /* @__PURE__ */ (0, import_react.createElement)(content, props);
		if (/* @__PURE__ */ (0, import_react.isValidElement)(label)) return label;
	} else label = getLabel(props);
	var isPolarLabel = isPolar(viewBox);
	var attrs = filterProps(props, true);
	if (isPolarLabel && (position === "insideStart" || position === "insideEnd" || position === "end")) return renderRadialLabel(props, label, attrs);
	var positionAttrs = isPolarLabel ? getAttrsOfPolarLabel(props) : getAttrsOfCartesianLabel(props);
	return /* @__PURE__ */ import_react.createElement(Text, _extends$18({ className: clsx_default("recharts-label", className) }, attrs, positionAttrs, { breakAll: textBreakAll }), label);
}
Label.displayName = "Label";
var parseViewBox = function parseViewBox$1(props) {
	var cx = props.cx, cy = props.cy, angle = props.angle, startAngle = props.startAngle, endAngle = props.endAngle, r = props.r, radius = props.radius, innerRadius = props.innerRadius, outerRadius = props.outerRadius, x$1 = props.x, y$1 = props.y, top = props.top, left = props.left, width = props.width, height = props.height, clockWise = props.clockWise, labelViewBox = props.labelViewBox;
	if (labelViewBox) return labelViewBox;
	if (isNumber(width) && isNumber(height)) {
		if (isNumber(x$1) && isNumber(y$1)) return {
			x: x$1,
			y: y$1,
			width,
			height
		};
		if (isNumber(top) && isNumber(left)) return {
			x: top,
			y: left,
			width,
			height
		};
	}
	if (isNumber(x$1) && isNumber(y$1)) return {
		x: x$1,
		y: y$1,
		width: 0,
		height: 0
	};
	if (isNumber(cx) && isNumber(cy)) return {
		cx,
		cy,
		startAngle: startAngle || angle || 0,
		endAngle: endAngle || angle || 0,
		innerRadius: innerRadius || 0,
		outerRadius: outerRadius || radius || r || 0,
		clockWise
	};
	if (props.viewBox) return props.viewBox;
	return {};
};
var parseLabel = function parseLabel$1(label, viewBox) {
	if (!label) return null;
	if (label === true) return /* @__PURE__ */ import_react.createElement(Label, {
		key: "label-implicit",
		viewBox
	});
	if (isNumOrStr(label)) return /* @__PURE__ */ import_react.createElement(Label, {
		key: "label-implicit",
		viewBox,
		value: label
	});
	if (/* @__PURE__ */ (0, import_react.isValidElement)(label)) {
		if (label.type === Label) return /* @__PURE__ */ (0, import_react.cloneElement)(label, {
			key: "label-implicit",
			viewBox
		});
		return /* @__PURE__ */ import_react.createElement(Label, {
			key: "label-implicit",
			content: label,
			viewBox
		});
	}
	if ((0, import_isFunction$11.default)(label)) return /* @__PURE__ */ import_react.createElement(Label, {
		key: "label-implicit",
		content: label,
		viewBox
	});
	if ((0, import_isObject$1.default)(label)) return /* @__PURE__ */ import_react.createElement(Label, _extends$18({ viewBox }, label, { key: "label-implicit" }));
	return null;
};
var renderCallByParent$1 = function renderCallByParent$2(parentProps, viewBox) {
	var checkPropsLabel = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
	if (!parentProps || !parentProps.children && checkPropsLabel && !parentProps.label) return null;
	var children = parentProps.children;
	var parentViewBox = parseViewBox(parentProps);
	var explicitChildren = findAllByType(children, Label).map(function(child, index) {
		return /* @__PURE__ */ (0, import_react.cloneElement)(child, {
			viewBox: viewBox || parentViewBox,
			key: "label-".concat(index)
		});
	});
	if (!checkPropsLabel) return explicitChildren;
	return [parseLabel(parentProps.label, viewBox || parentViewBox)].concat(_toConsumableArray$6(explicitChildren));
};
Label.parseViewBox = parseViewBox;
Label.renderCallByParent = renderCallByParent$1;
var require_last = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function last$1(array) {
		var length = array == null ? 0 : array.length;
		return length ? array[length - 1] : void 0;
	}
	module.exports = last$1;
}));
var import_isNil$2 = /* @__PURE__ */ __toESM(require_isNil());
var import_isObject = /* @__PURE__ */ __toESM(require_isObject());
var import_isFunction$10 = /* @__PURE__ */ __toESM(require_isFunction());
var import_last = /* @__PURE__ */ __toESM(require_last());
function _typeof$27(o) {
	"@babel/helpers - typeof";
	return _typeof$27 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$27(o);
}
var _excluded$8 = ["valueAccessor"], _excluded2$3 = [
	"data",
	"dataKey",
	"clockWise",
	"id",
	"textBreakAll"
];
function _toConsumableArray$5(arr) {
	return _arrayWithoutHoles$5(arr) || _iterableToArray$6(arr) || _unsupportedIterableToArray$9(arr) || _nonIterableSpread$5();
}
function _nonIterableSpread$5() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$9(o, minLen) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$9(o, minLen);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$9(o, minLen);
}
function _iterableToArray$6(iter) {
	if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$5(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray$9(arr);
}
function _arrayLikeToArray$9(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _extends$17() {
	_extends$17 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$17.apply(this, arguments);
}
function ownKeys$22(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$22(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$22(Object(t), !0).forEach(function(r$1) {
			_defineProperty$25(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$22(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}
function _defineProperty$25(obj, key, value) {
	key = _toPropertyKey$25(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$25(t) {
	var i = _toPrimitive$25(t, "string");
	return "symbol" == _typeof$27(i) ? i : i + "";
}
function _toPrimitive$25(t, r) {
	if ("object" != _typeof$27(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$27(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
function _objectWithoutProperties$8(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$8(source, excluded);
	var key, i;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i = 0; i < sourceSymbolKeys.length; i++) {
			key = sourceSymbolKeys[i];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$8(source, excluded) {
	if (source == null) return {};
	var target = {};
	for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
var defaultAccessor = function defaultAccessor$1(entry) {
	return Array.isArray(entry.value) ? (0, import_last.default)(entry.value) : entry.value;
};
function LabelList(_ref) {
	var _ref$valueAccessor = _ref.valueAccessor, valueAccessor = _ref$valueAccessor === void 0 ? defaultAccessor : _ref$valueAccessor, restProps = _objectWithoutProperties$8(_ref, _excluded$8);
	var data = restProps.data, dataKey = restProps.dataKey, clockWise = restProps.clockWise, id = restProps.id, textBreakAll = restProps.textBreakAll, others = _objectWithoutProperties$8(restProps, _excluded2$3);
	if (!data || !data.length) return null;
	return /* @__PURE__ */ import_react.createElement(Layer, { className: "recharts-label-list" }, data.map(function(entry, index) {
		var value = (0, import_isNil$2.default)(dataKey) ? valueAccessor(entry, index) : getValueByDataKey(entry && entry.payload, dataKey);
		var idProps = (0, import_isNil$2.default)(id) ? {} : { id: "".concat(id, "-").concat(index) };
		return /* @__PURE__ */ import_react.createElement(Label, _extends$17({}, filterProps(entry, true), others, idProps, {
			parentViewBox: entry.parentViewBox,
			value,
			textBreakAll,
			viewBox: Label.parseViewBox((0, import_isNil$2.default)(clockWise) ? entry : _objectSpread$22(_objectSpread$22({}, entry), {}, { clockWise })),
			key: "label-".concat(index),
			index
		}));
	}));
}
LabelList.displayName = "LabelList";
function parseLabelList(label, data) {
	if (!label) return null;
	if (label === true) return /* @__PURE__ */ import_react.createElement(LabelList, {
		key: "labelList-implicit",
		data
	});
	if (/* @__PURE__ */ import_react.isValidElement(label) || (0, import_isFunction$10.default)(label)) return /* @__PURE__ */ import_react.createElement(LabelList, {
		key: "labelList-implicit",
		data,
		content: label
	});
	if ((0, import_isObject.default)(label)) return /* @__PURE__ */ import_react.createElement(LabelList, _extends$17({ data }, label, { key: "labelList-implicit" }));
	return null;
}
function renderCallByParent(parentProps, data) {
	var checkPropsLabel = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
	if (!parentProps || !parentProps.children && checkPropsLabel && !parentProps.label) return null;
	var children = parentProps.children;
	var explicitChildren = findAllByType(children, LabelList).map(function(child, index) {
		return /* @__PURE__ */ (0, import_react.cloneElement)(child, {
			data,
			key: "labelList-".concat(index)
		});
	});
	if (!checkPropsLabel) return explicitChildren;
	return [parseLabelList(parentProps.label, data)].concat(_toConsumableArray$5(explicitChildren));
}
LabelList.renderCallByParent = renderCallByParent;
function _typeof$26(o) {
	"@babel/helpers - typeof";
	return _typeof$26 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$26(o);
}
function _extends$16() {
	_extends$16 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$16.apply(this, arguments);
}
function ownKeys$21(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$21(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$21(Object(t), !0).forEach(function(r$1) {
			_defineProperty$24(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$21(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}
function _defineProperty$24(obj, key, value) {
	key = _toPropertyKey$24(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$24(t) {
	var i = _toPrimitive$24(t, "string");
	return "symbol" == _typeof$26(i) ? i : i + "";
}
function _toPrimitive$24(t, r) {
	if ("object" != _typeof$26(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$26(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
var getDeltaAngle = function getDeltaAngle$2(startAngle, endAngle) {
	return mathSign(endAngle - startAngle) * Math.min(Math.abs(endAngle - startAngle), 359.999);
};
var getTangentCircle = function getTangentCircle$1(_ref) {
	var cx = _ref.cx, cy = _ref.cy, radius = _ref.radius, angle = _ref.angle, sign$1 = _ref.sign, isExternal = _ref.isExternal, cornerRadius = _ref.cornerRadius, cornerIsExternal = _ref.cornerIsExternal;
	var centerRadius = cornerRadius * (isExternal ? 1 : -1) + radius;
	var theta = Math.asin(cornerRadius / centerRadius) / RADIAN;
	var centerAngle = cornerIsExternal ? angle : angle + sign$1 * theta;
	var center = polarToCartesian(cx, cy, centerRadius, centerAngle);
	var circleTangency = polarToCartesian(cx, cy, radius, centerAngle);
	var lineTangencyAngle = cornerIsExternal ? angle - sign$1 * theta : angle;
	return {
		center,
		circleTangency,
		lineTangency: polarToCartesian(cx, cy, centerRadius * Math.cos(theta * RADIAN), lineTangencyAngle),
		theta
	};
};
var getSectorPath = function getSectorPath$1(_ref2) {
	var cx = _ref2.cx, cy = _ref2.cy, innerRadius = _ref2.innerRadius, outerRadius = _ref2.outerRadius, startAngle = _ref2.startAngle, endAngle = _ref2.endAngle;
	var angle = getDeltaAngle(startAngle, endAngle);
	var tempEndAngle = startAngle + angle;
	var outerStartPoint = polarToCartesian(cx, cy, outerRadius, startAngle);
	var outerEndPoint = polarToCartesian(cx, cy, outerRadius, tempEndAngle);
	var path$1 = "M ".concat(outerStartPoint.x, ",").concat(outerStartPoint.y, "\n    A ").concat(outerRadius, ",").concat(outerRadius, ",0,\n    ").concat(+(Math.abs(angle) > 180), ",").concat(+(startAngle > tempEndAngle), ",\n    ").concat(outerEndPoint.x, ",").concat(outerEndPoint.y, "\n  ");
	if (innerRadius > 0) {
		var innerStartPoint = polarToCartesian(cx, cy, innerRadius, startAngle);
		var innerEndPoint = polarToCartesian(cx, cy, innerRadius, tempEndAngle);
		path$1 += "L ".concat(innerEndPoint.x, ",").concat(innerEndPoint.y, "\n            A ").concat(innerRadius, ",").concat(innerRadius, ",0,\n            ").concat(+(Math.abs(angle) > 180), ",").concat(+(startAngle <= tempEndAngle), ",\n            ").concat(innerStartPoint.x, ",").concat(innerStartPoint.y, " Z");
	} else path$1 += "L ".concat(cx, ",").concat(cy, " Z");
	return path$1;
};
var getSectorWithCorner = function getSectorWithCorner$1(_ref3) {
	var cx = _ref3.cx, cy = _ref3.cy, innerRadius = _ref3.innerRadius, outerRadius = _ref3.outerRadius, cornerRadius = _ref3.cornerRadius, forceCornerRadius = _ref3.forceCornerRadius, cornerIsExternal = _ref3.cornerIsExternal, startAngle = _ref3.startAngle, endAngle = _ref3.endAngle;
	var sign$1 = mathSign(endAngle - startAngle);
	var _getTangentCircle = getTangentCircle({
		cx,
		cy,
		radius: outerRadius,
		angle: startAngle,
		sign: sign$1,
		cornerRadius,
		cornerIsExternal
	}), soct = _getTangentCircle.circleTangency, solt = _getTangentCircle.lineTangency, sot = _getTangentCircle.theta;
	var _getTangentCircle2 = getTangentCircle({
		cx,
		cy,
		radius: outerRadius,
		angle: endAngle,
		sign: -sign$1,
		cornerRadius,
		cornerIsExternal
	}), eoct = _getTangentCircle2.circleTangency, eolt = _getTangentCircle2.lineTangency, eot = _getTangentCircle2.theta;
	var outerArcAngle = cornerIsExternal ? Math.abs(startAngle - endAngle) : Math.abs(startAngle - endAngle) - sot - eot;
	if (outerArcAngle < 0) {
		if (forceCornerRadius) return "M ".concat(solt.x, ",").concat(solt.y, "\n        a").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,1,").concat(cornerRadius * 2, ",0\n        a").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,1,").concat(-cornerRadius * 2, ",0\n      ");
		return getSectorPath({
			cx,
			cy,
			innerRadius,
			outerRadius,
			startAngle,
			endAngle
		});
	}
	var path$1 = "M ".concat(solt.x, ",").concat(solt.y, "\n    A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign$1 < 0), ",").concat(soct.x, ",").concat(soct.y, "\n    A").concat(outerRadius, ",").concat(outerRadius, ",0,").concat(+(outerArcAngle > 180), ",").concat(+(sign$1 < 0), ",").concat(eoct.x, ",").concat(eoct.y, "\n    A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign$1 < 0), ",").concat(eolt.x, ",").concat(eolt.y, "\n  ");
	if (innerRadius > 0) {
		var _getTangentCircle3 = getTangentCircle({
			cx,
			cy,
			radius: innerRadius,
			angle: startAngle,
			sign: sign$1,
			isExternal: true,
			cornerRadius,
			cornerIsExternal
		}), sict = _getTangentCircle3.circleTangency, silt = _getTangentCircle3.lineTangency, sit = _getTangentCircle3.theta;
		var _getTangentCircle4 = getTangentCircle({
			cx,
			cy,
			radius: innerRadius,
			angle: endAngle,
			sign: -sign$1,
			isExternal: true,
			cornerRadius,
			cornerIsExternal
		}), eict = _getTangentCircle4.circleTangency, eilt = _getTangentCircle4.lineTangency, eit = _getTangentCircle4.theta;
		var innerArcAngle = cornerIsExternal ? Math.abs(startAngle - endAngle) : Math.abs(startAngle - endAngle) - sit - eit;
		if (innerArcAngle < 0 && cornerRadius === 0) return "".concat(path$1, "L").concat(cx, ",").concat(cy, "Z");
		path$1 += "L".concat(eilt.x, ",").concat(eilt.y, "\n      A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign$1 < 0), ",").concat(eict.x, ",").concat(eict.y, "\n      A").concat(innerRadius, ",").concat(innerRadius, ",0,").concat(+(innerArcAngle > 180), ",").concat(+(sign$1 > 0), ",").concat(sict.x, ",").concat(sict.y, "\n      A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign$1 < 0), ",").concat(silt.x, ",").concat(silt.y, "Z");
	} else path$1 += "L".concat(cx, ",").concat(cy, "Z");
	return path$1;
};
var defaultProps$3 = {
	cx: 0,
	cy: 0,
	innerRadius: 0,
	outerRadius: 0,
	startAngle: 0,
	endAngle: 0,
	cornerRadius: 0,
	forceCornerRadius: false,
	cornerIsExternal: false
};
var Sector = function Sector$1(sectorProps) {
	var props = _objectSpread$21(_objectSpread$21({}, defaultProps$3), sectorProps);
	var cx = props.cx, cy = props.cy, innerRadius = props.innerRadius, outerRadius = props.outerRadius, cornerRadius = props.cornerRadius, forceCornerRadius = props.forceCornerRadius, cornerIsExternal = props.cornerIsExternal, startAngle = props.startAngle, endAngle = props.endAngle, className = props.className;
	if (outerRadius < innerRadius || startAngle === endAngle) return null;
	var layerClass = clsx_default("recharts-sector", className);
	var deltaRadius = outerRadius - innerRadius;
	var cr = getPercentValue(cornerRadius, deltaRadius, 0, true);
	var path$1;
	if (cr > 0 && Math.abs(startAngle - endAngle) < 360) path$1 = getSectorWithCorner({
		cx,
		cy,
		innerRadius,
		outerRadius,
		cornerRadius: Math.min(cr, deltaRadius / 2),
		forceCornerRadius,
		cornerIsExternal,
		startAngle,
		endAngle
	});
	else path$1 = getSectorPath({
		cx,
		cy,
		innerRadius,
		outerRadius,
		startAngle,
		endAngle
	});
	return /* @__PURE__ */ import_react.createElement("path", _extends$16({}, filterProps(props, true), {
		className: layerClass,
		d: path$1,
		role: "img"
	}));
};
var import_upperFirst = /* @__PURE__ */ __toESM(require_upperFirst());
var import_isFunction$9 = /* @__PURE__ */ __toESM(require_isFunction());
function _typeof$25(o) {
	"@babel/helpers - typeof";
	return _typeof$25 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$25(o);
}
function _extends$15() {
	_extends$15 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$15.apply(this, arguments);
}
function ownKeys$20(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$20(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$20(Object(t), !0).forEach(function(r$1) {
			_defineProperty$23(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$20(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}
function _defineProperty$23(obj, key, value) {
	key = _toPropertyKey$23(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$23(t) {
	var i = _toPrimitive$23(t, "string");
	return "symbol" == _typeof$25(i) ? i : i + "";
}
function _toPrimitive$23(t, r) {
	if ("object" != _typeof$25(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$25(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
var CURVE_FACTORIES = {
	curveBasisClosed: basisClosed_default,
	curveBasisOpen: basisOpen_default,
	curveBasis: basis_default,
	curveBumpX: bumpX,
	curveBumpY: bumpY,
	curveLinearClosed: linearClosed_default,
	curveLinear: linear_default,
	curveMonotoneX: monotoneX,
	curveMonotoneY: monotoneY,
	curveNatural: natural_default,
	curveStep: step_default,
	curveStepAfter: stepAfter,
	curveStepBefore: stepBefore
};
var defined = function defined$1(p) {
	return p.x === +p.x && p.y === +p.y;
};
var getX = function getX$1(p) {
	return p.x;
};
var getY = function getY$1(p) {
	return p.y;
};
var getCurveFactory = function getCurveFactory$1(type, layout) {
	if ((0, import_isFunction$9.default)(type)) return type;
	var name = "curve".concat((0, import_upperFirst.default)(type));
	if ((name === "curveMonotone" || name === "curveBump") && layout) return CURVE_FACTORIES["".concat(name).concat(layout === "vertical" ? "Y" : "X")];
	return CURVE_FACTORIES[name] || linear_default;
};
var getPath$1 = function getPath$2(_ref) {
	var _ref$type = _ref.type, type = _ref$type === void 0 ? "linear" : _ref$type, _ref$points = _ref.points, points = _ref$points === void 0 ? [] : _ref$points, baseLine = _ref.baseLine, layout = _ref.layout, _ref$connectNulls = _ref.connectNulls, connectNulls = _ref$connectNulls === void 0 ? false : _ref$connectNulls;
	var curveFactory = getCurveFactory(type, layout);
	var formatPoints = connectNulls ? points.filter(function(entry) {
		return defined(entry);
	}) : points;
	var lineFunction;
	if (Array.isArray(baseLine)) {
		var formatBaseLine = connectNulls ? baseLine.filter(function(base) {
			return defined(base);
		}) : baseLine;
		var areaPoints = formatPoints.map(function(entry, index) {
			return _objectSpread$20(_objectSpread$20({}, entry), {}, { base: formatBaseLine[index] });
		});
		if (layout === "vertical") lineFunction = area_default().y(getY).x1(getX).x0(function(d) {
			return d.base.x;
		});
		else lineFunction = area_default().x(getX).y1(getY).y0(function(d) {
			return d.base.y;
		});
		lineFunction.defined(defined).curve(curveFactory);
		return lineFunction(areaPoints);
	}
	if (layout === "vertical" && isNumber(baseLine)) lineFunction = area_default().y(getY).x1(getX).x0(baseLine);
	else if (isNumber(baseLine)) lineFunction = area_default().x(getX).y1(getY).y0(baseLine);
	else lineFunction = line_default().x(getX).y(getY);
	lineFunction.defined(defined).curve(curveFactory);
	return lineFunction(formatPoints);
};
var Curve = function Curve$1(props) {
	var className = props.className, points = props.points, path$1 = props.path, pathRef = props.pathRef;
	if ((!points || !points.length) && !path$1) return null;
	var realPath = points && points.length ? getPath$1(props) : path$1;
	return /* @__PURE__ */ import_react.createElement("path", _extends$15({}, filterProps(props, false), adaptEventHandlers(props), {
		className: clsx_default("recharts-curve", className),
		d: realPath,
		ref: pathRef
	}));
};
/** @license React v16.13.1
* react-is.development.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var require_react_is_development = /* @__PURE__ */ __commonJSMin(((exports) => {
	(function() {
		"use strict";
		var hasSymbol = typeof Symbol === "function" && Symbol.for;
		var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
		var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
		var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
		var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
		var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
		var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
		var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
		var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
		var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
		var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
		var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
		var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
		var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
		var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
		var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
		var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
		var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
		var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
		function isValidElementType(type) {
			return typeof type === "string" || typeof type === "function" || type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
		}
		function typeOf(object) {
			if (typeof object === "object" && object !== null) {
				var $$typeof = object.$$typeof;
				switch ($$typeof) {
					case REACT_ELEMENT_TYPE:
						var type = object.type;
						switch (type) {
							case REACT_ASYNC_MODE_TYPE:
							case REACT_CONCURRENT_MODE_TYPE:
							case REACT_FRAGMENT_TYPE:
							case REACT_PROFILER_TYPE:
							case REACT_STRICT_MODE_TYPE:
							case REACT_SUSPENSE_TYPE: return type;
							default:
								var $$typeofType = type && type.$$typeof;
								switch ($$typeofType) {
									case REACT_CONTEXT_TYPE:
									case REACT_FORWARD_REF_TYPE:
									case REACT_LAZY_TYPE:
									case REACT_MEMO_TYPE:
									case REACT_PROVIDER_TYPE: return $$typeofType;
									default: return $$typeof;
								}
						}
					case REACT_PORTAL_TYPE: return $$typeof;
				}
			}
		}
		var AsyncMode = REACT_ASYNC_MODE_TYPE;
		var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
		var ContextConsumer = REACT_CONTEXT_TYPE;
		var ContextProvider = REACT_PROVIDER_TYPE;
		var Element = REACT_ELEMENT_TYPE;
		var ForwardRef = REACT_FORWARD_REF_TYPE;
		var Fragment = REACT_FRAGMENT_TYPE;
		var Lazy = REACT_LAZY_TYPE;
		var Memo = REACT_MEMO_TYPE;
		var Portal = REACT_PORTAL_TYPE;
		var Profiler = REACT_PROFILER_TYPE;
		var StrictMode = REACT_STRICT_MODE_TYPE;
		var Suspense = REACT_SUSPENSE_TYPE;
		var hasWarnedAboutDeprecatedIsAsyncMode = false;
		function isAsyncMode(object) {
			if (!hasWarnedAboutDeprecatedIsAsyncMode) {
				hasWarnedAboutDeprecatedIsAsyncMode = true;
				console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
			}
			return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
		}
		function isConcurrentMode(object) {
			return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
		}
		function isContextConsumer(object) {
			return typeOf(object) === REACT_CONTEXT_TYPE;
		}
		function isContextProvider(object) {
			return typeOf(object) === REACT_PROVIDER_TYPE;
		}
		function isElement(object) {
			return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
		}
		function isForwardRef(object) {
			return typeOf(object) === REACT_FORWARD_REF_TYPE;
		}
		function isFragment$1(object) {
			return typeOf(object) === REACT_FRAGMENT_TYPE;
		}
		function isLazy(object) {
			return typeOf(object) === REACT_LAZY_TYPE;
		}
		function isMemo(object) {
			return typeOf(object) === REACT_MEMO_TYPE;
		}
		function isPortal(object) {
			return typeOf(object) === REACT_PORTAL_TYPE;
		}
		function isProfiler(object) {
			return typeOf(object) === REACT_PROFILER_TYPE;
		}
		function isStrictMode(object) {
			return typeOf(object) === REACT_STRICT_MODE_TYPE;
		}
		function isSuspense(object) {
			return typeOf(object) === REACT_SUSPENSE_TYPE;
		}
		exports.AsyncMode = AsyncMode;
		exports.ConcurrentMode = ConcurrentMode;
		exports.ContextConsumer = ContextConsumer;
		exports.ContextProvider = ContextProvider;
		exports.Element = Element;
		exports.ForwardRef = ForwardRef;
		exports.Fragment = Fragment;
		exports.Lazy = Lazy;
		exports.Memo = Memo;
		exports.Portal = Portal;
		exports.Profiler = Profiler;
		exports.StrictMode = StrictMode;
		exports.Suspense = Suspense;
		exports.isAsyncMode = isAsyncMode;
		exports.isConcurrentMode = isConcurrentMode;
		exports.isContextConsumer = isContextConsumer;
		exports.isContextProvider = isContextProvider;
		exports.isElement = isElement;
		exports.isForwardRef = isForwardRef;
		exports.isFragment = isFragment$1;
		exports.isLazy = isLazy;
		exports.isMemo = isMemo;
		exports.isPortal = isPortal;
		exports.isProfiler = isProfiler;
		exports.isStrictMode = isStrictMode;
		exports.isSuspense = isSuspense;
		exports.isValidElementType = isValidElementType;
		exports.typeOf = typeOf;
	})();
}));
var require_react_is = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require_react_is_development();
}));
var require_object_assign = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var getOwnPropertySymbols$1 = Object.getOwnPropertySymbols;
	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	function toObject(val) {
		if (val === null || val === void 0) throw new TypeError("Object.assign cannot be called with null or undefined");
		return Object(val);
	}
	function shouldUseNative() {
		try {
			if (!Object.assign) return false;
			var test1 = /* @__PURE__ */ new String("abc");
			test1[5] = "de";
			if (Object.getOwnPropertyNames(test1)[0] === "5") return false;
			var test2 = {};
			for (var i = 0; i < 10; i++) test2["_" + String.fromCharCode(i)] = i;
			if (Object.getOwnPropertyNames(test2).map(function(n) {
				return test2[n];
			}).join("") !== "0123456789") return false;
			var test3 = {};
			"abcdefghijklmnopqrst".split("").forEach(function(letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") return false;
			return true;
		} catch (err) {
			return false;
		}
	}
	module.exports = shouldUseNative() ? Object.assign : function(target, source) {
		var from;
		var to = toObject(target);
		var symbols;
		for (var s$1 = 1; s$1 < arguments.length; s$1++) {
			from = Object(arguments[s$1]);
			for (var key in from) if (hasOwnProperty$2.call(from, key)) to[key] = from[key];
			if (getOwnPropertySymbols$1) {
				symbols = getOwnPropertySymbols$1(from);
				for (var i = 0; i < symbols.length; i++) if (propIsEnumerable.call(from, symbols[i])) to[symbols[i]] = from[symbols[i]];
			}
		}
		return to;
	};
}));
var require_ReactPropTypesSecret = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
}));
var require_has = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
}));
var require_checkPropTypes = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var printWarning$1 = function() {};
	var ReactPropTypesSecret$1 = require_ReactPropTypesSecret();
	var loggedTypeFailures = {};
	var has$2 = require_has();
	printWarning$1 = function(text) {
		var message = "Warning: " + text;
		if (typeof console !== "undefined") console.error(message);
		try {
			throw new Error(message);
		} catch (x$1) {}
	};
	function checkPropTypes$1(typeSpecs, values, location, componentName, getStack) {
		for (var typeSpecName in typeSpecs) if (has$2(typeSpecs, typeSpecName)) {
			var error;
			try {
				if (typeof typeSpecs[typeSpecName] !== "function") {
					var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
					err.name = "Invariant Violation";
					throw err;
				}
				error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret$1);
			} catch (ex) {
				error = ex;
			}
			if (error && !(error instanceof Error)) printWarning$1((componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).");
			if (error instanceof Error && !(error.message in loggedTypeFailures)) {
				loggedTypeFailures[error.message] = true;
				var stack = getStack ? getStack() : "";
				printWarning$1("Failed " + location + " type: " + error.message + (stack != null ? stack : ""));
			}
		}
	}
	checkPropTypes$1.resetWarningCache = function() {
		loggedTypeFailures = {};
	};
	module.exports = checkPropTypes$1;
}));
var require_factoryWithTypeCheckers = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var ReactIs$1 = require_react_is();
	var assign = require_object_assign();
	var ReactPropTypesSecret = require_ReactPropTypesSecret();
	var has$1 = require_has();
	var checkPropTypes = require_checkPropTypes();
	var printWarning = function() {};
	printWarning = function(text) {
		var message = "Warning: " + text;
		if (typeof console !== "undefined") console.error(message);
		try {
			throw new Error(message);
		} catch (x$1) {}
	};
	function emptyFunctionThatReturnsNull() {
		return null;
	}
	module.exports = function(isValidElement$7, throwOnDirectAccess$1) {
		var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
		var FAUX_ITERATOR_SYMBOL = "@@iterator";
		function getIteratorFn(maybeIterable) {
			var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
			if (typeof iteratorFn === "function") return iteratorFn;
		}
		var ANONYMOUS = "<<anonymous>>";
		var ReactPropTypes = {
			array: createPrimitiveTypeChecker("array"),
			bigint: createPrimitiveTypeChecker("bigint"),
			bool: createPrimitiveTypeChecker("boolean"),
			func: createPrimitiveTypeChecker("function"),
			number: createPrimitiveTypeChecker("number"),
			object: createPrimitiveTypeChecker("object"),
			string: createPrimitiveTypeChecker("string"),
			symbol: createPrimitiveTypeChecker("symbol"),
			any: createAnyTypeChecker(),
			arrayOf: createArrayOfTypeChecker,
			element: createElementTypeChecker(),
			elementType: createElementTypeTypeChecker(),
			instanceOf: createInstanceTypeChecker,
			node: createNodeChecker(),
			objectOf: createObjectOfTypeChecker,
			oneOf: createEnumTypeChecker,
			oneOfType: createUnionTypeChecker,
			shape: createShapeTypeChecker,
			exact: createStrictShapeTypeChecker
		};
		function is(x$1, y$1) {
			if (x$1 === y$1) return x$1 !== 0 || 1 / x$1 === 1 / y$1;
			else return x$1 !== x$1 && y$1 !== y$1;
		}
		function PropTypeError(message, data) {
			this.message = message;
			this.data = data && typeof data === "object" ? data : {};
			this.stack = "";
		}
		PropTypeError.prototype = Error.prototype;
		function createChainableTypeChecker(validate) {
			var manualPropTypeCallCache = {};
			var manualPropTypeWarningCount = 0;
			function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
				componentName = componentName || ANONYMOUS;
				propFullName = propFullName || propName;
				if (secret !== ReactPropTypesSecret) {
					if (throwOnDirectAccess$1) {
						var err = /* @__PURE__ */ new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types");
						err.name = "Invariant Violation";
						throw err;
					} else if (typeof console !== "undefined") {
						var cacheKey = componentName + ":" + propName;
						if (!manualPropTypeCallCache[cacheKey] && manualPropTypeWarningCount < 3) {
							printWarning("You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details.");
							manualPropTypeCallCache[cacheKey] = true;
							manualPropTypeWarningCount++;
						}
					}
				}
				if (props[propName] == null) {
					if (isRequired) {
						if (props[propName] === null) return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
						return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
					}
					return null;
				} else return validate(props, propName, componentName, location, propFullName);
			}
			var chainedCheckType = checkType.bind(null, false);
			chainedCheckType.isRequired = checkType.bind(null, true);
			return chainedCheckType;
		}
		function createPrimitiveTypeChecker(expectedType) {
			function validate(props, propName, componentName, location, propFullName, secret) {
				var propValue = props[propName];
				if (getPropType(propValue) !== expectedType) {
					var preciseType = getPreciseType(propValue);
					return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."), { expectedType });
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function createAnyTypeChecker() {
			return createChainableTypeChecker(emptyFunctionThatReturnsNull);
		}
		function createArrayOfTypeChecker(typeChecker) {
			function validate(props, propName, componentName, location, propFullName) {
				if (typeof typeChecker !== "function") return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
				var propValue = props[propName];
				if (!Array.isArray(propValue)) {
					var propType = getPropType(propValue);
					return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
				}
				for (var i = 0; i < propValue.length; i++) {
					var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
					if (error instanceof Error) return error;
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function createElementTypeChecker() {
			function validate(props, propName, componentName, location, propFullName) {
				var propValue = props[propName];
				if (!isValidElement$7(propValue)) {
					var propType = getPropType(propValue);
					return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function createElementTypeTypeChecker() {
			function validate(props, propName, componentName, location, propFullName) {
				var propValue = props[propName];
				if (!ReactIs$1.isValidElementType(propValue)) {
					var propType = getPropType(propValue);
					return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function createInstanceTypeChecker(expectedClass) {
			function validate(props, propName, componentName, location, propFullName) {
				if (!(props[propName] instanceof expectedClass)) {
					var expectedClassName = expectedClass.name || ANONYMOUS;
					var actualClassName = getClassName(props[propName]);
					return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function createEnumTypeChecker(expectedValues) {
			if (!Array.isArray(expectedValues)) {
				if (arguments.length > 1) printWarning("Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).");
				else printWarning("Invalid argument supplied to oneOf, expected an array.");
				return emptyFunctionThatReturnsNull;
			}
			function validate(props, propName, componentName, location, propFullName) {
				var propValue = props[propName];
				for (var i = 0; i < expectedValues.length; i++) if (is(propValue, expectedValues[i])) return null;
				var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
					if (getPreciseType(value) === "symbol") return String(value);
					return value;
				});
				return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
			}
			return createChainableTypeChecker(validate);
		}
		function createObjectOfTypeChecker(typeChecker) {
			function validate(props, propName, componentName, location, propFullName) {
				if (typeof typeChecker !== "function") return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
				var propValue = props[propName];
				var propType = getPropType(propValue);
				if (propType !== "object") return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
				for (var key in propValue) if (has$1(propValue, key)) {
					var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
					if (error instanceof Error) return error;
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function createUnionTypeChecker(arrayOfTypeCheckers) {
			if (!Array.isArray(arrayOfTypeCheckers)) {
				printWarning("Invalid argument supplied to oneOfType, expected an instance of array.");
				return emptyFunctionThatReturnsNull;
			}
			for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
				var checker = arrayOfTypeCheckers[i];
				if (typeof checker !== "function") {
					printWarning("Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + ".");
					return emptyFunctionThatReturnsNull;
				}
			}
			function validate(props, propName, componentName, location, propFullName) {
				var expectedTypes = [];
				for (var i$1 = 0; i$1 < arrayOfTypeCheckers.length; i$1++) {
					var checker$1 = arrayOfTypeCheckers[i$1];
					var checkerResult = checker$1(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
					if (checkerResult == null) return null;
					if (checkerResult.data && has$1(checkerResult.data, "expectedType")) expectedTypes.push(checkerResult.data.expectedType);
				}
				var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
				return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
			}
			return createChainableTypeChecker(validate);
		}
		function createNodeChecker() {
			function validate(props, propName, componentName, location, propFullName) {
				if (!isNode(props[propName])) return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function invalidValidatorError(componentName, location, propFullName, key, type) {
			return new PropTypeError((componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`.");
		}
		function createShapeTypeChecker(shapeTypes) {
			function validate(props, propName, componentName, location, propFullName) {
				var propValue = props[propName];
				var propType = getPropType(propValue);
				if (propType !== "object") return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
				for (var key in shapeTypes) {
					var checker = shapeTypes[key];
					if (typeof checker !== "function") return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
					var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
					if (error) return error;
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function createStrictShapeTypeChecker(shapeTypes) {
			function validate(props, propName, componentName, location, propFullName) {
				var propValue = props[propName];
				var propType = getPropType(propValue);
				if (propType !== "object") return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
				for (var key in assign({}, props[propName], shapeTypes)) {
					var checker = shapeTypes[key];
					if (has$1(shapeTypes, key) && typeof checker !== "function") return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
					if (!checker) return new PropTypeError("Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  "));
					var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
					if (error) return error;
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function isNode(propValue) {
			switch (typeof propValue) {
				case "number":
				case "string":
				case "undefined": return true;
				case "boolean": return !propValue;
				case "object":
					if (Array.isArray(propValue)) return propValue.every(isNode);
					if (propValue === null || isValidElement$7(propValue)) return true;
					var iteratorFn = getIteratorFn(propValue);
					if (iteratorFn) {
						var iterator = iteratorFn.call(propValue);
						var step;
						if (iteratorFn !== propValue.entries) {
							while (!(step = iterator.next()).done) if (!isNode(step.value)) return false;
						} else while (!(step = iterator.next()).done) {
							var entry = step.value;
							if (entry) {
								if (!isNode(entry[1])) return false;
							}
						}
					} else return false;
					return true;
				default: return false;
			}
		}
		function isSymbol$7(propType, propValue) {
			if (propType === "symbol") return true;
			if (!propValue) return false;
			if (propValue["@@toStringTag"] === "Symbol") return true;
			if (typeof Symbol === "function" && propValue instanceof Symbol) return true;
			return false;
		}
		function getPropType(propValue) {
			var propType = typeof propValue;
			if (Array.isArray(propValue)) return "array";
			if (propValue instanceof RegExp) return "object";
			if (isSymbol$7(propType, propValue)) return "symbol";
			return propType;
		}
		function getPreciseType(propValue) {
			if (typeof propValue === "undefined" || propValue === null) return "" + propValue;
			var propType = getPropType(propValue);
			if (propType === "object") {
				if (propValue instanceof Date) return "date";
				else if (propValue instanceof RegExp) return "regexp";
			}
			return propType;
		}
		function getPostfixForTypeWarning(value) {
			var type = getPreciseType(value);
			switch (type) {
				case "array":
				case "object": return "an " + type;
				case "boolean":
				case "date":
				case "regexp": return "a " + type;
				default: return type;
			}
		}
		function getClassName(propValue) {
			if (!propValue.constructor || !propValue.constructor.name) return ANONYMOUS;
			return propValue.constructor.name;
		}
		ReactPropTypes.checkPropTypes = checkPropTypes;
		ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
		ReactPropTypes.PropTypes = ReactPropTypes;
		return ReactPropTypes;
	};
}));
var require_prop_types = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var ReactIs = require_react_is();
	module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, true);
}));
var { getOwnPropertyNames, getOwnPropertySymbols } = Object;
var { hasOwnProperty: hasOwnProperty$1 } = Object.prototype;
function combineComparators(comparatorA, comparatorB) {
	return function isEqual$4(a$1, b, state) {
		return comparatorA(a$1, b, state) && comparatorB(a$1, b, state);
	};
}
function createIsCircular(areItemsEqual) {
	return function isCircular(a$1, b, state) {
		if (!a$1 || !b || typeof a$1 !== "object" || typeof b !== "object") return areItemsEqual(a$1, b, state);
		const { cache } = state;
		const cachedA = cache.get(a$1);
		const cachedB = cache.get(b);
		if (cachedA && cachedB) return cachedA === b && cachedB === a$1;
		cache.set(a$1, b);
		cache.set(b, a$1);
		const result = areItemsEqual(a$1, b, state);
		cache.delete(a$1);
		cache.delete(b);
		return result;
	};
}
function getShortTag(value) {
	return value != null ? value[Symbol.toStringTag] : void 0;
}
function getStrictProperties(object) {
	return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));
}
var hasOwn = Object.hasOwn || ((object, property$2) => hasOwnProperty$1.call(object, property$2));
function sameValueZeroEqual(a$1, b) {
	return a$1 === b || !a$1 && !b && a$1 !== a$1 && b !== b;
}
var PREACT_VNODE = "__v";
var PREACT_OWNER = "__o";
var REACT_OWNER = "_owner";
var { getOwnPropertyDescriptor, keys: keys$1 } = Object;
function areArrayBuffersEqual(a$1, b) {
	return a$1.byteLength === b.byteLength && areTypedArraysEqual(new Uint8Array(a$1), new Uint8Array(b));
}
function areArraysEqual(a$1, b, state) {
	let index = a$1.length;
	if (b.length !== index) return false;
	while (index-- > 0) if (!state.equals(a$1[index], b[index], index, index, a$1, b, state)) return false;
	return true;
}
function areDataViewsEqual(a$1, b) {
	return a$1.byteLength === b.byteLength && areTypedArraysEqual(new Uint8Array(a$1.buffer, a$1.byteOffset, a$1.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength));
}
function areDatesEqual(a$1, b) {
	return sameValueZeroEqual(a$1.getTime(), b.getTime());
}
function areErrorsEqual(a$1, b) {
	return a$1.name === b.name && a$1.message === b.message && a$1.cause === b.cause && a$1.stack === b.stack;
}
function areFunctionsEqual(a$1, b) {
	return a$1 === b;
}
function areMapsEqual(a$1, b, state) {
	const size = a$1.size;
	if (size !== b.size) return false;
	if (!size) return true;
	const matchedIndices = new Array(size);
	const aIterable = a$1.entries();
	let aResult;
	let bResult;
	let index = 0;
	while (aResult = aIterable.next()) {
		if (aResult.done) break;
		const bIterable = b.entries();
		let hasMatch = false;
		let matchIndex = 0;
		while (bResult = bIterable.next()) {
			if (bResult.done) break;
			if (matchedIndices[matchIndex]) {
				matchIndex++;
				continue;
			}
			const aEntry = aResult.value;
			const bEntry = bResult.value;
			if (state.equals(aEntry[0], bEntry[0], index, matchIndex, a$1, b, state) && state.equals(aEntry[1], bEntry[1], aEntry[0], bEntry[0], a$1, b, state)) {
				hasMatch = matchedIndices[matchIndex] = true;
				break;
			}
			matchIndex++;
		}
		if (!hasMatch) return false;
		index++;
	}
	return true;
}
var areNumbersEqual = sameValueZeroEqual;
function areObjectsEqual(a$1, b, state) {
	const properties = keys$1(a$1);
	let index = properties.length;
	if (keys$1(b).length !== index) return false;
	while (index-- > 0) if (!isPropertyEqual(a$1, b, state, properties[index])) return false;
	return true;
}
function areObjectsEqualStrict(a$1, b, state) {
	const properties = getStrictProperties(a$1);
	let index = properties.length;
	if (getStrictProperties(b).length !== index) return false;
	let property$2;
	let descriptorA;
	let descriptorB;
	while (index-- > 0) {
		property$2 = properties[index];
		if (!isPropertyEqual(a$1, b, state, property$2)) return false;
		descriptorA = getOwnPropertyDescriptor(a$1, property$2);
		descriptorB = getOwnPropertyDescriptor(b, property$2);
		if ((descriptorA || descriptorB) && (!descriptorA || !descriptorB || descriptorA.configurable !== descriptorB.configurable || descriptorA.enumerable !== descriptorB.enumerable || descriptorA.writable !== descriptorB.writable)) return false;
	}
	return true;
}
function arePrimitiveWrappersEqual(a$1, b) {
	return sameValueZeroEqual(a$1.valueOf(), b.valueOf());
}
function areRegExpsEqual(a$1, b) {
	return a$1.source === b.source && a$1.flags === b.flags;
}
function areSetsEqual(a$1, b, state) {
	const size = a$1.size;
	if (size !== b.size) return false;
	if (!size) return true;
	const matchedIndices = new Array(size);
	const aIterable = a$1.values();
	let aResult;
	let bResult;
	while (aResult = aIterable.next()) {
		if (aResult.done) break;
		const bIterable = b.values();
		let hasMatch = false;
		let matchIndex = 0;
		while (bResult = bIterable.next()) {
			if (bResult.done) break;
			if (!matchedIndices[matchIndex] && state.equals(aResult.value, bResult.value, aResult.value, bResult.value, a$1, b, state)) {
				hasMatch = matchedIndices[matchIndex] = true;
				break;
			}
			matchIndex++;
		}
		if (!hasMatch) return false;
	}
	return true;
}
function areTypedArraysEqual(a$1, b) {
	let index = a$1.byteLength;
	if (b.byteLength !== index || a$1.byteOffset !== b.byteOffset) return false;
	while (index-- > 0) if (a$1[index] !== b[index]) return false;
	return true;
}
function areUrlsEqual(a$1, b) {
	return a$1.hostname === b.hostname && a$1.pathname === b.pathname && a$1.protocol === b.protocol && a$1.port === b.port && a$1.hash === b.hash && a$1.username === b.username && a$1.password === b.password;
}
function isPropertyEqual(a$1, b, state, property$2) {
	if ((property$2 === REACT_OWNER || property$2 === PREACT_OWNER || property$2 === PREACT_VNODE) && (a$1.$$typeof || b.$$typeof)) return true;
	return hasOwn(b, property$2) && state.equals(a$1[property$2], b[property$2], property$2, property$2, a$1, b, state);
}
var ARRAY_BUFFER_TAG = "[object ArrayBuffer]";
var ARGUMENTS_TAG = "[object Arguments]";
var BOOLEAN_TAG = "[object Boolean]";
var DATA_VIEW_TAG = "[object DataView]";
var DATE_TAG = "[object Date]";
var ERROR_TAG = "[object Error]";
var MAP_TAG = "[object Map]";
var NUMBER_TAG = "[object Number]";
var OBJECT_TAG = "[object Object]";
var REG_EXP_TAG = "[object RegExp]";
var SET_TAG = "[object Set]";
var STRING_TAG = "[object String]";
var TYPED_ARRAY_TAGS = {
	"[object Int8Array]": true,
	"[object Uint8Array]": true,
	"[object Uint8ClampedArray]": true,
	"[object Int16Array]": true,
	"[object Uint16Array]": true,
	"[object Int32Array]": true,
	"[object Uint32Array]": true,
	"[object Float16Array]": true,
	"[object Float32Array]": true,
	"[object Float64Array]": true,
	"[object BigInt64Array]": true,
	"[object BigUint64Array]": true
};
var URL_TAG = "[object URL]";
var toString = Object.prototype.toString;
function createEqualityComparator({ areArrayBuffersEqual: areArrayBuffersEqual$1, areArraysEqual: areArraysEqual$1, areDataViewsEqual: areDataViewsEqual$1, areDatesEqual: areDatesEqual$1, areErrorsEqual: areErrorsEqual$1, areFunctionsEqual: areFunctionsEqual$1, areMapsEqual: areMapsEqual$1, areNumbersEqual: areNumbersEqual$1, areObjectsEqual: areObjectsEqual$1, arePrimitiveWrappersEqual: arePrimitiveWrappersEqual$1, areRegExpsEqual: areRegExpsEqual$1, areSetsEqual: areSetsEqual$1, areTypedArraysEqual: areTypedArraysEqual$1, areUrlsEqual: areUrlsEqual$1, unknownTagComparators }) {
	return function comparator(a$1, b, state) {
		if (a$1 === b) return true;
		if (a$1 == null || b == null) return false;
		const type = typeof a$1;
		if (type !== typeof b) return false;
		if (type !== "object") {
			if (type === "number") return areNumbersEqual$1(a$1, b, state);
			if (type === "function") return areFunctionsEqual$1(a$1, b, state);
			return false;
		}
		const constructor = a$1.constructor;
		if (constructor !== b.constructor) return false;
		if (constructor === Object) return areObjectsEqual$1(a$1, b, state);
		if (Array.isArray(a$1)) return areArraysEqual$1(a$1, b, state);
		if (constructor === Date) return areDatesEqual$1(a$1, b, state);
		if (constructor === RegExp) return areRegExpsEqual$1(a$1, b, state);
		if (constructor === Map) return areMapsEqual$1(a$1, b, state);
		if (constructor === Set) return areSetsEqual$1(a$1, b, state);
		const tag = toString.call(a$1);
		if (tag === DATE_TAG) return areDatesEqual$1(a$1, b, state);
		if (tag === REG_EXP_TAG) return areRegExpsEqual$1(a$1, b, state);
		if (tag === MAP_TAG) return areMapsEqual$1(a$1, b, state);
		if (tag === SET_TAG) return areSetsEqual$1(a$1, b, state);
		if (tag === OBJECT_TAG) return typeof a$1.then !== "function" && typeof b.then !== "function" && areObjectsEqual$1(a$1, b, state);
		if (tag === URL_TAG) return areUrlsEqual$1(a$1, b, state);
		if (tag === ERROR_TAG) return areErrorsEqual$1(a$1, b, state);
		if (tag === ARGUMENTS_TAG) return areObjectsEqual$1(a$1, b, state);
		if (TYPED_ARRAY_TAGS[tag]) return areTypedArraysEqual$1(a$1, b, state);
		if (tag === ARRAY_BUFFER_TAG) return areArrayBuffersEqual$1(a$1, b, state);
		if (tag === DATA_VIEW_TAG) return areDataViewsEqual$1(a$1, b, state);
		if (tag === BOOLEAN_TAG || tag === NUMBER_TAG || tag === STRING_TAG) return arePrimitiveWrappersEqual$1(a$1, b, state);
		if (unknownTagComparators) {
			let unknownTagComparator = unknownTagComparators[tag];
			if (!unknownTagComparator) {
				const shortTag = getShortTag(a$1);
				if (shortTag) unknownTagComparator = unknownTagComparators[shortTag];
			}
			if (unknownTagComparator) return unknownTagComparator(a$1, b, state);
		}
		return false;
	};
}
function createEqualityComparatorConfig({ circular, createCustomConfig, strict }) {
	let config = {
		areArrayBuffersEqual,
		areArraysEqual: strict ? areObjectsEqualStrict : areArraysEqual,
		areDataViewsEqual,
		areDatesEqual,
		areErrorsEqual,
		areFunctionsEqual,
		areMapsEqual: strict ? combineComparators(areMapsEqual, areObjectsEqualStrict) : areMapsEqual,
		areNumbersEqual,
		areObjectsEqual: strict ? areObjectsEqualStrict : areObjectsEqual,
		arePrimitiveWrappersEqual,
		areRegExpsEqual,
		areSetsEqual: strict ? combineComparators(areSetsEqual, areObjectsEqualStrict) : areSetsEqual,
		areTypedArraysEqual: strict ? combineComparators(areTypedArraysEqual, areObjectsEqualStrict) : areTypedArraysEqual,
		areUrlsEqual,
		unknownTagComparators: void 0
	};
	if (createCustomConfig) config = Object.assign({}, config, createCustomConfig(config));
	if (circular) {
		const areArraysEqual$1 = createIsCircular(config.areArraysEqual);
		const areMapsEqual$1 = createIsCircular(config.areMapsEqual);
		const areObjectsEqual$1 = createIsCircular(config.areObjectsEqual);
		const areSetsEqual$1 = createIsCircular(config.areSetsEqual);
		config = Object.assign({}, config, {
			areArraysEqual: areArraysEqual$1,
			areMapsEqual: areMapsEqual$1,
			areObjectsEqual: areObjectsEqual$1,
			areSetsEqual: areSetsEqual$1
		});
	}
	return config;
}
function createInternalEqualityComparator(compare) {
	return function(a$1, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, state) {
		return compare(a$1, b, state);
	};
}
function createIsEqual({ circular, comparator, createState, equals, strict }) {
	if (createState) return function isEqual$4(a$1, b) {
		const { cache = circular ? /* @__PURE__ */ new WeakMap() : void 0, meta } = createState();
		return comparator(a$1, b, {
			cache,
			equals,
			meta,
			strict
		});
	};
	if (circular) return function isEqual$4(a$1, b) {
		return comparator(a$1, b, {
			cache: /* @__PURE__ */ new WeakMap(),
			equals,
			meta: void 0,
			strict
		});
	};
	const state = {
		cache: void 0,
		equals,
		meta: void 0,
		strict
	};
	return function isEqual$4(a$1, b) {
		return comparator(a$1, b, state);
	};
}
var deepEqual = createCustomEqual();
createCustomEqual({ strict: true });
createCustomEqual({ circular: true });
createCustomEqual({
	circular: true,
	strict: true
});
createCustomEqual({ createInternalComparator: () => sameValueZeroEqual });
createCustomEqual({
	strict: true,
	createInternalComparator: () => sameValueZeroEqual
});
createCustomEqual({
	circular: true,
	createInternalComparator: () => sameValueZeroEqual
});
createCustomEqual({
	circular: true,
	createInternalComparator: () => sameValueZeroEqual,
	strict: true
});
function createCustomEqual(options = {}) {
	const { circular = false, createInternalComparator: createCustomInternalComparator, createState, strict = false } = options;
	const comparator = createEqualityComparator(createEqualityComparatorConfig(options));
	return createIsEqual({
		circular,
		comparator,
		createState,
		equals: createCustomInternalComparator ? createCustomInternalComparator(comparator) : createInternalEqualityComparator(comparator),
		strict
	});
}
function safeRequestAnimationFrame(callback) {
	if (typeof requestAnimationFrame !== "undefined") requestAnimationFrame(callback);
}
function setRafTimeout(callback) {
	var timeout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
	var currTime = -1;
	requestAnimationFrame(function shouldUpdate(now$2) {
		if (currTime < 0) currTime = now$2;
		if (now$2 - currTime > timeout) {
			callback(now$2);
			currTime = -1;
		} else safeRequestAnimationFrame(shouldUpdate);
	});
}
function _typeof$24(o) {
	"@babel/helpers - typeof";
	return _typeof$24 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$24(o);
}
function _toArray(arr) {
	return _arrayWithHoles$6(arr) || _iterableToArray$5(arr) || _unsupportedIterableToArray$8(arr) || _nonIterableRest$6();
}
function _nonIterableRest$6() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$8(o, minLen) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$8(o, minLen);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$8(o, minLen);
}
function _arrayLikeToArray$8(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArray$5(iter) {
	if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithHoles$6(arr) {
	if (Array.isArray(arr)) return arr;
}
function createAnimateManager() {
	var currStyle = {};
	var handleChange = function handleChange$1() {
		return null;
	};
	var shouldStop = false;
	var setStyle = function setStyle$1(_style) {
		if (shouldStop) return;
		if (Array.isArray(_style)) {
			if (!_style.length) return;
			var _styles = _toArray(_style), curr = _styles[0], restStyles = _styles.slice(1);
			if (typeof curr === "number") {
				setRafTimeout(setStyle$1.bind(null, restStyles), curr);
				return;
			}
			setStyle$1(curr);
			setRafTimeout(setStyle$1.bind(null, restStyles));
			return;
		}
		if (_typeof$24(_style) === "object") {
			currStyle = _style;
			handleChange(currStyle);
		}
		if (typeof _style === "function") _style();
	};
	return {
		stop: function stop() {
			shouldStop = true;
		},
		start: function start(style) {
			shouldStop = false;
			setStyle(style);
		},
		subscribe: function subscribe(_handleChange) {
			handleChange = _handleChange;
			return function() {
				handleChange = function handleChange$1() {
					return null;
				};
			};
		}
	};
}
function _typeof$23(o) {
	"@babel/helpers - typeof";
	return _typeof$23 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$23(o);
}
function ownKeys$19(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$19(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$19(Object(t), !0).forEach(function(r$1) {
			_defineProperty$22(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$19(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}
function _defineProperty$22(obj, key, value) {
	key = _toPropertyKey$22(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$22(arg) {
	var key = _toPrimitive$22(arg, "string");
	return _typeof$23(key) === "symbol" ? key : String(key);
}
function _toPrimitive$22(input, hint) {
	if (_typeof$23(input) !== "object" || input === null) return input;
	var prim = input[Symbol.toPrimitive];
	if (prim !== void 0) {
		var res = prim.call(input, hint || "default");
		if (_typeof$23(res) !== "object") return res;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return (hint === "string" ? String : Number)(input);
}
var getIntersectionKeys = function getIntersectionKeys$1(preObj, nextObj) {
	return [Object.keys(preObj), Object.keys(nextObj)].reduce(function(a$1, b) {
		return a$1.filter(function(c$1) {
			return b.includes(c$1);
		});
	});
};
var identity = function identity$11(param) {
	return param;
};
var getDashCase = function getDashCase$1(name) {
	return name.replace(/([A-Z])/g, function(v) {
		return "-".concat(v.toLowerCase());
	});
};
var mapObject = function mapObject$1(fn, obj) {
	return Object.keys(obj).reduce(function(res, key) {
		return _objectSpread$19(_objectSpread$19({}, res), {}, _defineProperty$22({}, key, fn(key, obj[key])));
	}, {});
};
var getTransitionVal = function getTransitionVal$1(props, duration, easing) {
	return props.map(function(prop) {
		return "".concat(getDashCase(prop), " ").concat(duration, "ms ").concat(easing);
	}).join(",");
};
var isDev = true;
var warn$1 = function warn$2(condition, format$1, a$1, b, c$1, d, e, f) {
	if (isDev && typeof console !== "undefined" && console.warn) {
		if (format$1 === void 0) console.warn("LogUtils requires an error message argument");
		if (!condition) if (format$1 === void 0) console.warn("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
		else {
			var args = [
				a$1,
				b,
				c$1,
				d,
				e,
				f
			];
			var argIndex = 0;
			console.warn(format$1.replace(/%s/g, function() {
				return args[argIndex++];
			}));
		}
	}
};
function _slicedToArray$5(arr, i) {
	return _arrayWithHoles$5(arr) || _iterableToArrayLimit$5(arr, i) || _unsupportedIterableToArray$7(arr, i) || _nonIterableRest$5();
}
function _nonIterableRest$5() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArrayLimit$5(r, l) {
	var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a$1 = [], f = !0, o = !1;
		try {
			if (i = (t = t.call(r)).next, 0 === l) {
				if (Object(t) !== t) return;
				f = !1;
			} else for (; !(f = (e = i.call(t)).done) && (a$1.push(e.value), a$1.length !== l); f = !0);
		} catch (r$1) {
			o = !0, n = r$1;
		} finally {
			try {
				if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a$1;
	}
}
function _arrayWithHoles$5(arr) {
	if (Array.isArray(arr)) return arr;
}
function _toConsumableArray$4(arr) {
	return _arrayWithoutHoles$4(arr) || _iterableToArray$4(arr) || _unsupportedIterableToArray$7(arr) || _nonIterableSpread$4();
}
function _nonIterableSpread$4() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$7(o, minLen) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$7(o, minLen);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(o, minLen);
}
function _iterableToArray$4(iter) {
	if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$4(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray$7(arr);
}
function _arrayLikeToArray$7(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
var ACCURACY = 1e-4;
var cubicBezierFactor = function cubicBezierFactor$1(c1, c2) {
	return [
		0,
		3 * c1,
		3 * c2 - 6 * c1,
		3 * c1 - 3 * c2 + 1
	];
};
var multyTime = function multyTime$1(params, t) {
	return params.map(function(param, i) {
		return param * Math.pow(t, i);
	}).reduce(function(pre, curr) {
		return pre + curr;
	});
};
var cubicBezier = function cubicBezier$1(c1, c2) {
	return function(t) {
		return multyTime(cubicBezierFactor(c1, c2), t);
	};
};
var derivativeCubicBezier = function derivativeCubicBezier$1(c1, c2) {
	return function(t) {
		var params = cubicBezierFactor(c1, c2);
		return multyTime([].concat(_toConsumableArray$4(params.map(function(param, i) {
			return param * i;
		}).slice(1)), [0]), t);
	};
};
var configBezier = function configBezier$1() {
	for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
	var x1 = args[0], y1 = args[1], x2 = args[2], y2 = args[3];
	if (args.length === 1) switch (args[0]) {
		case "linear":
			x1 = 0;
			y1 = 0;
			x2 = 1;
			y2 = 1;
			break;
		case "ease":
			x1 = .25;
			y1 = .1;
			x2 = .25;
			y2 = 1;
			break;
		case "ease-in":
			x1 = .42;
			y1 = 0;
			x2 = 1;
			y2 = 1;
			break;
		case "ease-out":
			x1 = .42;
			y1 = 0;
			x2 = .58;
			y2 = 1;
			break;
		case "ease-in-out":
			x1 = 0;
			y1 = 0;
			x2 = .58;
			y2 = 1;
			break;
		default:
			var easing = args[0].split("(");
			if (easing[0] === "cubic-bezier" && easing[1].split(")")[0].split(",").length === 4) {
				var _easing$1$split$0$spl2 = _slicedToArray$5(easing[1].split(")")[0].split(",").map(function(x$1) {
					return parseFloat(x$1);
				}), 4);
				x1 = _easing$1$split$0$spl2[0];
				y1 = _easing$1$split$0$spl2[1];
				x2 = _easing$1$split$0$spl2[2];
				y2 = _easing$1$split$0$spl2[3];
			} else warn$1(false, "[configBezier]: arguments should be one of oneOf 'linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out','cubic-bezier(x1,y1,x2,y2)', instead received %s", args);
	}
	warn$1([
		x1,
		x2,
		y1,
		y2
	].every(function(num) {
		return typeof num === "number" && num >= 0 && num <= 1;
	}), "[configBezier]: arguments should be x1, y1, x2, y2 of [0, 1] instead received %s", args);
	var curveX = cubicBezier(x1, x2);
	var curveY = cubicBezier(y1, y2);
	var derCurveX = derivativeCubicBezier(x1, x2);
	var rangeValue = function rangeValue$1(value) {
		if (value > 1) return 1;
		if (value < 0) return 0;
		return value;
	};
	var bezier = function bezier$1(_t) {
		var t = _t > 1 ? 1 : _t;
		var x$1 = t;
		for (var i = 0; i < 8; ++i) {
			var evalT = curveX(x$1) - t;
			var derVal = derCurveX(x$1);
			if (Math.abs(evalT - t) < ACCURACY || derVal < ACCURACY) return curveY(x$1);
			x$1 = rangeValue(x$1 - evalT / derVal);
		}
		return curveY(x$1);
	};
	bezier.isStepper = false;
	return bezier;
};
var configSpring = function configSpring$1() {
	var config = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
	var _config$stiff = config.stiff, stiff = _config$stiff === void 0 ? 100 : _config$stiff, _config$damping = config.damping, damping = _config$damping === void 0 ? 8 : _config$damping, _config$dt = config.dt, dt = _config$dt === void 0 ? 17 : _config$dt;
	var stepper = function stepper$1(currX, destX, currV) {
		var newV = currV + (-(currX - destX) * stiff - currV * damping) * dt / 1e3;
		var newX = currV * dt / 1e3 + currX;
		if (Math.abs(newX - destX) < ACCURACY && Math.abs(newV) < ACCURACY) return [destX, 0];
		return [newX, newV];
	};
	stepper.isStepper = true;
	stepper.dt = dt;
	return stepper;
};
var configEasing = function configEasing$1() {
	for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
	var easing = args[0];
	if (typeof easing === "string") switch (easing) {
		case "ease":
		case "ease-in-out":
		case "ease-out":
		case "ease-in":
		case "linear": return configBezier(easing);
		case "spring": return configSpring();
		default:
			if (easing.split("(")[0] === "cubic-bezier") return configBezier(easing);
			warn$1(false, "[configEasing]: first argument should be one of 'ease', 'ease-in', 'ease-out', 'ease-in-out','cubic-bezier(x1,y1,x2,y2)', 'linear' and 'spring', instead  received %s", args);
	}
	if (typeof easing === "function") return easing;
	warn$1(false, "[configEasing]: first argument type should be function or string, instead received %s", args);
	return null;
};
function _typeof$22(o) {
	"@babel/helpers - typeof";
	return _typeof$22 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$22(o);
}
function _toConsumableArray$3(arr) {
	return _arrayWithoutHoles$3(arr) || _iterableToArray$3(arr) || _unsupportedIterableToArray$6(arr) || _nonIterableSpread$3();
}
function _nonIterableSpread$3() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray$3(iter) {
	if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$3(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray$6(arr);
}
function ownKeys$18(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$18(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$18(Object(t), !0).forEach(function(r$1) {
			_defineProperty$21(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$18(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}
function _defineProperty$21(obj, key, value) {
	key = _toPropertyKey$21(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$21(arg) {
	var key = _toPrimitive$21(arg, "string");
	return _typeof$22(key) === "symbol" ? key : String(key);
}
function _toPrimitive$21(input, hint) {
	if (_typeof$22(input) !== "object" || input === null) return input;
	var prim = input[Symbol.toPrimitive];
	if (prim !== void 0) {
		var res = prim.call(input, hint || "default");
		if (_typeof$22(res) !== "object") return res;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return (hint === "string" ? String : Number)(input);
}
function _slicedToArray$4(arr, i) {
	return _arrayWithHoles$4(arr) || _iterableToArrayLimit$4(arr, i) || _unsupportedIterableToArray$6(arr, i) || _nonIterableRest$4();
}
function _nonIterableRest$4() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$6(o, minLen) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$6(o, minLen);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen);
}
function _arrayLikeToArray$6(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$4(r, l) {
	var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a$1 = [], f = !0, o = !1;
		try {
			if (i = (t = t.call(r)).next, 0 === l) {
				if (Object(t) !== t) return;
				f = !1;
			} else for (; !(f = (e = i.call(t)).done) && (a$1.push(e.value), a$1.length !== l); f = !0);
		} catch (r$1) {
			o = !0, n = r$1;
		} finally {
			try {
				if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a$1;
	}
}
function _arrayWithHoles$4(arr) {
	if (Array.isArray(arr)) return arr;
}
var alpha = function alpha$1(begin, end, k$1) {
	return begin + (end - begin) * k$1;
};
var needContinue = function needContinue$1(_ref) {
	return _ref.from !== _ref.to;
};
var calStepperVals = function calStepperVals$1(easing, preVals, steps) {
	var nextStepVals = mapObject(function(key, val) {
		if (needContinue(val)) {
			var _easing2 = _slicedToArray$4(easing(val.from, val.to, val.velocity), 2), newX = _easing2[0], newV = _easing2[1];
			return _objectSpread$18(_objectSpread$18({}, val), {}, {
				from: newX,
				velocity: newV
			});
		}
		return val;
	}, preVals);
	if (steps < 1) return mapObject(function(key, val) {
		if (needContinue(val)) return _objectSpread$18(_objectSpread$18({}, val), {}, {
			velocity: alpha(val.velocity, nextStepVals[key].velocity, steps),
			from: alpha(val.from, nextStepVals[key].from, steps)
		});
		return val;
	}, preVals);
	return calStepperVals$1(easing, nextStepVals, steps - 1);
};
var configUpdate_default = (function(from, to, easing, duration, render) {
	var interKeys = getIntersectionKeys(from, to);
	var timingStyle = interKeys.reduce(function(res, key) {
		return _objectSpread$18(_objectSpread$18({}, res), {}, _defineProperty$21({}, key, [from[key], to[key]]));
	}, {});
	var stepperStyle = interKeys.reduce(function(res, key) {
		return _objectSpread$18(_objectSpread$18({}, res), {}, _defineProperty$21({}, key, {
			from: from[key],
			velocity: 0,
			to: to[key]
		}));
	}, {});
	var cafId = -1;
	var preTime;
	var beginTime;
	var update = function update$1() {
		return null;
	};
	var getCurrStyle = function getCurrStyle$1() {
		return mapObject(function(key, val) {
			return val.from;
		}, stepperStyle);
	};
	var shouldStopAnimation = function shouldStopAnimation$1() {
		return !Object.values(stepperStyle).filter(needContinue).length;
	};
	update = easing.isStepper ? function stepperUpdate(now$2) {
		if (!preTime) preTime = now$2;
		var steps = (now$2 - preTime) / easing.dt;
		stepperStyle = calStepperVals(easing, stepperStyle, steps);
		render(_objectSpread$18(_objectSpread$18(_objectSpread$18({}, from), to), getCurrStyle(stepperStyle)));
		preTime = now$2;
		if (!shouldStopAnimation()) cafId = requestAnimationFrame(update);
	} : function timingUpdate(now$2) {
		if (!beginTime) beginTime = now$2;
		var t = (now$2 - beginTime) / duration;
		var currStyle = mapObject(function(key, val) {
			return alpha.apply(void 0, _toConsumableArray$3(val).concat([easing(t)]));
		}, timingStyle);
		render(_objectSpread$18(_objectSpread$18(_objectSpread$18({}, from), to), currStyle));
		if (t < 1) cafId = requestAnimationFrame(update);
		else {
			var finalStyle = mapObject(function(key, val) {
				return alpha.apply(void 0, _toConsumableArray$3(val).concat([easing(1)]));
			}, timingStyle);
			render(_objectSpread$18(_objectSpread$18(_objectSpread$18({}, from), to), finalStyle));
		}
	};
	return function() {
		requestAnimationFrame(update);
		return function() {
			cancelAnimationFrame(cafId);
		};
	};
});
var import_prop_types = /* @__PURE__ */ __toESM(require_prop_types());
function _typeof$21(o) {
	"@babel/helpers - typeof";
	return _typeof$21 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$21(o);
}
var _excluded$7 = [
	"children",
	"begin",
	"duration",
	"attributeName",
	"easing",
	"isActive",
	"steps",
	"from",
	"to",
	"canBegin",
	"onAnimationEnd",
	"shouldReAnimate",
	"onAnimationReStart"
];
function _objectWithoutProperties$7(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$7(source, excluded);
	var key, i;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i = 0; i < sourceSymbolKeys.length; i++) {
			key = sourceSymbolKeys[i];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$7(source, excluded) {
	if (source == null) return {};
	var target = {};
	var sourceKeys = Object.keys(source);
	var key, i;
	for (i = 0; i < sourceKeys.length; i++) {
		key = sourceKeys[i];
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function _toConsumableArray$2(arr) {
	return _arrayWithoutHoles$2(arr) || _iterableToArray$2(arr) || _unsupportedIterableToArray$5(arr) || _nonIterableSpread$2();
}
function _nonIterableSpread$2() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$5(o, minLen) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$5(o, minLen);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen);
}
function _iterableToArray$2(iter) {
	if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$2(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray$5(arr);
}
function _arrayLikeToArray$5(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function ownKeys$17(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$17(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$17(Object(t), !0).forEach(function(r$1) {
			_defineProperty$20(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$17(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}
function _defineProperty$20(obj, key, value) {
	key = _toPropertyKey$20(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _classCallCheck$11(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$11(target, props) {
	for (var i = 0; i < props.length; i++) {
		var descriptor = props[i];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$20(descriptor.key), descriptor);
	}
}
function _createClass$11(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$11(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$11(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _toPropertyKey$20(arg) {
	var key = _toPrimitive$20(arg, "string");
	return _typeof$21(key) === "symbol" ? key : String(key);
}
function _toPrimitive$20(input, hint) {
	if (_typeof$21(input) !== "object" || input === null) return input;
	var prim = input[Symbol.toPrimitive];
	if (prim !== void 0) {
		var res = prim.call(input, hint || "default");
		if (_typeof$21(res) !== "object") return res;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return (hint === "string" ? String : Number)(input);
}
function _inherits$9(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
	subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
		value: subClass,
		writable: true,
		configurable: true
	} });
	Object.defineProperty(subClass, "prototype", { writable: false });
	if (superClass) _setPrototypeOf$9(subClass, superClass);
}
function _setPrototypeOf$9(o, p) {
	_setPrototypeOf$9 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf$15(o$1, p$1) {
		o$1.__proto__ = p$1;
		return o$1;
	};
	return _setPrototypeOf$9(o, p);
}
function _createSuper(Derived) {
	var hasNativeReflectConstruct = _isNativeReflectConstruct$9();
	return function _createSuperInternal() {
		var Super = _getPrototypeOf$9(Derived), result;
		if (hasNativeReflectConstruct) {
			var NewTarget = _getPrototypeOf$9(this).constructor;
			result = Reflect.construct(Super, arguments, NewTarget);
		} else result = Super.apply(this, arguments);
		return _possibleConstructorReturn$9(this, result);
	};
}
function _possibleConstructorReturn$9(self$1, call) {
	if (call && (_typeof$21(call) === "object" || typeof call === "function")) return call;
	else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
	return _assertThisInitialized$9(self$1);
}
function _assertThisInitialized$9(self$1) {
	if (self$1 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return self$1;
}
function _isNativeReflectConstruct$9() {
	if (typeof Reflect === "undefined" || !Reflect.construct) return false;
	if (Reflect.construct.sham) return false;
	if (typeof Proxy === "function") return true;
	try {
		Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
		return true;
	} catch (e) {
		return false;
	}
}
function _getPrototypeOf$9(o) {
	_getPrototypeOf$9 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf$15(o$1) {
		return o$1.__proto__ || Object.getPrototypeOf(o$1);
	};
	return _getPrototypeOf$9(o);
}
var Animate = /* @__PURE__ */ function(_PureComponent) {
	_inherits$9(Animate$1, _PureComponent);
	var _super = _createSuper(Animate$1);
	function Animate$1(props, context) {
		var _this;
		_classCallCheck$11(this, Animate$1);
		_this = _super.call(this, props, context);
		var _this$props = _this.props, isActive = _this$props.isActive, attributeName = _this$props.attributeName, from = _this$props.from, to = _this$props.to, steps = _this$props.steps, children = _this$props.children, duration = _this$props.duration;
		_this.handleStyleChange = _this.handleStyleChange.bind(_assertThisInitialized$9(_this));
		_this.changeStyle = _this.changeStyle.bind(_assertThisInitialized$9(_this));
		if (!isActive || duration <= 0) {
			_this.state = { style: {} };
			if (typeof children === "function") _this.state = { style: to };
			return _possibleConstructorReturn$9(_this);
		}
		if (steps && steps.length) _this.state = { style: steps[0].style };
		else if (from) {
			if (typeof children === "function") {
				_this.state = { style: from };
				return _possibleConstructorReturn$9(_this);
			}
			_this.state = { style: attributeName ? _defineProperty$20({}, attributeName, from) : from };
		} else _this.state = { style: {} };
		return _this;
	}
	_createClass$11(Animate$1, [
		{
			key: "componentDidMount",
			value: function componentDidMount() {
				var _this$props2 = this.props, isActive = _this$props2.isActive, canBegin = _this$props2.canBegin;
				this.mounted = true;
				if (!isActive || !canBegin) return;
				this.runAnimation(this.props);
			}
		},
		{
			key: "componentDidUpdate",
			value: function componentDidUpdate(prevProps) {
				var _this$props3 = this.props, isActive = _this$props3.isActive, canBegin = _this$props3.canBegin, attributeName = _this$props3.attributeName, shouldReAnimate = _this$props3.shouldReAnimate, to = _this$props3.to, currentFrom = _this$props3.from;
				var style = this.state.style;
				if (!canBegin) return;
				if (!isActive) {
					var newState = { style: attributeName ? _defineProperty$20({}, attributeName, to) : to };
					if (this.state && style) {
						if (attributeName && style[attributeName] !== to || !attributeName && style !== to) this.setState(newState);
					}
					return;
				}
				if (deepEqual(prevProps.to, to) && prevProps.canBegin && prevProps.isActive) return;
				var isTriggered = !prevProps.canBegin || !prevProps.isActive;
				if (this.manager) this.manager.stop();
				if (this.stopJSAnimation) this.stopJSAnimation();
				var from = isTriggered || shouldReAnimate ? currentFrom : prevProps.to;
				if (this.state && style) {
					var _newState = { style: attributeName ? _defineProperty$20({}, attributeName, from) : from };
					if (attributeName && style[attributeName] !== from || !attributeName && style !== from) this.setState(_newState);
				}
				this.runAnimation(_objectSpread$17(_objectSpread$17({}, this.props), {}, {
					from,
					begin: 0
				}));
			}
		},
		{
			key: "componentWillUnmount",
			value: function componentWillUnmount() {
				this.mounted = false;
				var onAnimationEnd = this.props.onAnimationEnd;
				if (this.unSubscribe) this.unSubscribe();
				if (this.manager) {
					this.manager.stop();
					this.manager = null;
				}
				if (this.stopJSAnimation) this.stopJSAnimation();
				if (onAnimationEnd) onAnimationEnd();
			}
		},
		{
			key: "handleStyleChange",
			value: function handleStyleChange(style) {
				this.changeStyle(style);
			}
		},
		{
			key: "changeStyle",
			value: function changeStyle(style) {
				if (this.mounted) this.setState({ style });
			}
		},
		{
			key: "runJSAnimation",
			value: function runJSAnimation(props) {
				var _this2 = this;
				var from = props.from, to = props.to, duration = props.duration, easing = props.easing, begin = props.begin, onAnimationEnd = props.onAnimationEnd, onAnimationStart = props.onAnimationStart;
				var startAnimation = configUpdate_default(from, to, configEasing(easing), duration, this.changeStyle);
				this.manager.start([
					onAnimationStart,
					begin,
					function finalStartAnimation() {
						_this2.stopJSAnimation = startAnimation();
					},
					duration,
					onAnimationEnd
				]);
			}
		},
		{
			key: "runStepAnimation",
			value: function runStepAnimation(props) {
				var _this3 = this;
				var steps = props.steps, begin = props.begin, onAnimationStart = props.onAnimationStart;
				var _steps$ = steps[0], initialStyle = _steps$.style, _steps$$duration = _steps$.duration, initialTime = _steps$$duration === void 0 ? 0 : _steps$$duration;
				return this.manager.start([onAnimationStart].concat(_toConsumableArray$2(steps.reduce(function addStyle(sequence, nextItem, index) {
					if (index === 0) return sequence;
					var duration = nextItem.duration, _nextItem$easing = nextItem.easing, easing = _nextItem$easing === void 0 ? "ease" : _nextItem$easing, style = nextItem.style, nextProperties = nextItem.properties, onAnimationEnd = nextItem.onAnimationEnd;
					var preItem = index > 0 ? steps[index - 1] : nextItem;
					var properties = nextProperties || Object.keys(style);
					if (typeof easing === "function" || easing === "spring") return [].concat(_toConsumableArray$2(sequence), [_this3.runJSAnimation.bind(_this3, {
						from: preItem.style,
						to: style,
						duration,
						easing
					}), duration]);
					var transition = getTransitionVal(properties, duration, easing);
					var newStyle = _objectSpread$17(_objectSpread$17(_objectSpread$17({}, preItem.style), style), {}, { transition });
					return [].concat(_toConsumableArray$2(sequence), [
						newStyle,
						duration,
						onAnimationEnd
					]).filter(identity);
				}, [initialStyle, Math.max(initialTime, begin)])), [props.onAnimationEnd]));
			}
		},
		{
			key: "runAnimation",
			value: function runAnimation(props) {
				if (!this.manager) this.manager = createAnimateManager();
				var begin = props.begin, duration = props.duration, attributeName = props.attributeName, propsTo = props.to, easing = props.easing, onAnimationStart = props.onAnimationStart, onAnimationEnd = props.onAnimationEnd, steps = props.steps, children = props.children;
				var manager = this.manager;
				this.unSubscribe = manager.subscribe(this.handleStyleChange);
				if (typeof easing === "function" || typeof children === "function" || easing === "spring") {
					this.runJSAnimation(props);
					return;
				}
				if (steps.length > 1) {
					this.runStepAnimation(props);
					return;
				}
				var to = attributeName ? _defineProperty$20({}, attributeName, propsTo) : propsTo;
				var transition = getTransitionVal(Object.keys(to), duration, easing);
				manager.start([
					onAnimationStart,
					begin,
					_objectSpread$17(_objectSpread$17({}, to), {}, { transition }),
					duration,
					onAnimationEnd
				]);
			}
		},
		{
			key: "render",
			value: function render() {
				var _this$props4 = this.props, children = _this$props4.children;
				_this$props4.begin;
				var duration = _this$props4.duration;
				_this$props4.attributeName;
				_this$props4.easing;
				var isActive = _this$props4.isActive;
				_this$props4.steps;
				_this$props4.from;
				_this$props4.to;
				_this$props4.canBegin;
				_this$props4.onAnimationEnd;
				_this$props4.shouldReAnimate;
				_this$props4.onAnimationReStart;
				var others = _objectWithoutProperties$7(_this$props4, _excluded$7);
				var count = import_react.Children.count(children);
				var stateStyle = this.state.style;
				if (typeof children === "function") return children(stateStyle);
				if (!isActive || count === 0 || duration <= 0) return children;
				var cloneContainer = function cloneContainer$1(container) {
					var _container$props = container.props, _container$props$styl = _container$props.style, style = _container$props$styl === void 0 ? {} : _container$props$styl, className = _container$props.className;
					return /* @__PURE__ */ (0, import_react.cloneElement)(container, _objectSpread$17(_objectSpread$17({}, others), {}, {
						style: _objectSpread$17(_objectSpread$17({}, style), stateStyle),
						className
					}));
				};
				if (count === 1) return cloneContainer(import_react.Children.only(children));
				return /* @__PURE__ */ import_react.createElement("div", null, import_react.Children.map(children, function(child) {
					return cloneContainer(child);
				}));
			}
		}
	]);
	return Animate$1;
}(import_react.PureComponent);
Animate.displayName = "Animate";
Animate.defaultProps = {
	begin: 0,
	duration: 1e3,
	from: "",
	to: "",
	attributeName: "",
	easing: "ease",
	isActive: true,
	canBegin: true,
	steps: [],
	onAnimationEnd: function onAnimationEnd() {},
	onAnimationStart: function onAnimationStart() {}
};
Animate.propTypes = {
	from: import_prop_types.default.oneOfType([import_prop_types.default.object, import_prop_types.default.string]),
	to: import_prop_types.default.oneOfType([import_prop_types.default.object, import_prop_types.default.string]),
	attributeName: import_prop_types.default.string,
	duration: import_prop_types.default.number,
	begin: import_prop_types.default.number,
	easing: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func]),
	steps: import_prop_types.default.arrayOf(import_prop_types.default.shape({
		duration: import_prop_types.default.number.isRequired,
		style: import_prop_types.default.object.isRequired,
		easing: import_prop_types.default.oneOfType([import_prop_types.default.oneOf([
			"ease",
			"ease-in",
			"ease-out",
			"ease-in-out",
			"linear"
		]), import_prop_types.default.func]),
		properties: import_prop_types.default.arrayOf("string"),
		onAnimationEnd: import_prop_types.default.func
	})),
	children: import_prop_types.default.oneOfType([import_prop_types.default.node, import_prop_types.default.func]),
	isActive: import_prop_types.default.bool,
	canBegin: import_prop_types.default.bool,
	onAnimationEnd: import_prop_types.default.func,
	shouldReAnimate: import_prop_types.default.bool,
	onAnimationStart: import_prop_types.default.func,
	onAnimationReStart: import_prop_types.default.func
};
var es6_default = Animate;
function _typeof$20(o) {
	"@babel/helpers - typeof";
	return _typeof$20 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$20(o);
}
function _extends$14() {
	_extends$14 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$14.apply(this, arguments);
}
function _slicedToArray$3(arr, i) {
	return _arrayWithHoles$3(arr) || _iterableToArrayLimit$3(arr, i) || _unsupportedIterableToArray$4(arr, i) || _nonIterableRest$3();
}
function _nonIterableRest$3() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$4(o, minLen) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$4(o, minLen);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen);
}
function _arrayLikeToArray$4(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$3(r, l) {
	var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a$1 = [], f = !0, o = !1;
		try {
			if (i = (t = t.call(r)).next, 0 === l) {
				if (Object(t) !== t) return;
				f = !1;
			} else for (; !(f = (e = i.call(t)).done) && (a$1.push(e.value), a$1.length !== l); f = !0);
		} catch (r$1) {
			o = !0, n = r$1;
		} finally {
			try {
				if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a$1;
	}
}
function _arrayWithHoles$3(arr) {
	if (Array.isArray(arr)) return arr;
}
function ownKeys$16(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$16(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$16(Object(t), !0).forEach(function(r$1) {
			_defineProperty$19(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$16(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}
function _defineProperty$19(obj, key, value) {
	key = _toPropertyKey$19(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$19(t) {
	var i = _toPrimitive$19(t, "string");
	return "symbol" == _typeof$20(i) ? i : i + "";
}
function _toPrimitive$19(t, r) {
	if ("object" != _typeof$20(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$20(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
var getRectanglePath = function getRectanglePath$1(x$1, y$1, width, height, radius) {
	var maxRadius = Math.min(Math.abs(width) / 2, Math.abs(height) / 2);
	var ySign = height >= 0 ? 1 : -1;
	var xSign = width >= 0 ? 1 : -1;
	var clockWise = height >= 0 && width >= 0 || height < 0 && width < 0 ? 1 : 0;
	var path$1;
	if (maxRadius > 0 && radius instanceof Array) {
		var newRadius = [
			0,
			0,
			0,
			0
		];
		for (var i = 0, len = 4; i < len; i++) newRadius[i] = radius[i] > maxRadius ? maxRadius : radius[i];
		path$1 = "M".concat(x$1, ",").concat(y$1 + ySign * newRadius[0]);
		if (newRadius[0] > 0) path$1 += "A ".concat(newRadius[0], ",").concat(newRadius[0], ",0,0,").concat(clockWise, ",").concat(x$1 + xSign * newRadius[0], ",").concat(y$1);
		path$1 += "L ".concat(x$1 + width - xSign * newRadius[1], ",").concat(y$1);
		if (newRadius[1] > 0) path$1 += "A ".concat(newRadius[1], ",").concat(newRadius[1], ",0,0,").concat(clockWise, ",\n        ").concat(x$1 + width, ",").concat(y$1 + ySign * newRadius[1]);
		path$1 += "L ".concat(x$1 + width, ",").concat(y$1 + height - ySign * newRadius[2]);
		if (newRadius[2] > 0) path$1 += "A ".concat(newRadius[2], ",").concat(newRadius[2], ",0,0,").concat(clockWise, ",\n        ").concat(x$1 + width - xSign * newRadius[2], ",").concat(y$1 + height);
		path$1 += "L ".concat(x$1 + xSign * newRadius[3], ",").concat(y$1 + height);
		if (newRadius[3] > 0) path$1 += "A ".concat(newRadius[3], ",").concat(newRadius[3], ",0,0,").concat(clockWise, ",\n        ").concat(x$1, ",").concat(y$1 + height - ySign * newRadius[3]);
		path$1 += "Z";
	} else if (maxRadius > 0 && radius === +radius && radius > 0) {
		var _newRadius = Math.min(maxRadius, radius);
		path$1 = "M ".concat(x$1, ",").concat(y$1 + ySign * _newRadius, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x$1 + xSign * _newRadius, ",").concat(y$1, "\n            L ").concat(x$1 + width - xSign * _newRadius, ",").concat(y$1, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x$1 + width, ",").concat(y$1 + ySign * _newRadius, "\n            L ").concat(x$1 + width, ",").concat(y$1 + height - ySign * _newRadius, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x$1 + width - xSign * _newRadius, ",").concat(y$1 + height, "\n            L ").concat(x$1 + xSign * _newRadius, ",").concat(y$1 + height, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x$1, ",").concat(y$1 + height - ySign * _newRadius, " Z");
	} else path$1 = "M ".concat(x$1, ",").concat(y$1, " h ").concat(width, " v ").concat(height, " h ").concat(-width, " Z");
	return path$1;
};
var isInRectangle = function isInRectangle$1(point$3, rect) {
	if (!point$3 || !rect) return false;
	var px = point$3.x, py = point$3.y;
	var x$1 = rect.x, y$1 = rect.y, width = rect.width, height = rect.height;
	if (Math.abs(width) > 0 && Math.abs(height) > 0) {
		var minX = Math.min(x$1, x$1 + width);
		var maxX = Math.max(x$1, x$1 + width);
		var minY = Math.min(y$1, y$1 + height);
		var maxY = Math.max(y$1, y$1 + height);
		return px >= minX && px <= maxX && py >= minY && py <= maxY;
	}
	return false;
};
var defaultProps$2 = {
	x: 0,
	y: 0,
	width: 0,
	height: 0,
	radius: 0,
	isAnimationActive: false,
	isUpdateAnimationActive: false,
	animationBegin: 0,
	animationDuration: 1500,
	animationEasing: "ease"
};
var Rectangle = function Rectangle$1(rectangleProps) {
	var props = _objectSpread$16(_objectSpread$16({}, defaultProps$2), rectangleProps);
	var pathRef = (0, import_react.useRef)();
	var _useState2 = _slicedToArray$3((0, import_react.useState)(-1), 2), totalLength = _useState2[0], setTotalLength = _useState2[1];
	(0, import_react.useEffect)(function() {
		if (pathRef.current && pathRef.current.getTotalLength) try {
			var pathTotalLength = pathRef.current.getTotalLength();
			if (pathTotalLength) setTotalLength(pathTotalLength);
		} catch (err) {}
	}, []);
	var x$1 = props.x, y$1 = props.y, width = props.width, height = props.height, radius = props.radius, className = props.className;
	var animationEasing = props.animationEasing, animationDuration = props.animationDuration, animationBegin = props.animationBegin, isAnimationActive = props.isAnimationActive, isUpdateAnimationActive = props.isUpdateAnimationActive;
	if (x$1 !== +x$1 || y$1 !== +y$1 || width !== +width || height !== +height || width === 0 || height === 0) return null;
	var layerClass = clsx_default("recharts-rectangle", className);
	if (!isUpdateAnimationActive) return /* @__PURE__ */ import_react.createElement("path", _extends$14({}, filterProps(props, true), {
		className: layerClass,
		d: getRectanglePath(x$1, y$1, width, height, radius)
	}));
	return /* @__PURE__ */ import_react.createElement(es6_default, {
		canBegin: totalLength > 0,
		from: {
			width,
			height,
			x: x$1,
			y: y$1
		},
		to: {
			width,
			height,
			x: x$1,
			y: y$1
		},
		duration: animationDuration,
		animationEasing,
		isActive: isUpdateAnimationActive
	}, function(_ref) {
		var currWidth = _ref.width, currHeight = _ref.height, currX = _ref.x, currY = _ref.y;
		return /* @__PURE__ */ import_react.createElement(es6_default, {
			canBegin: totalLength > 0,
			from: "0px ".concat(totalLength === -1 ? 1 : totalLength, "px"),
			to: "".concat(totalLength, "px 0px"),
			attributeName: "strokeDasharray",
			begin: animationBegin,
			duration: animationDuration,
			isActive: isAnimationActive,
			easing: animationEasing
		}, /* @__PURE__ */ import_react.createElement("path", _extends$14({}, filterProps(props, true), {
			className: layerClass,
			d: getRectanglePath(currX, currY, currWidth, currHeight, radius),
			ref: pathRef
		})));
	});
};
function _extends$13() {
	_extends$13 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$13.apply(this, arguments);
}
var Dot = function Dot$1(props) {
	var cx = props.cx, cy = props.cy, r = props.r, className = props.className;
	var layerClass = clsx_default("recharts-dot", className);
	if (cx === +cx && cy === +cy && r === +r) return /* @__PURE__ */ import_react.createElement("circle", _extends$13({}, filterProps(props, false), adaptEventHandlers(props), {
		className: layerClass,
		cx,
		cy,
		r
	}));
	return null;
};
function _typeof$19(o) {
	"@babel/helpers - typeof";
	return _typeof$19 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$19(o);
}
var _excluded$6 = [
	"x",
	"y",
	"top",
	"left",
	"width",
	"height",
	"className"
];
function _extends$12() {
	_extends$12 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$12.apply(this, arguments);
}
function ownKeys$15(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$15(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$15(Object(t), !0).forEach(function(r$1) {
			_defineProperty$18(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$15(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}
function _defineProperty$18(obj, key, value) {
	key = _toPropertyKey$18(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$18(t) {
	var i = _toPrimitive$18(t, "string");
	return "symbol" == _typeof$19(i) ? i : i + "";
}
function _toPrimitive$18(t, r) {
	if ("object" != _typeof$19(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$19(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
function _objectWithoutProperties$6(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$6(source, excluded);
	var key, i;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i = 0; i < sourceSymbolKeys.length; i++) {
			key = sourceSymbolKeys[i];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$6(source, excluded) {
	if (source == null) return {};
	var target = {};
	for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
var getPath = function getPath$2(x$1, y$1, width, height, top, left) {
	return "M".concat(x$1, ",").concat(top, "v").concat(height, "M").concat(left, ",").concat(y$1, "h").concat(width);
};
var Cross = function Cross$1(_ref) {
	var _ref$x = _ref.x, x$1 = _ref$x === void 0 ? 0 : _ref$x, _ref$y = _ref.y, y$1 = _ref$y === void 0 ? 0 : _ref$y, _ref$top = _ref.top, top = _ref$top === void 0 ? 0 : _ref$top, _ref$left = _ref.left, left = _ref$left === void 0 ? 0 : _ref$left, _ref$width = _ref.width, width = _ref$width === void 0 ? 0 : _ref$width, _ref$height = _ref.height, height = _ref$height === void 0 ? 0 : _ref$height, className = _ref.className, rest = _objectWithoutProperties$6(_ref, _excluded$6);
	var props = _objectSpread$15({
		x: x$1,
		y: y$1,
		top,
		left,
		width,
		height
	}, rest);
	if (!isNumber(x$1) || !isNumber(y$1) || !isNumber(width) || !isNumber(height) || !isNumber(top) || !isNumber(left)) return null;
	return /* @__PURE__ */ import_react.createElement("path", _extends$12({}, filterProps(props, true), {
		className: clsx_default("recharts-cross", className),
		d: getPath(x$1, y$1, width, height, top, left)
	}));
};
var require__getPrototype = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__overArg()(Object.getPrototypeOf, Object);
}));
var require_isPlainObject = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseGetTag$1 = require__baseGetTag(), getPrototype = require__getPrototype(), isObjectLike$1 = require_isObjectLike();
	var objectTag = "[object Object]";
	var funcProto = Function.prototype, objectProto = Object.prototype;
	var funcToString = funcProto.toString;
	var hasOwnProperty = objectProto.hasOwnProperty;
	var objectCtorString = funcToString.call(Object);
	function isPlainObject$1(value) {
		if (!isObjectLike$1(value) || baseGetTag$1(value) != objectTag) return false;
		var proto = getPrototype(value);
		if (proto === null) return true;
		var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
		return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
	}
	module.exports = isPlainObject$1;
}));
var require_isBoolean = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseGetTag = require__baseGetTag(), isObjectLike = require_isObjectLike();
	var boolTag = "[object Boolean]";
	function isBoolean$1(value) {
		return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
	}
	module.exports = isBoolean$1;
}));
function _typeof$18(o) {
	"@babel/helpers - typeof";
	return _typeof$18 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$18(o);
}
function _extends$11() {
	_extends$11 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$11.apply(this, arguments);
}
function _slicedToArray$2(arr, i) {
	return _arrayWithHoles$2(arr) || _iterableToArrayLimit$2(arr, i) || _unsupportedIterableToArray$3(arr, i) || _nonIterableRest$2();
}
function _nonIterableRest$2() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$3(o, minLen) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$3(o, minLen);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen);
}
function _arrayLikeToArray$3(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$2(r, l) {
	var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a$1 = [], f = !0, o = !1;
		try {
			if (i = (t = t.call(r)).next, 0 === l) {
				if (Object(t) !== t) return;
				f = !1;
			} else for (; !(f = (e = i.call(t)).done) && (a$1.push(e.value), a$1.length !== l); f = !0);
		} catch (r$1) {
			o = !0, n = r$1;
		} finally {
			try {
				if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a$1;
	}
}
function _arrayWithHoles$2(arr) {
	if (Array.isArray(arr)) return arr;
}
function ownKeys$14(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$14(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$14(Object(t), !0).forEach(function(r$1) {
			_defineProperty$17(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$14(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}
function _defineProperty$17(obj, key, value) {
	key = _toPropertyKey$17(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$17(t) {
	var i = _toPrimitive$17(t, "string");
	return "symbol" == _typeof$18(i) ? i : i + "";
}
function _toPrimitive$17(t, r) {
	if ("object" != _typeof$18(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$18(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
var getTrapezoidPath = function getTrapezoidPath$1(x$1, y$1, upperWidth, lowerWidth, height) {
	var widthGap = upperWidth - lowerWidth;
	var path$1 = "M ".concat(x$1, ",").concat(y$1);
	path$1 += "L ".concat(x$1 + upperWidth, ",").concat(y$1);
	path$1 += "L ".concat(x$1 + upperWidth - widthGap / 2, ",").concat(y$1 + height);
	path$1 += "L ".concat(x$1 + upperWidth - widthGap / 2 - lowerWidth, ",").concat(y$1 + height);
	path$1 += "L ".concat(x$1, ",").concat(y$1, " Z");
	return path$1;
};
var defaultProps$1 = {
	x: 0,
	y: 0,
	upperWidth: 0,
	lowerWidth: 0,
	height: 0,
	isUpdateAnimationActive: false,
	animationBegin: 0,
	animationDuration: 1500,
	animationEasing: "ease"
};
var Trapezoid = function Trapezoid$1(props) {
	var trapezoidProps = _objectSpread$14(_objectSpread$14({}, defaultProps$1), props);
	var pathRef = (0, import_react.useRef)();
	var _useState2 = _slicedToArray$2((0, import_react.useState)(-1), 2), totalLength = _useState2[0], setTotalLength = _useState2[1];
	(0, import_react.useEffect)(function() {
		if (pathRef.current && pathRef.current.getTotalLength) try {
			var pathTotalLength = pathRef.current.getTotalLength();
			if (pathTotalLength) setTotalLength(pathTotalLength);
		} catch (err) {}
	}, []);
	var x$1 = trapezoidProps.x, y$1 = trapezoidProps.y, upperWidth = trapezoidProps.upperWidth, lowerWidth = trapezoidProps.lowerWidth, height = trapezoidProps.height, className = trapezoidProps.className;
	var animationEasing = trapezoidProps.animationEasing, animationDuration = trapezoidProps.animationDuration, animationBegin = trapezoidProps.animationBegin, isUpdateAnimationActive = trapezoidProps.isUpdateAnimationActive;
	if (x$1 !== +x$1 || y$1 !== +y$1 || upperWidth !== +upperWidth || lowerWidth !== +lowerWidth || height !== +height || upperWidth === 0 && lowerWidth === 0 || height === 0) return null;
	var layerClass = clsx_default("recharts-trapezoid", className);
	if (!isUpdateAnimationActive) return /* @__PURE__ */ import_react.createElement("g", null, /* @__PURE__ */ import_react.createElement("path", _extends$11({}, filterProps(trapezoidProps, true), {
		className: layerClass,
		d: getTrapezoidPath(x$1, y$1, upperWidth, lowerWidth, height)
	})));
	return /* @__PURE__ */ import_react.createElement(es6_default, {
		canBegin: totalLength > 0,
		from: {
			upperWidth: 0,
			lowerWidth: 0,
			height,
			x: x$1,
			y: y$1
		},
		to: {
			upperWidth,
			lowerWidth,
			height,
			x: x$1,
			y: y$1
		},
		duration: animationDuration,
		animationEasing,
		isActive: isUpdateAnimationActive
	}, function(_ref) {
		var currUpperWidth = _ref.upperWidth, currLowerWidth = _ref.lowerWidth, currHeight = _ref.height, currX = _ref.x, currY = _ref.y;
		return /* @__PURE__ */ import_react.createElement(es6_default, {
			canBegin: totalLength > 0,
			from: "0px ".concat(totalLength === -1 ? 1 : totalLength, "px"),
			to: "".concat(totalLength, "px 0px"),
			attributeName: "strokeDasharray",
			begin: animationBegin,
			duration: animationDuration,
			easing: animationEasing
		}, /* @__PURE__ */ import_react.createElement("path", _extends$11({}, filterProps(trapezoidProps, true), {
			className: layerClass,
			d: getTrapezoidPath(currX, currY, currUpperWidth, currLowerWidth, currHeight),
			ref: pathRef
		})));
	});
};
var import_isFunction$8 = /* @__PURE__ */ __toESM(require_isFunction());
var import_isPlainObject = /* @__PURE__ */ __toESM(require_isPlainObject());
var import_isBoolean = /* @__PURE__ */ __toESM(require_isBoolean());
var import_isEqual$1 = /* @__PURE__ */ __toESM(require_isEqual());
var _excluded$5 = [
	"option",
	"shapeType",
	"propTransformer",
	"activeClassName",
	"isActive"
];
function _typeof$17(o) {
	"@babel/helpers - typeof";
	return _typeof$17 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$17(o);
}
function _objectWithoutProperties$5(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$5(source, excluded);
	var key, i;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i = 0; i < sourceSymbolKeys.length; i++) {
			key = sourceSymbolKeys[i];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$5(source, excluded) {
	if (source == null) return {};
	var target = {};
	for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function ownKeys$13(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$13(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$13(Object(t), !0).forEach(function(r$1) {
			_defineProperty$16(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$13(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}
function _defineProperty$16(obj, key, value) {
	key = _toPropertyKey$16(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$16(t) {
	var i = _toPrimitive$16(t, "string");
	return "symbol" == _typeof$17(i) ? i : i + "";
}
function _toPrimitive$16(t, r) {
	if ("object" != _typeof$17(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$17(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
function defaultPropTransformer(option, props) {
	return _objectSpread$13(_objectSpread$13({}, props), option);
}
function isSymbolsProps(shapeType, _elementProps) {
	return shapeType === "symbols";
}
function ShapeSelector(_ref) {
	var shapeType = _ref.shapeType, elementProps = _ref.elementProps;
	switch (shapeType) {
		case "rectangle": return /* @__PURE__ */ import_react.createElement(Rectangle, elementProps);
		case "trapezoid": return /* @__PURE__ */ import_react.createElement(Trapezoid, elementProps);
		case "sector": return /* @__PURE__ */ import_react.createElement(Sector, elementProps);
		case "symbols":
			if (isSymbolsProps(shapeType, elementProps)) return /* @__PURE__ */ import_react.createElement(Symbols, elementProps);
			break;
		default: return null;
	}
}
function getPropsFromShapeOption(option) {
	if (/* @__PURE__ */ (0, import_react.isValidElement)(option)) return option.props;
	return option;
}
function Shape(_ref2) {
	var option = _ref2.option, shapeType = _ref2.shapeType, _ref2$propTransformer = _ref2.propTransformer, propTransformer = _ref2$propTransformer === void 0 ? defaultPropTransformer : _ref2$propTransformer, _ref2$activeClassName = _ref2.activeClassName, activeClassName = _ref2$activeClassName === void 0 ? "recharts-active-shape" : _ref2$activeClassName, isActive = _ref2.isActive, props = _objectWithoutProperties$5(_ref2, _excluded$5);
	var shape;
	if (/* @__PURE__ */ (0, import_react.isValidElement)(option)) shape = /* @__PURE__ */ (0, import_react.cloneElement)(option, _objectSpread$13(_objectSpread$13({}, props), getPropsFromShapeOption(option)));
	else if ((0, import_isFunction$8.default)(option)) shape = option(props);
	else if ((0, import_isPlainObject.default)(option) && !(0, import_isBoolean.default)(option)) {
		var nextProps = propTransformer(option, props);
		shape = /* @__PURE__ */ import_react.createElement(ShapeSelector, {
			shapeType,
			elementProps: nextProps
		});
	} else {
		var elementProps = props;
		shape = /* @__PURE__ */ import_react.createElement(ShapeSelector, {
			shapeType,
			elementProps
		});
	}
	if (isActive) return /* @__PURE__ */ import_react.createElement(Layer, { className: activeClassName }, shape);
	return shape;
}
function isFunnel(graphicalItem, _item) {
	return _item != null && "trapezoids" in graphicalItem.props;
}
function isPie(graphicalItem, _item) {
	return _item != null && "sectors" in graphicalItem.props;
}
function isScatter(graphicalItem, _item) {
	return _item != null && "points" in graphicalItem.props;
}
function compareFunnel(shapeData, activeTooltipItem) {
	var _activeTooltipItem$la, _activeTooltipItem$la2;
	var xMatches = shapeData.x === (activeTooltipItem === null || activeTooltipItem === void 0 || (_activeTooltipItem$la = activeTooltipItem.labelViewBox) === null || _activeTooltipItem$la === void 0 ? void 0 : _activeTooltipItem$la.x) || shapeData.x === activeTooltipItem.x;
	var yMatches = shapeData.y === (activeTooltipItem === null || activeTooltipItem === void 0 || (_activeTooltipItem$la2 = activeTooltipItem.labelViewBox) === null || _activeTooltipItem$la2 === void 0 ? void 0 : _activeTooltipItem$la2.y) || shapeData.y === activeTooltipItem.y;
	return xMatches && yMatches;
}
function comparePie(shapeData, activeTooltipItem) {
	var startAngleMatches = shapeData.endAngle === activeTooltipItem.endAngle;
	var endAngleMatches = shapeData.startAngle === activeTooltipItem.startAngle;
	return startAngleMatches && endAngleMatches;
}
function compareScatter(shapeData, activeTooltipItem) {
	var xMatches = shapeData.x === activeTooltipItem.x;
	var yMatches = shapeData.y === activeTooltipItem.y;
	var zMatches = shapeData.z === activeTooltipItem.z;
	return xMatches && yMatches && zMatches;
}
function getComparisonFn(graphicalItem, activeItem) {
	var comparison;
	if (isFunnel(graphicalItem, activeItem)) comparison = compareFunnel;
	else if (isPie(graphicalItem, activeItem)) comparison = comparePie;
	else if (isScatter(graphicalItem, activeItem)) comparison = compareScatter;
	return comparison;
}
function getShapeDataKey(graphicalItem, activeItem) {
	var shapeKey;
	if (isFunnel(graphicalItem, activeItem)) shapeKey = "trapezoids";
	else if (isPie(graphicalItem, activeItem)) shapeKey = "sectors";
	else if (isScatter(graphicalItem, activeItem)) shapeKey = "points";
	return shapeKey;
}
function getActiveShapeTooltipPayload(graphicalItem, activeItem) {
	if (isFunnel(graphicalItem, activeItem)) {
		var _activeItem$tooltipPa;
		return (_activeItem$tooltipPa = activeItem.tooltipPayload) === null || _activeItem$tooltipPa === void 0 || (_activeItem$tooltipPa = _activeItem$tooltipPa[0]) === null || _activeItem$tooltipPa === void 0 || (_activeItem$tooltipPa = _activeItem$tooltipPa.payload) === null || _activeItem$tooltipPa === void 0 ? void 0 : _activeItem$tooltipPa.payload;
	}
	if (isPie(graphicalItem, activeItem)) {
		var _activeItem$tooltipPa2;
		return (_activeItem$tooltipPa2 = activeItem.tooltipPayload) === null || _activeItem$tooltipPa2 === void 0 || (_activeItem$tooltipPa2 = _activeItem$tooltipPa2[0]) === null || _activeItem$tooltipPa2 === void 0 || (_activeItem$tooltipPa2 = _activeItem$tooltipPa2.payload) === null || _activeItem$tooltipPa2 === void 0 ? void 0 : _activeItem$tooltipPa2.payload;
	}
	if (isScatter(graphicalItem, activeItem)) return activeItem.payload;
	return {};
}
function getActiveShapeIndexForTooltip(_ref3) {
	var activeTooltipItem = _ref3.activeTooltipItem, graphicalItem = _ref3.graphicalItem, itemData = _ref3.itemData;
	var shapeKey = getShapeDataKey(graphicalItem, activeTooltipItem);
	var tooltipPayload = getActiveShapeTooltipPayload(graphicalItem, activeTooltipItem);
	var activeItemMatches = itemData.filter(function(datum, dataIndex) {
		var valuesMatch = (0, import_isEqual$1.default)(tooltipPayload, datum);
		var mouseCoordinateMatches = graphicalItem.props[shapeKey].filter(function(shapeData) {
			return getComparisonFn(graphicalItem, activeTooltipItem)(shapeData, activeTooltipItem);
		});
		var coordinatesMatch = dataIndex === graphicalItem.props[shapeKey].indexOf(mouseCoordinateMatches[mouseCoordinateMatches.length - 1]);
		return valuesMatch && coordinatesMatch;
	});
	return itemData.indexOf(activeItemMatches[activeItemMatches.length - 1]);
}
var require__baseRange = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var nativeCeil = Math.ceil, nativeMax$1 = Math.max;
	function baseRange$1(start, end, step, fromRight) {
		var index = -1, length = nativeMax$1(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);
		while (length--) {
			result[fromRight ? length : ++index] = start;
			start += step;
		}
		return result;
	}
	module.exports = baseRange$1;
}));
var require_toFinite = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var toNumber = require_toNumber();
	var INFINITY = Infinity, MAX_INTEGER = 17976931348623157e292;
	function toFinite$2(value) {
		if (!value) return value === 0 ? value : 0;
		value = toNumber(value);
		if (value === INFINITY || value === -INFINITY) return (value < 0 ? -1 : 1) * MAX_INTEGER;
		return value === value ? value : 0;
	}
	module.exports = toFinite$2;
}));
var require__createRange = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseRange = require__baseRange(), isIterateeCall$2 = require__isIterateeCall(), toFinite$1 = require_toFinite();
	function createRange(fromRight) {
		return function(start, end, step) {
			if (step && typeof step != "number" && isIterateeCall$2(start, end, step)) end = step = void 0;
			start = toFinite$1(start);
			if (end === void 0) {
				end = start;
				start = 0;
			} else end = toFinite$1(end);
			step = step === void 0 ? start < end ? 1 : -1 : toFinite$1(step);
			return baseRange(start, end, step, fromRight);
		};
	}
	module.exports = createRange;
}));
var require_range = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__createRange()();
}));
function _typeof$16(o) {
	"@babel/helpers - typeof";
	return _typeof$16 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$16(o);
}
function ownKeys$12(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$12(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$12(Object(t), !0).forEach(function(r$1) {
			_defineProperty$15(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$12(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}
function _defineProperty$15(obj, key, value) {
	key = _toPropertyKey$15(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$15(t) {
	var i = _toPrimitive$15(t, "string");
	return "symbol" == _typeof$16(i) ? i : i + "";
}
function _toPrimitive$15(t, r) {
	if ("object" != _typeof$16(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$16(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
var PREFIX_LIST = [
	"Webkit",
	"Moz",
	"O",
	"ms"
];
var generatePrefixStyle = function generatePrefixStyle$1(name, value) {
	if (!name) return null;
	var camelName = name.replace(/(\w)/, function(v) {
		return v.toUpperCase();
	});
	var result = PREFIX_LIST.reduce(function(res, entry) {
		return _objectSpread$12(_objectSpread$12({}, res), {}, _defineProperty$15({}, entry + camelName, value));
	}, {});
	result[name] = value;
	return result;
};
var import_isFunction$7 = /* @__PURE__ */ __toESM(require_isFunction());
var import_range$1 = /* @__PURE__ */ __toESM(require_range());
function _typeof$15(o) {
	"@babel/helpers - typeof";
	return _typeof$15 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$15(o);
}
function _extends$10() {
	_extends$10 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$10.apply(this, arguments);
}
function ownKeys$11(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$11(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$11(Object(t), !0).forEach(function(r$1) {
			_defineProperty$14(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$11(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}
function _classCallCheck$10(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$10(target, props) {
	for (var i = 0; i < props.length; i++) {
		var descriptor = props[i];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$14(descriptor.key), descriptor);
	}
}
function _createClass$10(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$10(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$10(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _callSuper$8(t, o, e) {
	return o = _getPrototypeOf$8(o), _possibleConstructorReturn$8(t, _isNativeReflectConstruct$8() ? Reflect.construct(o, e || [], _getPrototypeOf$8(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn$8(self$1, call) {
	if (call && (_typeof$15(call) === "object" || typeof call === "function")) return call;
	else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
	return _assertThisInitialized$8(self$1);
}
function _assertThisInitialized$8(self$1) {
	if (self$1 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return self$1;
}
function _isNativeReflectConstruct$8() {
	try {
		var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
	} catch (t$1) {}
	return (_isNativeReflectConstruct$8 = function _isNativeReflectConstruct$15() {
		return !!t;
	})();
}
function _getPrototypeOf$8(o) {
	_getPrototypeOf$8 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf$15(o$1) {
		return o$1.__proto__ || Object.getPrototypeOf(o$1);
	};
	return _getPrototypeOf$8(o);
}
function _inherits$8(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
	subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
		value: subClass,
		writable: true,
		configurable: true
	} });
	Object.defineProperty(subClass, "prototype", { writable: false });
	if (superClass) _setPrototypeOf$8(subClass, superClass);
}
function _setPrototypeOf$8(o, p) {
	_setPrototypeOf$8 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf$15(o$1, p$1) {
		o$1.__proto__ = p$1;
		return o$1;
	};
	return _setPrototypeOf$8(o, p);
}
function _defineProperty$14(obj, key, value) {
	key = _toPropertyKey$14(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$14(t) {
	var i = _toPrimitive$14(t, "string");
	return "symbol" == _typeof$15(i) ? i : i + "";
}
function _toPrimitive$14(t, r) {
	if ("object" != _typeof$15(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$15(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
var createScale = function createScale$1(_ref) {
	var data = _ref.data, startIndex = _ref.startIndex, endIndex = _ref.endIndex, x$1 = _ref.x, width = _ref.width, travellerWidth = _ref.travellerWidth;
	if (!data || !data.length) return {};
	var len = data.length;
	var scale = point().domain((0, import_range$1.default)(0, len)).range([x$1, x$1 + width - travellerWidth]);
	var scaleValues = scale.domain().map(function(entry) {
		return scale(entry);
	});
	return {
		isTextActive: false,
		isSlideMoving: false,
		isTravellerMoving: false,
		isTravellerFocused: false,
		startX: scale(startIndex),
		endX: scale(endIndex),
		scale,
		scaleValues
	};
};
var isTouch = function isTouch$1(e) {
	return e.changedTouches && !!e.changedTouches.length;
};
var Brush = /* @__PURE__ */ function(_PureComponent) {
	function Brush$1(props) {
		var _this;
		_classCallCheck$10(this, Brush$1);
		_this = _callSuper$8(this, Brush$1, [props]);
		_defineProperty$14(_this, "handleDrag", function(e) {
			if (_this.leaveTimer) {
				clearTimeout(_this.leaveTimer);
				_this.leaveTimer = null;
			}
			if (_this.state.isTravellerMoving) _this.handleTravellerMove(e);
			else if (_this.state.isSlideMoving) _this.handleSlideDrag(e);
		});
		_defineProperty$14(_this, "handleTouchMove", function(e) {
			if (e.changedTouches != null && e.changedTouches.length > 0) _this.handleDrag(e.changedTouches[0]);
		});
		_defineProperty$14(_this, "handleDragEnd", function() {
			_this.setState({
				isTravellerMoving: false,
				isSlideMoving: false
			}, function() {
				var _this$props = _this.props, endIndex = _this$props.endIndex, onDragEnd = _this$props.onDragEnd, startIndex = _this$props.startIndex;
				onDragEnd === null || onDragEnd === void 0 || onDragEnd({
					endIndex,
					startIndex
				});
			});
			_this.detachDragEndListener();
		});
		_defineProperty$14(_this, "handleLeaveWrapper", function() {
			if (_this.state.isTravellerMoving || _this.state.isSlideMoving) _this.leaveTimer = window.setTimeout(_this.handleDragEnd, _this.props.leaveTimeOut);
		});
		_defineProperty$14(_this, "handleEnterSlideOrTraveller", function() {
			_this.setState({ isTextActive: true });
		});
		_defineProperty$14(_this, "handleLeaveSlideOrTraveller", function() {
			_this.setState({ isTextActive: false });
		});
		_defineProperty$14(_this, "handleSlideDragStart", function(e) {
			var event = isTouch(e) ? e.changedTouches[0] : e;
			_this.setState({
				isTravellerMoving: false,
				isSlideMoving: true,
				slideMoveStartX: event.pageX
			});
			_this.attachDragEndListener();
		});
		_this.travellerDragStartHandlers = {
			startX: _this.handleTravellerDragStart.bind(_this, "startX"),
			endX: _this.handleTravellerDragStart.bind(_this, "endX")
		};
		_this.state = {};
		return _this;
	}
	_inherits$8(Brush$1, _PureComponent);
	return _createClass$10(Brush$1, [
		{
			key: "componentWillUnmount",
			value: function componentWillUnmount() {
				if (this.leaveTimer) {
					clearTimeout(this.leaveTimer);
					this.leaveTimer = null;
				}
				this.detachDragEndListener();
			}
		},
		{
			key: "getIndex",
			value: function getIndex(_ref2) {
				var startX = _ref2.startX, endX = _ref2.endX;
				var scaleValues = this.state.scaleValues;
				var _this$props2 = this.props, gap = _this$props2.gap;
				var lastIndex = _this$props2.data.length - 1;
				var min$3 = Math.min(startX, endX);
				var max$3 = Math.max(startX, endX);
				var minIndex = Brush$1.getIndexInRange(scaleValues, min$3);
				var maxIndex = Brush$1.getIndexInRange(scaleValues, max$3);
				return {
					startIndex: minIndex - minIndex % gap,
					endIndex: maxIndex === lastIndex ? lastIndex : maxIndex - maxIndex % gap
				};
			}
		},
		{
			key: "getTextOfTick",
			value: function getTextOfTick(index) {
				var _this$props3 = this.props, data = _this$props3.data, tickFormatter = _this$props3.tickFormatter, dataKey = _this$props3.dataKey;
				var text = getValueByDataKey(data[index], dataKey, index);
				return (0, import_isFunction$7.default)(tickFormatter) ? tickFormatter(text, index) : text;
			}
		},
		{
			key: "attachDragEndListener",
			value: function attachDragEndListener() {
				window.addEventListener("mouseup", this.handleDragEnd, true);
				window.addEventListener("touchend", this.handleDragEnd, true);
				window.addEventListener("mousemove", this.handleDrag, true);
			}
		},
		{
			key: "detachDragEndListener",
			value: function detachDragEndListener() {
				window.removeEventListener("mouseup", this.handleDragEnd, true);
				window.removeEventListener("touchend", this.handleDragEnd, true);
				window.removeEventListener("mousemove", this.handleDrag, true);
			}
		},
		{
			key: "handleSlideDrag",
			value: function handleSlideDrag(e) {
				var _this$state = this.state, slideMoveStartX = _this$state.slideMoveStartX, startX = _this$state.startX, endX = _this$state.endX;
				var _this$props4 = this.props, x$1 = _this$props4.x, width = _this$props4.width, travellerWidth = _this$props4.travellerWidth, startIndex = _this$props4.startIndex, endIndex = _this$props4.endIndex, onChange = _this$props4.onChange;
				var delta = e.pageX - slideMoveStartX;
				if (delta > 0) delta = Math.min(delta, x$1 + width - travellerWidth - endX, x$1 + width - travellerWidth - startX);
				else if (delta < 0) delta = Math.max(delta, x$1 - startX, x$1 - endX);
				var newIndex = this.getIndex({
					startX: startX + delta,
					endX: endX + delta
				});
				if ((newIndex.startIndex !== startIndex || newIndex.endIndex !== endIndex) && onChange) onChange(newIndex);
				this.setState({
					startX: startX + delta,
					endX: endX + delta,
					slideMoveStartX: e.pageX
				});
			}
		},
		{
			key: "handleTravellerDragStart",
			value: function handleTravellerDragStart(id, e) {
				var event = isTouch(e) ? e.changedTouches[0] : e;
				this.setState({
					isSlideMoving: false,
					isTravellerMoving: true,
					movingTravellerId: id,
					brushMoveStartX: event.pageX
				});
				this.attachDragEndListener();
			}
		},
		{
			key: "handleTravellerMove",
			value: function handleTravellerMove(e) {
				var _this$state2 = this.state, brushMoveStartX = _this$state2.brushMoveStartX, movingTravellerId = _this$state2.movingTravellerId, endX = _this$state2.endX, startX = _this$state2.startX;
				var prevValue = this.state[movingTravellerId];
				var _this$props5 = this.props, x$1 = _this$props5.x, width = _this$props5.width, travellerWidth = _this$props5.travellerWidth, onChange = _this$props5.onChange, gap = _this$props5.gap, data = _this$props5.data;
				var params = {
					startX: this.state.startX,
					endX: this.state.endX
				};
				var delta = e.pageX - brushMoveStartX;
				if (delta > 0) delta = Math.min(delta, x$1 + width - travellerWidth - prevValue);
				else if (delta < 0) delta = Math.max(delta, x$1 - prevValue);
				params[movingTravellerId] = prevValue + delta;
				var newIndex = this.getIndex(params);
				var startIndex = newIndex.startIndex, endIndex = newIndex.endIndex;
				var isFullGap = function isFullGap$1() {
					var lastIndex = data.length - 1;
					if (movingTravellerId === "startX" && (endX > startX ? startIndex % gap === 0 : endIndex % gap === 0) || endX < startX && endIndex === lastIndex || movingTravellerId === "endX" && (endX > startX ? endIndex % gap === 0 : startIndex % gap === 0) || endX > startX && endIndex === lastIndex) return true;
					return false;
				};
				this.setState(_defineProperty$14(_defineProperty$14({}, movingTravellerId, prevValue + delta), "brushMoveStartX", e.pageX), function() {
					if (onChange) {
						if (isFullGap()) onChange(newIndex);
					}
				});
			}
		},
		{
			key: "handleTravellerMoveKeyboard",
			value: function handleTravellerMoveKeyboard(direction, id) {
				var _this2 = this;
				var _this$state3 = this.state, scaleValues = _this$state3.scaleValues, startX = _this$state3.startX, endX = _this$state3.endX;
				var currentScaleValue = this.state[id];
				var currentIndex = scaleValues.indexOf(currentScaleValue);
				if (currentIndex === -1) return;
				var newIndex = currentIndex + direction;
				if (newIndex === -1 || newIndex >= scaleValues.length) return;
				var newScaleValue = scaleValues[newIndex];
				if (id === "startX" && newScaleValue >= endX || id === "endX" && newScaleValue <= startX) return;
				this.setState(_defineProperty$14({}, id, newScaleValue), function() {
					_this2.props.onChange(_this2.getIndex({
						startX: _this2.state.startX,
						endX: _this2.state.endX
					}));
				});
			}
		},
		{
			key: "renderBackground",
			value: function renderBackground() {
				var _this$props6 = this.props, x$1 = _this$props6.x, y$1 = _this$props6.y, width = _this$props6.width, height = _this$props6.height, fill = _this$props6.fill, stroke = _this$props6.stroke;
				return /* @__PURE__ */ import_react.createElement("rect", {
					stroke,
					fill,
					x: x$1,
					y: y$1,
					width,
					height
				});
			}
		},
		{
			key: "renderPanorama",
			value: function renderPanorama() {
				var _this$props7 = this.props, x$1 = _this$props7.x, y$1 = _this$props7.y, width = _this$props7.width, height = _this$props7.height, data = _this$props7.data, children = _this$props7.children, padding = _this$props7.padding;
				var chartElement = import_react.Children.only(children);
				if (!chartElement) return null;
				return /* @__PURE__ */ import_react.cloneElement(chartElement, {
					x: x$1,
					y: y$1,
					width,
					height,
					margin: padding,
					compact: true,
					data
				});
			}
		},
		{
			key: "renderTravellerLayer",
			value: function renderTravellerLayer(travellerX, id) {
				var _data$startIndex, _data$endIndex, _this3 = this;
				var _this$props8 = this.props, y$1 = _this$props8.y, travellerWidth = _this$props8.travellerWidth, height = _this$props8.height, traveller = _this$props8.traveller, ariaLabel = _this$props8.ariaLabel, data = _this$props8.data, startIndex = _this$props8.startIndex, endIndex = _this$props8.endIndex;
				var x$1 = Math.max(travellerX, this.props.x);
				var travellerProps = _objectSpread$11(_objectSpread$11({}, filterProps(this.props, false)), {}, {
					x: x$1,
					y: y$1,
					width: travellerWidth,
					height
				});
				var ariaLabelBrush = ariaLabel || "Min value: ".concat((_data$startIndex = data[startIndex]) === null || _data$startIndex === void 0 ? void 0 : _data$startIndex.name, ", Max value: ").concat((_data$endIndex = data[endIndex]) === null || _data$endIndex === void 0 ? void 0 : _data$endIndex.name);
				return /* @__PURE__ */ import_react.createElement(Layer, {
					tabIndex: 0,
					role: "slider",
					"aria-label": ariaLabelBrush,
					"aria-valuenow": travellerX,
					className: "recharts-brush-traveller",
					onMouseEnter: this.handleEnterSlideOrTraveller,
					onMouseLeave: this.handleLeaveSlideOrTraveller,
					onMouseDown: this.travellerDragStartHandlers[id],
					onTouchStart: this.travellerDragStartHandlers[id],
					onKeyDown: function onKeyDown(e) {
						if (!["ArrowLeft", "ArrowRight"].includes(e.key)) return;
						e.preventDefault();
						e.stopPropagation();
						_this3.handleTravellerMoveKeyboard(e.key === "ArrowRight" ? 1 : -1, id);
					},
					onFocus: function onFocus() {
						_this3.setState({ isTravellerFocused: true });
					},
					onBlur: function onBlur() {
						_this3.setState({ isTravellerFocused: false });
					},
					style: { cursor: "col-resize" }
				}, Brush$1.renderTraveller(traveller, travellerProps));
			}
		},
		{
			key: "renderSlide",
			value: function renderSlide(startX, endX) {
				var _this$props9 = this.props, y$1 = _this$props9.y, height = _this$props9.height, stroke = _this$props9.stroke, travellerWidth = _this$props9.travellerWidth;
				var x$1 = Math.min(startX, endX) + travellerWidth;
				var width = Math.max(Math.abs(endX - startX) - travellerWidth, 0);
				return /* @__PURE__ */ import_react.createElement("rect", {
					className: "recharts-brush-slide",
					onMouseEnter: this.handleEnterSlideOrTraveller,
					onMouseLeave: this.handleLeaveSlideOrTraveller,
					onMouseDown: this.handleSlideDragStart,
					onTouchStart: this.handleSlideDragStart,
					style: { cursor: "move" },
					stroke: "none",
					fill: stroke,
					fillOpacity: .2,
					x: x$1,
					y: y$1,
					width,
					height
				});
			}
		},
		{
			key: "renderText",
			value: function renderText() {
				var _this$props10 = this.props, startIndex = _this$props10.startIndex, endIndex = _this$props10.endIndex, y$1 = _this$props10.y, height = _this$props10.height, travellerWidth = _this$props10.travellerWidth, stroke = _this$props10.stroke;
				var _this$state4 = this.state, startX = _this$state4.startX, endX = _this$state4.endX;
				var offset = 5;
				var attrs = {
					pointerEvents: "none",
					fill: stroke
				};
				return /* @__PURE__ */ import_react.createElement(Layer, { className: "recharts-brush-texts" }, /* @__PURE__ */ import_react.createElement(Text, _extends$10({
					textAnchor: "end",
					verticalAnchor: "middle",
					x: Math.min(startX, endX) - offset,
					y: y$1 + height / 2
				}, attrs), this.getTextOfTick(startIndex)), /* @__PURE__ */ import_react.createElement(Text, _extends$10({
					textAnchor: "start",
					verticalAnchor: "middle",
					x: Math.max(startX, endX) + travellerWidth + offset,
					y: y$1 + height / 2
				}, attrs), this.getTextOfTick(endIndex)));
			}
		},
		{
			key: "render",
			value: function render() {
				var _this$props11 = this.props, data = _this$props11.data, className = _this$props11.className, children = _this$props11.children, x$1 = _this$props11.x, y$1 = _this$props11.y, width = _this$props11.width, height = _this$props11.height, alwaysShowText = _this$props11.alwaysShowText;
				var _this$state5 = this.state, startX = _this$state5.startX, endX = _this$state5.endX, isTextActive = _this$state5.isTextActive, isSlideMoving = _this$state5.isSlideMoving, isTravellerMoving = _this$state5.isTravellerMoving, isTravellerFocused = _this$state5.isTravellerFocused;
				if (!data || !data.length || !isNumber(x$1) || !isNumber(y$1) || !isNumber(width) || !isNumber(height) || width <= 0 || height <= 0) return null;
				var layerClass = clsx_default("recharts-brush", className);
				var isPanoramic = import_react.Children.count(children) === 1;
				var style = generatePrefixStyle("userSelect", "none");
				return /* @__PURE__ */ import_react.createElement(Layer, {
					className: layerClass,
					onMouseLeave: this.handleLeaveWrapper,
					onTouchMove: this.handleTouchMove,
					style
				}, this.renderBackground(), isPanoramic && this.renderPanorama(), this.renderSlide(startX, endX), this.renderTravellerLayer(startX, "startX"), this.renderTravellerLayer(endX, "endX"), (isTextActive || isSlideMoving || isTravellerMoving || isTravellerFocused || alwaysShowText) && this.renderText());
			}
		}
	], [
		{
			key: "renderDefaultTraveller",
			value: function renderDefaultTraveller(props) {
				var x$1 = props.x, y$1 = props.y, width = props.width, height = props.height, stroke = props.stroke;
				var lineY = Math.floor(y$1 + height / 2) - 1;
				return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement("rect", {
					x: x$1,
					y: y$1,
					width,
					height,
					fill: stroke,
					stroke: "none"
				}), /* @__PURE__ */ import_react.createElement("line", {
					x1: x$1 + 1,
					y1: lineY,
					x2: x$1 + width - 1,
					y2: lineY,
					fill: "none",
					stroke: "#fff"
				}), /* @__PURE__ */ import_react.createElement("line", {
					x1: x$1 + 1,
					y1: lineY + 2,
					x2: x$1 + width - 1,
					y2: lineY + 2,
					fill: "none",
					stroke: "#fff"
				}));
			}
		},
		{
			key: "renderTraveller",
			value: function renderTraveller(option, props) {
				var rectangle;
				if (/* @__PURE__ */ import_react.isValidElement(option)) rectangle = /* @__PURE__ */ import_react.cloneElement(option, props);
				else if ((0, import_isFunction$7.default)(option)) rectangle = option(props);
				else rectangle = Brush$1.renderDefaultTraveller(props);
				return rectangle;
			}
		},
		{
			key: "getDerivedStateFromProps",
			value: function getDerivedStateFromProps(nextProps, prevState) {
				var data = nextProps.data, width = nextProps.width, x$1 = nextProps.x, travellerWidth = nextProps.travellerWidth, updateId = nextProps.updateId, startIndex = nextProps.startIndex, endIndex = nextProps.endIndex;
				if (data !== prevState.prevData || updateId !== prevState.prevUpdateId) return _objectSpread$11({
					prevData: data,
					prevTravellerWidth: travellerWidth,
					prevUpdateId: updateId,
					prevX: x$1,
					prevWidth: width
				}, data && data.length ? createScale({
					data,
					width,
					x: x$1,
					travellerWidth,
					startIndex,
					endIndex
				}) : {
					scale: null,
					scaleValues: null
				});
				if (prevState.scale && (width !== prevState.prevWidth || x$1 !== prevState.prevX || travellerWidth !== prevState.prevTravellerWidth)) {
					prevState.scale.range([x$1, x$1 + width - travellerWidth]);
					var scaleValues = prevState.scale.domain().map(function(entry) {
						return prevState.scale(entry);
					});
					return {
						prevData: data,
						prevTravellerWidth: travellerWidth,
						prevUpdateId: updateId,
						prevX: x$1,
						prevWidth: width,
						startX: prevState.scale(nextProps.startIndex),
						endX: prevState.scale(nextProps.endIndex),
						scaleValues
					};
				}
				return null;
			}
		},
		{
			key: "getIndexInRange",
			value: function getIndexInRange(valueRange, x$1) {
				var len = valueRange.length;
				var start = 0;
				var end = len - 1;
				while (end - start > 1) {
					var middle = Math.floor((start + end) / 2);
					if (valueRange[middle] > x$1) end = middle;
					else start = middle;
				}
				return x$1 >= valueRange[end] ? end : start;
			}
		}
	]);
}(import_react.PureComponent);
_defineProperty$14(Brush, "displayName", "Brush");
_defineProperty$14(Brush, "defaultProps", {
	height: 40,
	travellerWidth: 5,
	gap: 1,
	fill: "#fff",
	stroke: "#666",
	padding: {
		top: 1,
		right: 1,
		bottom: 1,
		left: 1
	},
	leaveTimeOut: 1e3,
	alwaysShowText: false
});
var require__baseSome = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseEach$1 = require__baseEach();
	function baseSome$1(collection, predicate) {
		var result;
		baseEach$1(collection, function(value, index, collection$1) {
			result = predicate(value, index, collection$1);
			return !result;
		});
		return !!result;
	}
	module.exports = baseSome$1;
}));
var require_some = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var arraySome = require__arraySome(), baseIteratee$4 = require__baseIteratee(), baseSome = require__baseSome(), isArray$1 = require_isArray(), isIterateeCall$1 = require__isIterateeCall();
	function some$1(collection, predicate, guard) {
		var func = isArray$1(collection) ? arraySome : baseSome;
		if (guard && isIterateeCall$1(collection, predicate, guard)) predicate = void 0;
		return func(collection, baseIteratee$4(predicate, 3));
	}
	module.exports = some$1;
}));
var ifOverflowMatches = function ifOverflowMatches$1(props, value) {
	var alwaysShow = props.alwaysShow;
	var ifOverflow = props.ifOverflow;
	if (alwaysShow) ifOverflow = "extendDomain";
	return ifOverflow === value;
};
var require__baseAssignValue = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var defineProperty = require__defineProperty();
	function baseAssignValue$1(object, key, value) {
		if (key == "__proto__" && defineProperty) defineProperty(object, key, {
			"configurable": true,
			"enumerable": true,
			"value": value,
			"writable": true
		});
		else object[key] = value;
	}
	module.exports = baseAssignValue$1;
}));
var require_mapValues = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseAssignValue = require__baseAssignValue(), baseForOwn = require__baseForOwn(), baseIteratee$3 = require__baseIteratee();
	function mapValues$1(object, iteratee) {
		var result = {};
		iteratee = baseIteratee$3(iteratee, 3);
		baseForOwn(object, function(value, key, object$1) {
			baseAssignValue(result, key, iteratee(value, key, object$1));
		});
		return result;
	}
	module.exports = mapValues$1;
}));
var require__arrayEvery = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	function arrayEvery$1(array, predicate) {
		var index = -1, length = array == null ? 0 : array.length;
		while (++index < length) if (!predicate(array[index], index, array)) return false;
		return true;
	}
	module.exports = arrayEvery$1;
}));
var require__baseEvery = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseEach = require__baseEach();
	function baseEvery$1(collection, predicate) {
		var result = true;
		baseEach(collection, function(value, index, collection$1) {
			result = !!predicate(value, index, collection$1);
			return result;
		});
		return result;
	}
	module.exports = baseEvery$1;
}));
var require_every = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var arrayEvery = require__arrayEvery(), baseEvery = require__baseEvery(), baseIteratee$2 = require__baseIteratee(), isArray = require_isArray(), isIterateeCall = require__isIterateeCall();
	function every$2(collection, predicate, guard) {
		var func = isArray(collection) ? arrayEvery : baseEvery;
		if (guard && isIterateeCall(collection, predicate, guard)) predicate = void 0;
		return func(collection, baseIteratee$2(predicate, 3));
	}
	module.exports = every$2;
}));
var _excluded$4 = ["x", "y"];
function _typeof$14(o) {
	"@babel/helpers - typeof";
	return _typeof$14 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$14(o);
}
function _extends$9() {
	_extends$9 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$9.apply(this, arguments);
}
function ownKeys$10(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$10(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$10(Object(t), !0).forEach(function(r$1) {
			_defineProperty$13(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$10(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}
function _defineProperty$13(obj, key, value) {
	key = _toPropertyKey$13(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$13(t) {
	var i = _toPrimitive$13(t, "string");
	return "symbol" == _typeof$14(i) ? i : i + "";
}
function _toPrimitive$13(t, r) {
	if ("object" != _typeof$14(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$14(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
function _objectWithoutProperties$4(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$4(source, excluded);
	var key, i;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i = 0; i < sourceSymbolKeys.length; i++) {
			key = sourceSymbolKeys[i];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$4(source, excluded) {
	if (source == null) return {};
	var target = {};
	for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function typeguardBarRectangleProps(_ref, props) {
	var xProp = _ref.x, yProp = _ref.y, option = _objectWithoutProperties$4(_ref, _excluded$4);
	var xValue = "".concat(xProp);
	var x$1 = parseInt(xValue, 10);
	var yValue = "".concat(yProp);
	var y$1 = parseInt(yValue, 10);
	var heightValue = "".concat(props.height || option.height);
	var height = parseInt(heightValue, 10);
	var widthValue = "".concat(props.width || option.width);
	var width = parseInt(widthValue, 10);
	return _objectSpread$10(_objectSpread$10(_objectSpread$10(_objectSpread$10(_objectSpread$10({}, props), option), x$1 ? { x: x$1 } : {}), y$1 ? { y: y$1 } : {}), {}, {
		height,
		width,
		name: props.name,
		radius: props.radius
	});
}
function BarRectangle(props) {
	return /* @__PURE__ */ import_react.createElement(Shape, _extends$9({
		shapeType: "rectangle",
		propTransformer: typeguardBarRectangleProps,
		activeClassName: "recharts-active-bar"
	}, props));
}
var minPointSizeCallback = function minPointSizeCallback$1(minPointSize) {
	var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
	return function(value, index) {
		if (typeof minPointSize === "number") return minPointSize;
		var isValueNumberOrNil = isNumber(value) || isNullish(value);
		if (isValueNumberOrNil) return minPointSize(value, index);
		!isValueNumberOrNil && invariant(false, "minPointSize callback function received a value with type of ".concat(_typeof$14(value), ". Currently only numbers or null/undefined are supported."));
		return defaultValue;
	};
};
var import_isEqual = /* @__PURE__ */ __toESM(require_isEqual());
var import_isNil$1 = /* @__PURE__ */ __toESM(require_isNil());
var _excluded$3 = ["value", "background"];
var _Bar;
function _typeof$13(o) {
	"@babel/helpers - typeof";
	return _typeof$13 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$13(o);
}
function _objectWithoutProperties$3(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$3(source, excluded);
	var key, i;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i = 0; i < sourceSymbolKeys.length; i++) {
			key = sourceSymbolKeys[i];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$3(source, excluded) {
	if (source == null) return {};
	var target = {};
	for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function _extends$8() {
	_extends$8 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$8.apply(this, arguments);
}
function ownKeys$9(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$9(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$9(Object(t), !0).forEach(function(r$1) {
			_defineProperty$12(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$9(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}
function _classCallCheck$9(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$9(target, props) {
	for (var i = 0; i < props.length; i++) {
		var descriptor = props[i];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$12(descriptor.key), descriptor);
	}
}
function _createClass$9(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$9(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$9(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _callSuper$7(t, o, e) {
	return o = _getPrototypeOf$7(o), _possibleConstructorReturn$7(t, _isNativeReflectConstruct$7() ? Reflect.construct(o, e || [], _getPrototypeOf$7(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn$7(self$1, call) {
	if (call && (_typeof$13(call) === "object" || typeof call === "function")) return call;
	else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
	return _assertThisInitialized$7(self$1);
}
function _assertThisInitialized$7(self$1) {
	if (self$1 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return self$1;
}
function _isNativeReflectConstruct$7() {
	try {
		var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
	} catch (t$1) {}
	return (_isNativeReflectConstruct$7 = function _isNativeReflectConstruct$15() {
		return !!t;
	})();
}
function _getPrototypeOf$7(o) {
	_getPrototypeOf$7 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf$15(o$1) {
		return o$1.__proto__ || Object.getPrototypeOf(o$1);
	};
	return _getPrototypeOf$7(o);
}
function _inherits$7(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
	subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
		value: subClass,
		writable: true,
		configurable: true
	} });
	Object.defineProperty(subClass, "prototype", { writable: false });
	if (superClass) _setPrototypeOf$7(subClass, superClass);
}
function _setPrototypeOf$7(o, p) {
	_setPrototypeOf$7 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf$15(o$1, p$1) {
		o$1.__proto__ = p$1;
		return o$1;
	};
	return _setPrototypeOf$7(o, p);
}
function _defineProperty$12(obj, key, value) {
	key = _toPropertyKey$12(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$12(t) {
	var i = _toPrimitive$12(t, "string");
	return "symbol" == _typeof$13(i) ? i : i + "";
}
function _toPrimitive$12(t, r) {
	if ("object" != _typeof$13(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$13(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
var Bar = /* @__PURE__ */ function(_PureComponent) {
	function Bar$1() {
		var _this;
		_classCallCheck$9(this, Bar$1);
		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
		_this = _callSuper$7(this, Bar$1, [].concat(args));
		_defineProperty$12(_this, "state", { isAnimationFinished: false });
		_defineProperty$12(_this, "id", uniqueId("recharts-bar-"));
		_defineProperty$12(_this, "handleAnimationEnd", function() {
			var onAnimationEnd = _this.props.onAnimationEnd;
			_this.setState({ isAnimationFinished: true });
			if (onAnimationEnd) onAnimationEnd();
		});
		_defineProperty$12(_this, "handleAnimationStart", function() {
			var onAnimationStart = _this.props.onAnimationStart;
			_this.setState({ isAnimationFinished: false });
			if (onAnimationStart) onAnimationStart();
		});
		return _this;
	}
	_inherits$7(Bar$1, _PureComponent);
	return _createClass$9(Bar$1, [
		{
			key: "renderRectanglesStatically",
			value: function renderRectanglesStatically(data) {
				var _this2 = this;
				var _this$props = this.props, shape = _this$props.shape, dataKey = _this$props.dataKey, activeIndex = _this$props.activeIndex, activeBar = _this$props.activeBar;
				var baseProps = filterProps(this.props, false);
				return data && data.map(function(entry, i) {
					var isActive = i === activeIndex;
					var option = isActive ? activeBar : shape;
					var props = _objectSpread$9(_objectSpread$9(_objectSpread$9({}, baseProps), entry), {}, {
						isActive,
						option,
						index: i,
						dataKey,
						onAnimationStart: _this2.handleAnimationStart,
						onAnimationEnd: _this2.handleAnimationEnd
					});
					return /* @__PURE__ */ import_react.createElement(Layer, _extends$8({ className: "recharts-bar-rectangle" }, adaptEventsOfChild(_this2.props, entry, i), { key: "rectangle-".concat(entry === null || entry === void 0 ? void 0 : entry.x, "-").concat(entry === null || entry === void 0 ? void 0 : entry.y, "-").concat(entry === null || entry === void 0 ? void 0 : entry.value, "-").concat(i) }), /* @__PURE__ */ import_react.createElement(BarRectangle, props));
				});
			}
		},
		{
			key: "renderRectanglesWithAnimation",
			value: function renderRectanglesWithAnimation() {
				var _this3 = this;
				var _this$props2 = this.props, data = _this$props2.data, layout = _this$props2.layout, isAnimationActive = _this$props2.isAnimationActive, animationBegin = _this$props2.animationBegin, animationDuration = _this$props2.animationDuration, animationEasing = _this$props2.animationEasing, animationId = _this$props2.animationId;
				var prevData = this.state.prevData;
				return /* @__PURE__ */ import_react.createElement(es6_default, {
					begin: animationBegin,
					duration: animationDuration,
					isActive: isAnimationActive,
					easing: animationEasing,
					from: { t: 0 },
					to: { t: 1 },
					key: "bar-".concat(animationId),
					onAnimationEnd: this.handleAnimationEnd,
					onAnimationStart: this.handleAnimationStart
				}, function(_ref) {
					var t = _ref.t;
					var stepData = data.map(function(entry, index) {
						var prev = prevData && prevData[index];
						if (prev) {
							var interpolatorX = interpolateNumber(prev.x, entry.x);
							var interpolatorY = interpolateNumber(prev.y, entry.y);
							var interpolatorWidth = interpolateNumber(prev.width, entry.width);
							var interpolatorHeight = interpolateNumber(prev.height, entry.height);
							return _objectSpread$9(_objectSpread$9({}, entry), {}, {
								x: interpolatorX(t),
								y: interpolatorY(t),
								width: interpolatorWidth(t),
								height: interpolatorHeight(t)
							});
						}
						if (layout === "horizontal") {
							var h = interpolateNumber(0, entry.height)(t);
							return _objectSpread$9(_objectSpread$9({}, entry), {}, {
								y: entry.y + entry.height - h,
								height: h
							});
						}
						var w = interpolateNumber(0, entry.width)(t);
						return _objectSpread$9(_objectSpread$9({}, entry), {}, { width: w });
					});
					return /* @__PURE__ */ import_react.createElement(Layer, null, _this3.renderRectanglesStatically(stepData));
				});
			}
		},
		{
			key: "renderRectangles",
			value: function renderRectangles() {
				var _this$props3 = this.props, data = _this$props3.data, isAnimationActive = _this$props3.isAnimationActive;
				var prevData = this.state.prevData;
				if (isAnimationActive && data && data.length && (!prevData || !(0, import_isEqual.default)(prevData, data))) return this.renderRectanglesWithAnimation();
				return this.renderRectanglesStatically(data);
			}
		},
		{
			key: "renderBackground",
			value: function renderBackground() {
				var _this4 = this;
				var _this$props4 = this.props, data = _this$props4.data, dataKey = _this$props4.dataKey, activeIndex = _this$props4.activeIndex;
				var backgroundProps = filterProps(this.props.background, false);
				return data.map(function(entry, i) {
					entry.value;
					var background = entry.background, rest = _objectWithoutProperties$3(entry, _excluded$3);
					if (!background) return null;
					var props = _objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9({}, rest), {}, { fill: "#eee" }, background), backgroundProps), adaptEventsOfChild(_this4.props, entry, i)), {}, {
						onAnimationStart: _this4.handleAnimationStart,
						onAnimationEnd: _this4.handleAnimationEnd,
						dataKey,
						index: i,
						className: "recharts-bar-background-rectangle"
					});
					return /* @__PURE__ */ import_react.createElement(BarRectangle, _extends$8({
						key: "background-bar-".concat(i),
						option: _this4.props.background,
						isActive: i === activeIndex
					}, props));
				});
			}
		},
		{
			key: "renderErrorBar",
			value: function renderErrorBar(needClip, clipPathId) {
				if (this.props.isAnimationActive && !this.state.isAnimationFinished) return null;
				var _this$props5 = this.props, data = _this$props5.data, xAxis = _this$props5.xAxis, yAxis = _this$props5.yAxis, layout = _this$props5.layout, children = _this$props5.children;
				var errorBarItems = findAllByType(children, ErrorBar);
				if (!errorBarItems) return null;
				var offset = layout === "vertical" ? data[0].height / 2 : data[0].width / 2;
				var dataPointFormatter = function dataPointFormatter$1(dataPoint, dataKey) {
					var value = Array.isArray(dataPoint.value) ? dataPoint.value[1] : dataPoint.value;
					return {
						x: dataPoint.x,
						y: dataPoint.y,
						value,
						errorVal: getValueByDataKey(dataPoint, dataKey)
					};
				};
				var errorBarProps = { clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : null };
				return /* @__PURE__ */ import_react.createElement(Layer, errorBarProps, errorBarItems.map(function(item) {
					return /* @__PURE__ */ import_react.cloneElement(item, {
						key: "error-bar-".concat(clipPathId, "-").concat(item.props.dataKey),
						data,
						xAxis,
						yAxis,
						layout,
						offset,
						dataPointFormatter
					});
				}));
			}
		},
		{
			key: "render",
			value: function render() {
				var _this$props6 = this.props, hide = _this$props6.hide, data = _this$props6.data, className = _this$props6.className, xAxis = _this$props6.xAxis, yAxis = _this$props6.yAxis, left = _this$props6.left, top = _this$props6.top, width = _this$props6.width, height = _this$props6.height, isAnimationActive = _this$props6.isAnimationActive, background = _this$props6.background, id = _this$props6.id;
				if (hide || !data || !data.length) return null;
				var isAnimationFinished = this.state.isAnimationFinished;
				var layerClass = clsx_default("recharts-bar", className);
				var needClipX = xAxis && xAxis.allowDataOverflow;
				var needClipY = yAxis && yAxis.allowDataOverflow;
				var needClip = needClipX || needClipY;
				var clipPathId = (0, import_isNil$1.default)(id) ? this.id : id;
				return /* @__PURE__ */ import_react.createElement(Layer, { className: layerClass }, needClipX || needClipY ? /* @__PURE__ */ import_react.createElement("defs", null, /* @__PURE__ */ import_react.createElement("clipPath", { id: "clipPath-".concat(clipPathId) }, /* @__PURE__ */ import_react.createElement("rect", {
					x: needClipX ? left : left - width / 2,
					y: needClipY ? top : top - height / 2,
					width: needClipX ? width : width * 2,
					height: needClipY ? height : height * 2
				}))) : null, /* @__PURE__ */ import_react.createElement(Layer, {
					className: "recharts-bar-rectangles",
					clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : null
				}, background ? this.renderBackground() : null, this.renderRectangles()), this.renderErrorBar(needClip, clipPathId), (!isAnimationActive || isAnimationFinished) && LabelList.renderCallByParent(this.props, data));
			}
		}
	], [{
		key: "getDerivedStateFromProps",
		value: function getDerivedStateFromProps(nextProps, prevState) {
			if (nextProps.animationId !== prevState.prevAnimationId) return {
				prevAnimationId: nextProps.animationId,
				curData: nextProps.data,
				prevData: prevState.curData
			};
			if (nextProps.data !== prevState.curData) return { curData: nextProps.data };
			return null;
		}
	}]);
}(import_react.PureComponent);
_Bar = Bar;
_defineProperty$12(Bar, "displayName", "Bar");
_defineProperty$12(Bar, "defaultProps", {
	xAxisId: 0,
	yAxisId: 0,
	legendType: "rect",
	minPointSize: 0,
	hide: false,
	data: [],
	layout: "vertical",
	activeBar: false,
	isAnimationActive: !Global.isSsr,
	animationBegin: 0,
	animationDuration: 400,
	animationEasing: "ease"
});
_defineProperty$12(Bar, "getComposedData", function(_ref2) {
	var props = _ref2.props, item = _ref2.item, barPosition = _ref2.barPosition, bandSize = _ref2.bandSize, xAxis = _ref2.xAxis, yAxis = _ref2.yAxis, xAxisTicks = _ref2.xAxisTicks, yAxisTicks = _ref2.yAxisTicks, stackedData = _ref2.stackedData, dataStartIndex = _ref2.dataStartIndex, displayedData = _ref2.displayedData, offset = _ref2.offset;
	var pos = findPositionOfBar(barPosition, item);
	if (!pos) return null;
	var layout = props.layout;
	var itemDefaultProps = item.type.defaultProps;
	var itemProps = itemDefaultProps !== void 0 ? _objectSpread$9(_objectSpread$9({}, itemDefaultProps), item.props) : item.props;
	var dataKey = itemProps.dataKey, children = itemProps.children, minPointSizeProp = itemProps.minPointSize;
	var numericAxis = layout === "horizontal" ? yAxis : xAxis;
	var stackedDomain = stackedData ? numericAxis.scale.domain() : null;
	var baseValue = getBaseValueOfBar({ numericAxis });
	var cells = findAllByType(children, Cell);
	return _objectSpread$9({
		data: displayedData.map(function(entry, index) {
			var value, x$1, y$1, width, height, background;
			if (stackedData) value = truncateByDomain(stackedData[dataStartIndex + index], stackedDomain);
			else {
				value = getValueByDataKey(entry, dataKey);
				if (!Array.isArray(value)) value = [baseValue, value];
			}
			var minPointSize = minPointSizeCallback(minPointSizeProp, _Bar.defaultProps.minPointSize)(value[1], index);
			if (layout === "horizontal") {
				var _ref4;
				var _ref3 = [yAxis.scale(value[0]), yAxis.scale(value[1])], baseValueScale = _ref3[0], currentValueScale = _ref3[1];
				x$1 = getCateCoordinateOfBar({
					axis: xAxis,
					ticks: xAxisTicks,
					bandSize,
					offset: pos.offset,
					entry,
					index
				});
				y$1 = (_ref4 = currentValueScale !== null && currentValueScale !== void 0 ? currentValueScale : baseValueScale) !== null && _ref4 !== void 0 ? _ref4 : void 0;
				width = pos.size;
				var computedHeight = baseValueScale - currentValueScale;
				height = Number.isNaN(computedHeight) ? 0 : computedHeight;
				background = {
					x: x$1,
					y: yAxis.y,
					width,
					height: yAxis.height
				};
				if (Math.abs(minPointSize) > 0 && Math.abs(height) < Math.abs(minPointSize)) {
					var delta = mathSign(height || minPointSize) * (Math.abs(minPointSize) - Math.abs(height));
					y$1 -= delta;
					height += delta;
				}
			} else {
				var _ref5 = [xAxis.scale(value[0]), xAxis.scale(value[1])], _baseValueScale = _ref5[0], _currentValueScale = _ref5[1];
				x$1 = _baseValueScale;
				y$1 = getCateCoordinateOfBar({
					axis: yAxis,
					ticks: yAxisTicks,
					bandSize,
					offset: pos.offset,
					entry,
					index
				});
				width = _currentValueScale - _baseValueScale;
				height = pos.size;
				background = {
					x: xAxis.x,
					y: y$1,
					width: xAxis.width,
					height
				};
				if (Math.abs(minPointSize) > 0 && Math.abs(width) < Math.abs(minPointSize)) {
					var _delta = mathSign(width || minPointSize) * (Math.abs(minPointSize) - Math.abs(width));
					width += _delta;
				}
			}
			return _objectSpread$9(_objectSpread$9(_objectSpread$9({}, entry), {}, {
				x: x$1,
				y: y$1,
				width,
				height,
				value: stackedData ? value : value[1],
				payload: entry,
				background
			}, cells && cells[index] && cells[index].props), {}, {
				tooltipPayload: [getTooltipItem(item, entry)],
				tooltipPosition: {
					x: x$1 + width / 2,
					y: y$1 + height / 2
				}
			});
		}),
		layout
	}, offset);
});
var import_mapValues = /* @__PURE__ */ __toESM(require_mapValues());
var import_every$1 = /* @__PURE__ */ __toESM(require_every());
function _typeof$12(o) {
	"@babel/helpers - typeof";
	return _typeof$12 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$12(o);
}
function _classCallCheck$8(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$8(target, props) {
	for (var i = 0; i < props.length; i++) {
		var descriptor = props[i];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$11(descriptor.key), descriptor);
	}
}
function _createClass$8(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$8(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$8(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function ownKeys$8(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$8(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$8(Object(t), !0).forEach(function(r$1) {
			_defineProperty$11(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$8(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}
function _defineProperty$11(obj, key, value) {
	key = _toPropertyKey$11(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$11(t) {
	var i = _toPrimitive$11(t, "string");
	return "symbol" == _typeof$12(i) ? i : i + "";
}
function _toPrimitive$11(t, r) {
	if ("object" != _typeof$12(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$12(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
var formatAxisMap = function formatAxisMap$1(props, axisMap, offset, axisType, chartName) {
	var width = props.width, height = props.height, layout = props.layout, children = props.children;
	var ids = Object.keys(axisMap);
	var steps = {
		left: offset.left,
		leftMirror: offset.left,
		right: width - offset.right,
		rightMirror: width - offset.right,
		top: offset.top,
		topMirror: offset.top,
		bottom: height - offset.bottom,
		bottomMirror: height - offset.bottom
	};
	var hasBar = !!findChildByType(children, Bar);
	return ids.reduce(function(result, id) {
		var axis = axisMap[id];
		var orientation = axis.orientation, domain = axis.domain, _axis$padding = axis.padding, padding = _axis$padding === void 0 ? {} : _axis$padding, mirror = axis.mirror, reversed = axis.reversed;
		var offsetKey = "".concat(orientation).concat(mirror ? "Mirror" : "");
		var calculatedPadding, range$5, x$1, y$1, needSpace;
		if (axis.type === "number" && (axis.padding === "gap" || axis.padding === "no-gap")) {
			var diff = domain[1] - domain[0];
			var smallestDistanceBetweenValues = Infinity;
			var sortedValues = axis.categoricalDomain.sort(compareValues);
			sortedValues.forEach(function(value, index) {
				if (index > 0) smallestDistanceBetweenValues = Math.min((value || 0) - (sortedValues[index - 1] || 0), smallestDistanceBetweenValues);
			});
			if (Number.isFinite(smallestDistanceBetweenValues)) {
				var smallestDistanceInPercent = smallestDistanceBetweenValues / diff;
				var rangeWidth = axis.layout === "vertical" ? offset.height : offset.width;
				if (axis.padding === "gap") calculatedPadding = smallestDistanceInPercent * rangeWidth / 2;
				if (axis.padding === "no-gap") {
					var gap = getPercentValue(props.barCategoryGap, smallestDistanceInPercent * rangeWidth);
					var halfBand = smallestDistanceInPercent * rangeWidth / 2;
					calculatedPadding = halfBand - gap - (halfBand - gap) / rangeWidth * gap;
				}
			}
		}
		if (axisType === "xAxis") range$5 = [offset.left + (padding.left || 0) + (calculatedPadding || 0), offset.left + offset.width - (padding.right || 0) - (calculatedPadding || 0)];
		else if (axisType === "yAxis") range$5 = layout === "horizontal" ? [offset.top + offset.height - (padding.bottom || 0), offset.top + (padding.top || 0)] : [offset.top + (padding.top || 0) + (calculatedPadding || 0), offset.top + offset.height - (padding.bottom || 0) - (calculatedPadding || 0)];
		else range$5 = axis.range;
		if (reversed) range$5 = [range$5[1], range$5[0]];
		var _parseScale = parseScale(axis, chartName, hasBar), scale = _parseScale.scale, realScaleType = _parseScale.realScaleType;
		scale.domain(domain).range(range$5);
		checkDomainOfScale(scale);
		var ticks$1 = getTicksOfScale(scale, _objectSpread$8(_objectSpread$8({}, axis), {}, { realScaleType }));
		if (axisType === "xAxis") {
			needSpace = orientation === "top" && !mirror || orientation === "bottom" && mirror;
			x$1 = offset.left;
			y$1 = steps[offsetKey] - needSpace * axis.height;
		} else if (axisType === "yAxis") {
			needSpace = orientation === "left" && !mirror || orientation === "right" && mirror;
			x$1 = steps[offsetKey] - needSpace * axis.width;
			y$1 = offset.top;
		}
		var finalAxis = _objectSpread$8(_objectSpread$8(_objectSpread$8({}, axis), ticks$1), {}, {
			realScaleType,
			x: x$1,
			y: y$1,
			scale,
			width: axisType === "xAxis" ? offset.width : axis.width,
			height: axisType === "yAxis" ? offset.height : axis.height
		});
		finalAxis.bandSize = getBandSizeOfAxis(finalAxis, ticks$1);
		if (!axis.hide && axisType === "xAxis") steps[offsetKey] += (needSpace ? -1 : 1) * finalAxis.height;
		else if (!axis.hide) steps[offsetKey] += (needSpace ? -1 : 1) * finalAxis.width;
		return _objectSpread$8(_objectSpread$8({}, result), {}, _defineProperty$11({}, id, finalAxis));
	}, {});
};
var rectWithPoints = function rectWithPoints$1(_ref, _ref2) {
	var x1 = _ref.x, y1 = _ref.y;
	var x2 = _ref2.x, y2 = _ref2.y;
	return {
		x: Math.min(x1, x2),
		y: Math.min(y1, y2),
		width: Math.abs(x2 - x1),
		height: Math.abs(y2 - y1)
	};
};
var rectWithCoords = function rectWithCoords$1(_ref3) {
	var x1 = _ref3.x1, y1 = _ref3.y1, x2 = _ref3.x2, y2 = _ref3.y2;
	return rectWithPoints({
		x: x1,
		y: y1
	}, {
		x: x2,
		y: y2
	});
};
var ScaleHelper = /* @__PURE__ */ function() {
	function ScaleHelper$1(scale) {
		_classCallCheck$8(this, ScaleHelper$1);
		this.scale = scale;
	}
	return _createClass$8(ScaleHelper$1, [
		{
			key: "domain",
			get: function get$7() {
				return this.scale.domain;
			}
		},
		{
			key: "range",
			get: function get$7() {
				return this.scale.range;
			}
		},
		{
			key: "rangeMin",
			get: function get$7() {
				return this.range()[0];
			}
		},
		{
			key: "rangeMax",
			get: function get$7() {
				return this.range()[1];
			}
		},
		{
			key: "bandwidth",
			get: function get$7() {
				return this.scale.bandwidth;
			}
		},
		{
			key: "apply",
			value: function apply$2(value) {
				var _ref4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, bandAware = _ref4.bandAware, position = _ref4.position;
				if (value === void 0) return;
				if (position) switch (position) {
					case "start": return this.scale(value);
					case "middle":
						var offset = this.bandwidth ? this.bandwidth() / 2 : 0;
						return this.scale(value) + offset;
					case "end":
						var _offset = this.bandwidth ? this.bandwidth() : 0;
						return this.scale(value) + _offset;
					default: return this.scale(value);
				}
				if (bandAware) {
					var _offset2 = this.bandwidth ? this.bandwidth() / 2 : 0;
					return this.scale(value) + _offset2;
				}
				return this.scale(value);
			}
		},
		{
			key: "isInRange",
			value: function isInRange(value) {
				var range$5 = this.range();
				var first = range$5[0];
				var last$2 = range$5[range$5.length - 1];
				return first <= last$2 ? value >= first && value <= last$2 : value >= last$2 && value <= first;
			}
		}
	], [{
		key: "create",
		value: function create(obj) {
			return new ScaleHelper$1(obj);
		}
	}]);
}();
_defineProperty$11(ScaleHelper, "EPS", 1e-4);
var createLabeledScales = function createLabeledScales$1(options) {
	var scales = Object.keys(options).reduce(function(res, key) {
		return _objectSpread$8(_objectSpread$8({}, res), {}, _defineProperty$11({}, key, ScaleHelper.create(options[key])));
	}, {});
	return _objectSpread$8(_objectSpread$8({}, scales), {}, {
		apply: function apply$2(coord) {
			var _ref5 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, bandAware = _ref5.bandAware, position = _ref5.position;
			return (0, import_mapValues.default)(coord, function(value, label) {
				return scales[label].apply(value, {
					bandAware,
					position
				});
			});
		},
		isInRange: function isInRange(coord) {
			return (0, import_every$1.default)(coord, function(value, label) {
				return scales[label].isInRange(value);
			});
		}
	});
};
function normalizeAngle(angle) {
	return (angle % 180 + 180) % 180;
}
var getAngledRectangleWidth = function getAngledRectangleWidth$1(_ref6) {
	var width = _ref6.width, height = _ref6.height;
	var angleRadians = normalizeAngle(arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0) * Math.PI / 180;
	var angleThreshold = Math.atan(height / width);
	var angledWidth = angleRadians > angleThreshold && angleRadians < Math.PI - angleThreshold ? height / Math.sin(angleRadians) : width / Math.cos(angleRadians);
	return Math.abs(angledWidth);
};
var require__createFind = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseIteratee$1 = require__baseIteratee(), isArrayLike = require_isArrayLike(), keys = require_keys();
	function createFind(findIndexFunc) {
		return function(collection, predicate, fromIndex) {
			var iterable = Object(collection);
			if (!isArrayLike(collection)) {
				var iteratee = baseIteratee$1(predicate, 3);
				collection = keys(collection);
				predicate = function(key) {
					return iteratee(iterable[key], key, iterable);
				};
			}
			var index = findIndexFunc(collection, predicate, fromIndex);
			return index > -1 ? iterable[iteratee ? collection[index] : index] : void 0;
		};
	}
	module.exports = createFind;
}));
var require_toInteger = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var toFinite = require_toFinite();
	function toInteger$1(value) {
		var result = toFinite(value), remainder = result % 1;
		return result === result ? remainder ? result - remainder : result : 0;
	}
	module.exports = toInteger$1;
}));
var require_findIndex = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var baseFindIndex = require__baseFindIndex(), baseIteratee = require__baseIteratee(), toInteger = require_toInteger();
	var nativeMax = Math.max;
	function findIndex(array, predicate, fromIndex) {
		var length = array == null ? 0 : array.length;
		if (!length) return -1;
		var index = fromIndex == null ? 0 : toInteger(fromIndex);
		if (index < 0) index = nativeMax(length + index, 0);
		return baseFindIndex(array, baseIteratee(predicate, 3), index);
	}
	module.exports = findIndex;
}));
var require_find = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require__createFind()(require_findIndex());
}));
var calculateViewBox = (0, (/* @__PURE__ */ __toESM(require_memoize())).default)(function(offset) {
	return {
		x: offset.left,
		y: offset.top,
		width: offset.width,
		height: offset.height
	};
}, function(offset) {
	return [
		"l",
		offset.left,
		"t",
		offset.top,
		"w",
		offset.width,
		"h",
		offset.height
	].join("");
});
var import_find = /* @__PURE__ */ __toESM(require_find());
var import_every = /* @__PURE__ */ __toESM(require_every());
function _typeof$11(o) {
	"@babel/helpers - typeof";
	return _typeof$11 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$11(o);
}
var XAxisContext = /* @__PURE__ */ (0, import_react.createContext)(void 0);
var YAxisContext = /* @__PURE__ */ (0, import_react.createContext)(void 0);
var ViewBoxContext = /* @__PURE__ */ (0, import_react.createContext)(void 0);
var OffsetContext = /* @__PURE__ */ (0, import_react.createContext)({});
var ClipPathIdContext = /* @__PURE__ */ (0, import_react.createContext)(void 0);
var ChartHeightContext = /* @__PURE__ */ (0, import_react.createContext)(0);
var ChartWidthContext = /* @__PURE__ */ (0, import_react.createContext)(0);
var ChartLayoutContextProvider = function ChartLayoutContextProvider$1(props) {
	var _props$state = props.state, xAxisMap = _props$state.xAxisMap, yAxisMap = _props$state.yAxisMap, offset = _props$state.offset, clipPathId = props.clipPathId, children = props.children, width = props.width, height = props.height;
	var viewBox = calculateViewBox(offset);
	return /* @__PURE__ */ import_react.createElement(XAxisContext.Provider, { value: xAxisMap }, /* @__PURE__ */ import_react.createElement(YAxisContext.Provider, { value: yAxisMap }, /* @__PURE__ */ import_react.createElement(OffsetContext.Provider, { value: offset }, /* @__PURE__ */ import_react.createElement(ViewBoxContext.Provider, { value: viewBox }, /* @__PURE__ */ import_react.createElement(ClipPathIdContext.Provider, { value: clipPathId }, /* @__PURE__ */ import_react.createElement(ChartHeightContext.Provider, { value: height }, /* @__PURE__ */ import_react.createElement(ChartWidthContext.Provider, { value: width }, children)))))));
};
var useClipPathId = function useClipPathId$1() {
	return (0, import_react.useContext)(ClipPathIdContext);
};
function getKeysForDebug(object) {
	var keys$6 = Object.keys(object);
	if (keys$6.length === 0) return "There are no available ids.";
	return "Available ids are: ".concat(keys$6, ".");
}
var useXAxisOrThrow = function useXAxisOrThrow$1(xAxisId) {
	var xAxisMap = (0, import_react.useContext)(XAxisContext);
	!(xAxisMap != null) && invariant(false, "Could not find Recharts context; are you sure this is rendered inside a Recharts wrapper component?");
	var xAxis = xAxisMap[xAxisId];
	!(xAxis != null) && invariant(false, "Could not find xAxis by id \"".concat(xAxisId, "\" [").concat(_typeof$11(xAxisId), "]. ").concat(getKeysForDebug(xAxisMap)));
	return xAxis;
};
var useArbitraryXAxis = function useArbitraryXAxis$1() {
	return getAnyElementOfObject((0, import_react.useContext)(XAxisContext));
};
var useYAxisWithFiniteDomainOrRandom = function useYAxisWithFiniteDomainOrRandom$1() {
	var yAxisMap = (0, import_react.useContext)(YAxisContext);
	return (0, import_find.default)(yAxisMap, function(axis) {
		return (0, import_every.default)(axis.domain, Number.isFinite);
	}) || getAnyElementOfObject(yAxisMap);
};
var useYAxisOrThrow = function useYAxisOrThrow$1(yAxisId) {
	var yAxisMap = (0, import_react.useContext)(YAxisContext);
	!(yAxisMap != null) && invariant(false, "Could not find Recharts context; are you sure this is rendered inside a Recharts wrapper component?");
	var yAxis = yAxisMap[yAxisId];
	!(yAxis != null) && invariant(false, "Could not find yAxis by id \"".concat(yAxisId, "\" [").concat(_typeof$11(yAxisId), "]. ").concat(getKeysForDebug(yAxisMap)));
	return yAxis;
};
var useViewBox = function useViewBox$1() {
	return (0, import_react.useContext)(ViewBoxContext);
};
var useOffset = function useOffset$1() {
	return (0, import_react.useContext)(OffsetContext);
};
var useChartWidth = function useChartWidth$1() {
	return (0, import_react.useContext)(ChartWidthContext);
};
var useChartHeight = function useChartHeight$1() {
	return (0, import_react.useContext)(ChartHeightContext);
};
var import_isFunction$6 = /* @__PURE__ */ __toESM(require_isFunction());
var import_some = /* @__PURE__ */ __toESM(require_some());
function _typeof$10(o) {
	"@babel/helpers - typeof";
	return _typeof$10 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$10(o);
}
function _classCallCheck$7(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$7(target, props) {
	for (var i = 0; i < props.length; i++) {
		var descriptor = props[i];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$10(descriptor.key), descriptor);
	}
}
function _createClass$7(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$7(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$7(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _callSuper$6(t, o, e) {
	return o = _getPrototypeOf$6(o), _possibleConstructorReturn$6(t, _isNativeReflectConstruct$6() ? Reflect.construct(o, e || [], _getPrototypeOf$6(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn$6(self$1, call) {
	if (call && (_typeof$10(call) === "object" || typeof call === "function")) return call;
	else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
	return _assertThisInitialized$6(self$1);
}
function _assertThisInitialized$6(self$1) {
	if (self$1 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return self$1;
}
function _isNativeReflectConstruct$6() {
	try {
		var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
	} catch (t$1) {}
	return (_isNativeReflectConstruct$6 = function _isNativeReflectConstruct$15() {
		return !!t;
	})();
}
function _getPrototypeOf$6(o) {
	_getPrototypeOf$6 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf$15(o$1) {
		return o$1.__proto__ || Object.getPrototypeOf(o$1);
	};
	return _getPrototypeOf$6(o);
}
function _inherits$6(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
	subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
		value: subClass,
		writable: true,
		configurable: true
	} });
	Object.defineProperty(subClass, "prototype", { writable: false });
	if (superClass) _setPrototypeOf$6(subClass, superClass);
}
function _setPrototypeOf$6(o, p) {
	_setPrototypeOf$6 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf$15(o$1, p$1) {
		o$1.__proto__ = p$1;
		return o$1;
	};
	return _setPrototypeOf$6(o, p);
}
function ownKeys$7(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$7(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$7(Object(t), !0).forEach(function(r$1) {
			_defineProperty$10(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$7(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}
function _defineProperty$10(obj, key, value) {
	key = _toPropertyKey$10(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$10(t) {
	var i = _toPrimitive$10(t, "string");
	return "symbol" == _typeof$10(i) ? i : i + "";
}
function _toPrimitive$10(t, r) {
	if ("object" != _typeof$10(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$10(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
function _slicedToArray$1(arr, i) {
	return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _unsupportedIterableToArray$2(arr, i) || _nonIterableRest$1();
}
function _nonIterableRest$1() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$2(o, minLen) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$2(o, minLen);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen);
}
function _arrayLikeToArray$2(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function _iterableToArrayLimit$1(r, l) {
	var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a$1 = [], f = !0, o = !1;
		try {
			if (i = (t = t.call(r)).next, 0 === l) {
				if (Object(t) !== t) return;
				f = !1;
			} else for (; !(f = (e = i.call(t)).done) && (a$1.push(e.value), a$1.length !== l); f = !0);
		} catch (r$1) {
			o = !0, n = r$1;
		} finally {
			try {
				if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a$1;
	}
}
function _arrayWithHoles$1(arr) {
	if (Array.isArray(arr)) return arr;
}
function _extends$7() {
	_extends$7 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$7.apply(this, arguments);
}
var renderLine = function renderLine$1(option, props) {
	var line;
	if (/* @__PURE__ */ import_react.isValidElement(option)) line = /* @__PURE__ */ import_react.cloneElement(option, props);
	else if ((0, import_isFunction$6.default)(option)) line = option(props);
	else line = /* @__PURE__ */ import_react.createElement("line", _extends$7({}, props, { className: "recharts-reference-line-line" }));
	return line;
};
var getEndPoints = function getEndPoints$1(scales, isFixedX, isFixedY, isSegment, viewBox, position, xAxisOrientation, yAxisOrientation, props) {
	var x$1 = viewBox.x, y$1 = viewBox.y, width = viewBox.width, height = viewBox.height;
	if (isFixedY) {
		var yCoord = props.y;
		var coord = scales.y.apply(yCoord, { position });
		if (ifOverflowMatches(props, "discard") && !scales.y.isInRange(coord)) return null;
		var points = [{
			x: x$1 + width,
			y: coord
		}, {
			x: x$1,
			y: coord
		}];
		return yAxisOrientation === "left" ? points.reverse() : points;
	}
	if (isFixedX) {
		var xCoord = props.x;
		var _coord = scales.x.apply(xCoord, { position });
		if (ifOverflowMatches(props, "discard") && !scales.x.isInRange(_coord)) return null;
		var _points = [{
			x: _coord,
			y: y$1 + height
		}, {
			x: _coord,
			y: y$1
		}];
		return xAxisOrientation === "top" ? _points.reverse() : _points;
	}
	if (isSegment) {
		var _points2 = props.segment.map(function(p) {
			return scales.apply(p, { position });
		});
		if (ifOverflowMatches(props, "discard") && (0, import_some.default)(_points2, function(p) {
			return !scales.isInRange(p);
		})) return null;
		return _points2;
	}
	return null;
};
function ReferenceLineImpl(props) {
	var fixedX = props.x, fixedY = props.y, segment = props.segment, xAxisId = props.xAxisId, yAxisId = props.yAxisId, shape = props.shape, className = props.className, alwaysShow = props.alwaysShow;
	var clipPathId = useClipPathId();
	var xAxis = useXAxisOrThrow(xAxisId);
	var yAxis = useYAxisOrThrow(yAxisId);
	var viewBox = useViewBox();
	if (!clipPathId || !viewBox) return null;
	warn(alwaysShow === void 0, "The alwaysShow prop is deprecated. Please use ifOverflow=\"extendDomain\" instead.");
	var endPoints = getEndPoints(createLabeledScales({
		x: xAxis.scale,
		y: yAxis.scale
	}), isNumOrStr(fixedX), isNumOrStr(fixedY), segment && segment.length === 2, viewBox, props.position, xAxis.orientation, yAxis.orientation, props);
	if (!endPoints) return null;
	var _endPoints = _slicedToArray$1(endPoints, 2), _endPoints$ = _endPoints[0], x1 = _endPoints$.x, y1 = _endPoints$.y, _endPoints$2 = _endPoints[1], x2 = _endPoints$2.x, y2 = _endPoints$2.y;
	var lineProps = _objectSpread$7(_objectSpread$7({ clipPath: ifOverflowMatches(props, "hidden") ? "url(#".concat(clipPathId, ")") : void 0 }, filterProps(props, true)), {}, {
		x1,
		y1,
		x2,
		y2
	});
	return /* @__PURE__ */ import_react.createElement(Layer, { className: clsx_default("recharts-reference-line", className) }, renderLine(shape, lineProps), Label.renderCallByParent(props, rectWithCoords({
		x1,
		y1,
		x2,
		y2
	})));
}
var ReferenceLine = /* @__PURE__ */ function(_React$Component) {
	function ReferenceLine$1() {
		_classCallCheck$7(this, ReferenceLine$1);
		return _callSuper$6(this, ReferenceLine$1, arguments);
	}
	_inherits$6(ReferenceLine$1, _React$Component);
	return _createClass$7(ReferenceLine$1, [{
		key: "render",
		value: function render() {
			return /* @__PURE__ */ import_react.createElement(ReferenceLineImpl, this.props);
		}
	}]);
}(import_react.Component);
_defineProperty$10(ReferenceLine, "displayName", "ReferenceLine");
_defineProperty$10(ReferenceLine, "defaultProps", {
	isFront: false,
	ifOverflow: "discard",
	xAxisId: 0,
	yAxisId: 0,
	fill: "none",
	stroke: "#ccc",
	fillOpacity: 1,
	strokeWidth: 1,
	position: "middle"
});
var import_isFunction$5 = /* @__PURE__ */ __toESM(require_isFunction());
function _extends$6() {
	_extends$6 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$6.apply(this, arguments);
}
function _typeof$9(o) {
	"@babel/helpers - typeof";
	return _typeof$9 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$9(o);
}
function ownKeys$6(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$6(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$6(Object(t), !0).forEach(function(r$1) {
			_defineProperty$9(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$6(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}
function _classCallCheck$6(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$6(target, props) {
	for (var i = 0; i < props.length; i++) {
		var descriptor = props[i];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$9(descriptor.key), descriptor);
	}
}
function _createClass$6(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$6(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$6(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _callSuper$5(t, o, e) {
	return o = _getPrototypeOf$5(o), _possibleConstructorReturn$5(t, _isNativeReflectConstruct$5() ? Reflect.construct(o, e || [], _getPrototypeOf$5(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn$5(self$1, call) {
	if (call && (_typeof$9(call) === "object" || typeof call === "function")) return call;
	else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
	return _assertThisInitialized$5(self$1);
}
function _assertThisInitialized$5(self$1) {
	if (self$1 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return self$1;
}
function _isNativeReflectConstruct$5() {
	try {
		var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
	} catch (t$1) {}
	return (_isNativeReflectConstruct$5 = function _isNativeReflectConstruct$15() {
		return !!t;
	})();
}
function _getPrototypeOf$5(o) {
	_getPrototypeOf$5 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf$15(o$1) {
		return o$1.__proto__ || Object.getPrototypeOf(o$1);
	};
	return _getPrototypeOf$5(o);
}
function _inherits$5(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
	subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
		value: subClass,
		writable: true,
		configurable: true
	} });
	Object.defineProperty(subClass, "prototype", { writable: false });
	if (superClass) _setPrototypeOf$5(subClass, superClass);
}
function _setPrototypeOf$5(o, p) {
	_setPrototypeOf$5 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf$15(o$1, p$1) {
		o$1.__proto__ = p$1;
		return o$1;
	};
	return _setPrototypeOf$5(o, p);
}
function _defineProperty$9(obj, key, value) {
	key = _toPropertyKey$9(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$9(t) {
	var i = _toPrimitive$9(t, "string");
	return "symbol" == _typeof$9(i) ? i : i + "";
}
function _toPrimitive$9(t, r) {
	if ("object" != _typeof$9(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$9(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
var getCoordinate = function getCoordinate$1(props) {
	var x$1 = props.x, y$1 = props.y, xAxis = props.xAxis, yAxis = props.yAxis;
	var scales = createLabeledScales({
		x: xAxis.scale,
		y: yAxis.scale
	});
	var result = scales.apply({
		x: x$1,
		y: y$1
	}, { bandAware: true });
	if (ifOverflowMatches(props, "discard") && !scales.isInRange(result)) return null;
	return result;
};
var ReferenceDot = /* @__PURE__ */ function(_React$Component) {
	function ReferenceDot$1() {
		_classCallCheck$6(this, ReferenceDot$1);
		return _callSuper$5(this, ReferenceDot$1, arguments);
	}
	_inherits$5(ReferenceDot$1, _React$Component);
	return _createClass$6(ReferenceDot$1, [{
		key: "render",
		value: function render() {
			var _this$props = this.props, x$1 = _this$props.x, y$1 = _this$props.y, r = _this$props.r, alwaysShow = _this$props.alwaysShow, clipPathId = _this$props.clipPathId;
			var isX = isNumOrStr(x$1);
			var isY = isNumOrStr(y$1);
			warn(alwaysShow === void 0, "The alwaysShow prop is deprecated. Please use ifOverflow=\"extendDomain\" instead.");
			if (!isX || !isY) return null;
			var coordinate = getCoordinate(this.props);
			if (!coordinate) return null;
			var cx = coordinate.x, cy = coordinate.y;
			var _this$props2 = this.props, shape = _this$props2.shape, className = _this$props2.className;
			var dotProps = _objectSpread$6(_objectSpread$6({ clipPath: ifOverflowMatches(this.props, "hidden") ? "url(#".concat(clipPathId, ")") : void 0 }, filterProps(this.props, true)), {}, {
				cx,
				cy
			});
			return /* @__PURE__ */ import_react.createElement(Layer, { className: clsx_default("recharts-reference-dot", className) }, ReferenceDot$1.renderDot(shape, dotProps), Label.renderCallByParent(this.props, {
				x: cx - r,
				y: cy - r,
				width: 2 * r,
				height: 2 * r
			}));
		}
	}]);
}(import_react.Component);
_defineProperty$9(ReferenceDot, "displayName", "ReferenceDot");
_defineProperty$9(ReferenceDot, "defaultProps", {
	isFront: false,
	ifOverflow: "discard",
	xAxisId: 0,
	yAxisId: 0,
	r: 10,
	fill: "#fff",
	stroke: "#ccc",
	fillOpacity: 1,
	strokeWidth: 1
});
_defineProperty$9(ReferenceDot, "renderDot", function(option, props) {
	var dot;
	if (/* @__PURE__ */ import_react.isValidElement(option)) dot = /* @__PURE__ */ import_react.cloneElement(option, props);
	else if ((0, import_isFunction$5.default)(option)) dot = option(props);
	else dot = /* @__PURE__ */ import_react.createElement(Dot, _extends$6({}, props, {
		cx: props.cx,
		cy: props.cy,
		className: "recharts-reference-dot-dot"
	}));
	return dot;
});
var import_isFunction$4 = /* @__PURE__ */ __toESM(require_isFunction());
function _extends$5() {
	_extends$5 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$5.apply(this, arguments);
}
function _typeof$8(o) {
	"@babel/helpers - typeof";
	return _typeof$8 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$8(o);
}
function ownKeys$5(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$5(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$5(Object(t), !0).forEach(function(r$1) {
			_defineProperty$8(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$5(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}
function _classCallCheck$5(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$5(target, props) {
	for (var i = 0; i < props.length; i++) {
		var descriptor = props[i];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$8(descriptor.key), descriptor);
	}
}
function _createClass$5(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$5(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$5(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _callSuper$4(t, o, e) {
	return o = _getPrototypeOf$4(o), _possibleConstructorReturn$4(t, _isNativeReflectConstruct$4() ? Reflect.construct(o, e || [], _getPrototypeOf$4(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn$4(self$1, call) {
	if (call && (_typeof$8(call) === "object" || typeof call === "function")) return call;
	else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
	return _assertThisInitialized$4(self$1);
}
function _assertThisInitialized$4(self$1) {
	if (self$1 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return self$1;
}
function _isNativeReflectConstruct$4() {
	try {
		var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
	} catch (t$1) {}
	return (_isNativeReflectConstruct$4 = function _isNativeReflectConstruct$15() {
		return !!t;
	})();
}
function _getPrototypeOf$4(o) {
	_getPrototypeOf$4 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf$15(o$1) {
		return o$1.__proto__ || Object.getPrototypeOf(o$1);
	};
	return _getPrototypeOf$4(o);
}
function _inherits$4(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
	subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
		value: subClass,
		writable: true,
		configurable: true
	} });
	Object.defineProperty(subClass, "prototype", { writable: false });
	if (superClass) _setPrototypeOf$4(subClass, superClass);
}
function _setPrototypeOf$4(o, p) {
	_setPrototypeOf$4 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf$15(o$1, p$1) {
		o$1.__proto__ = p$1;
		return o$1;
	};
	return _setPrototypeOf$4(o, p);
}
function _defineProperty$8(obj, key, value) {
	key = _toPropertyKey$8(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$8(t) {
	var i = _toPrimitive$8(t, "string");
	return "symbol" == _typeof$8(i) ? i : i + "";
}
function _toPrimitive$8(t, r) {
	if ("object" != _typeof$8(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$8(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
var getRect = function getRect$1(hasX1, hasX2, hasY1, hasY2, props) {
	var xValue1 = props.x1, xValue2 = props.x2, yValue1 = props.y1, yValue2 = props.y2, xAxis = props.xAxis, yAxis = props.yAxis;
	if (!xAxis || !yAxis) return null;
	var scales = createLabeledScales({
		x: xAxis.scale,
		y: yAxis.scale
	});
	var p1 = {
		x: hasX1 ? scales.x.apply(xValue1, { position: "start" }) : scales.x.rangeMin,
		y: hasY1 ? scales.y.apply(yValue1, { position: "start" }) : scales.y.rangeMin
	};
	var p2 = {
		x: hasX2 ? scales.x.apply(xValue2, { position: "end" }) : scales.x.rangeMax,
		y: hasY2 ? scales.y.apply(yValue2, { position: "end" }) : scales.y.rangeMax
	};
	if (ifOverflowMatches(props, "discard") && (!scales.isInRange(p1) || !scales.isInRange(p2))) return null;
	return rectWithPoints(p1, p2);
};
var ReferenceArea = /* @__PURE__ */ function(_React$Component) {
	function ReferenceArea$1() {
		_classCallCheck$5(this, ReferenceArea$1);
		return _callSuper$4(this, ReferenceArea$1, arguments);
	}
	_inherits$4(ReferenceArea$1, _React$Component);
	return _createClass$5(ReferenceArea$1, [{
		key: "render",
		value: function render() {
			var _this$props = this.props, x1 = _this$props.x1, x2 = _this$props.x2, y1 = _this$props.y1, y2 = _this$props.y2, className = _this$props.className, alwaysShow = _this$props.alwaysShow, clipPathId = _this$props.clipPathId;
			warn(alwaysShow === void 0, "The alwaysShow prop is deprecated. Please use ifOverflow=\"extendDomain\" instead.");
			var hasX1 = isNumOrStr(x1);
			var hasX2 = isNumOrStr(x2);
			var hasY1 = isNumOrStr(y1);
			var hasY2 = isNumOrStr(y2);
			var shape = this.props.shape;
			if (!hasX1 && !hasX2 && !hasY1 && !hasY2 && !shape) return null;
			var rect = getRect(hasX1, hasX2, hasY1, hasY2, this.props);
			if (!rect && !shape) return null;
			var clipPath = ifOverflowMatches(this.props, "hidden") ? "url(#".concat(clipPathId, ")") : void 0;
			return /* @__PURE__ */ import_react.createElement(Layer, { className: clsx_default("recharts-reference-area", className) }, ReferenceArea$1.renderRect(shape, _objectSpread$5(_objectSpread$5({ clipPath }, filterProps(this.props, true)), rect)), Label.renderCallByParent(this.props, rect));
		}
	}]);
}(import_react.Component);
_defineProperty$8(ReferenceArea, "displayName", "ReferenceArea");
_defineProperty$8(ReferenceArea, "defaultProps", {
	isFront: false,
	ifOverflow: "discard",
	xAxisId: 0,
	yAxisId: 0,
	r: 10,
	fill: "#ccc",
	fillOpacity: .5,
	stroke: "none",
	strokeWidth: 1
});
_defineProperty$8(ReferenceArea, "renderRect", function(option, props) {
	var rect;
	if (/* @__PURE__ */ import_react.isValidElement(option)) rect = /* @__PURE__ */ import_react.cloneElement(option, props);
	else if ((0, import_isFunction$4.default)(option)) rect = option(props);
	else rect = /* @__PURE__ */ import_react.createElement(Rectangle, _extends$5({}, props, { className: "recharts-reference-area-rect" }));
	return rect;
});
function getEveryNthWithCondition(array, n, isValid) {
	if (n < 1) return [];
	if (n === 1 && isValid === void 0) return array;
	var result = [];
	for (var i = 0; i < array.length; i += n) if (isValid === void 0 || isValid(array[i]) === true) result.push(array[i]);
	else return;
	return result;
}
function getAngledTickWidth(contentSize, unitSize, angle) {
	return getAngledRectangleWidth({
		width: contentSize.width + unitSize.width,
		height: contentSize.height + unitSize.height
	}, angle);
}
function getTickBoundaries(viewBox, sign$1, sizeKey) {
	var isWidth = sizeKey === "width";
	var x$1 = viewBox.x, y$1 = viewBox.y, width = viewBox.width, height = viewBox.height;
	if (sign$1 === 1) return {
		start: isWidth ? x$1 : y$1,
		end: isWidth ? x$1 + width : y$1 + height
	};
	return {
		start: isWidth ? x$1 + width : y$1 + height,
		end: isWidth ? x$1 : y$1
	};
}
function isVisible(sign$1, tickPosition, getSize, start, end) {
	if (sign$1 * tickPosition < sign$1 * start || sign$1 * tickPosition > sign$1 * end) return false;
	var size = getSize();
	return sign$1 * (tickPosition - sign$1 * size / 2 - start) >= 0 && sign$1 * (tickPosition + sign$1 * size / 2 - end) <= 0;
}
function getNumberIntervalTicks(ticks$1, interval) {
	return getEveryNthWithCondition(ticks$1, interval + 1);
}
function getEquidistantTicks(sign$1, boundaries, getTickSize, ticks$1, minTickGap) {
	var result = (ticks$1 || []).slice();
	var initialStart = boundaries.start, end = boundaries.end;
	var index = 0;
	var stepsize = 1;
	var start = initialStart;
	var _loop = function _loop$1() {
		var entry = ticks$1 === null || ticks$1 === void 0 ? void 0 : ticks$1[index];
		if (entry === void 0) return { v: getEveryNthWithCondition(ticks$1, stepsize) };
		var i = index;
		var size;
		var getSize = function getSize$1() {
			if (size === void 0) size = getTickSize(entry, i);
			return size;
		};
		var tickCoord = entry.coordinate;
		var isShow = index === 0 || isVisible(sign$1, tickCoord, getSize, start, end);
		if (!isShow) {
			index = 0;
			start = initialStart;
			stepsize += 1;
		}
		if (isShow) {
			start = tickCoord + sign$1 * (getSize() / 2 + minTickGap);
			index += stepsize;
		}
	}, _ret;
	while (stepsize <= result.length) {
		_ret = _loop();
		if (_ret) return _ret.v;
	}
	return [];
}
var import_isFunction$3 = /* @__PURE__ */ __toESM(require_isFunction());
function _typeof$7(o) {
	"@babel/helpers - typeof";
	return _typeof$7 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$7(o);
}
function ownKeys$4(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$4(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$4(Object(t), !0).forEach(function(r$1) {
			_defineProperty$7(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$4(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}
function _defineProperty$7(obj, key, value) {
	key = _toPropertyKey$7(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$7(t) {
	var i = _toPrimitive$7(t, "string");
	return "symbol" == _typeof$7(i) ? i : i + "";
}
function _toPrimitive$7(t, r) {
	if ("object" != _typeof$7(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$7(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
function getTicksEnd(sign$1, boundaries, getTickSize, ticks$1, minTickGap) {
	var result = (ticks$1 || []).slice();
	var len = result.length;
	var start = boundaries.start;
	var end = boundaries.end;
	var _loop = function _loop$1(i$1) {
		var entry = result[i$1];
		var size;
		var getSize = function getSize$1() {
			if (size === void 0) size = getTickSize(entry, i$1);
			return size;
		};
		if (i$1 === len - 1) {
			var gap = sign$1 * (entry.coordinate + sign$1 * getSize() / 2 - end);
			result[i$1] = entry = _objectSpread$4(_objectSpread$4({}, entry), {}, { tickCoord: gap > 0 ? entry.coordinate - gap * sign$1 : entry.coordinate });
		} else result[i$1] = entry = _objectSpread$4(_objectSpread$4({}, entry), {}, { tickCoord: entry.coordinate });
		if (isVisible(sign$1, entry.tickCoord, getSize, start, end)) {
			end = entry.tickCoord - sign$1 * (getSize() / 2 + minTickGap);
			result[i$1] = _objectSpread$4(_objectSpread$4({}, entry), {}, { isShow: true });
		}
	};
	for (var i = len - 1; i >= 0; i--) _loop(i);
	return result;
}
function getTicksStart(sign$1, boundaries, getTickSize, ticks$1, minTickGap, preserveEnd) {
	var result = (ticks$1 || []).slice();
	var len = result.length;
	var start = boundaries.start, end = boundaries.end;
	if (preserveEnd) {
		var tail = ticks$1[len - 1];
		var tailSize = getTickSize(tail, len - 1);
		var tailGap = sign$1 * (tail.coordinate + sign$1 * tailSize / 2 - end);
		result[len - 1] = tail = _objectSpread$4(_objectSpread$4({}, tail), {}, { tickCoord: tailGap > 0 ? tail.coordinate - tailGap * sign$1 : tail.coordinate });
		if (isVisible(sign$1, tail.tickCoord, function() {
			return tailSize;
		}, start, end)) {
			end = tail.tickCoord - sign$1 * (tailSize / 2 + minTickGap);
			result[len - 1] = _objectSpread$4(_objectSpread$4({}, tail), {}, { isShow: true });
		}
	}
	var count = preserveEnd ? len - 1 : len;
	var _loop2 = function _loop2$1(i$1) {
		var entry = result[i$1];
		var size;
		var getSize = function getSize$1() {
			if (size === void 0) size = getTickSize(entry, i$1);
			return size;
		};
		if (i$1 === 0) {
			var gap = sign$1 * (entry.coordinate - sign$1 * getSize() / 2 - start);
			result[i$1] = entry = _objectSpread$4(_objectSpread$4({}, entry), {}, { tickCoord: gap < 0 ? entry.coordinate - gap * sign$1 : entry.coordinate });
		} else result[i$1] = entry = _objectSpread$4(_objectSpread$4({}, entry), {}, { tickCoord: entry.coordinate });
		if (isVisible(sign$1, entry.tickCoord, getSize, start, end)) {
			start = entry.tickCoord + sign$1 * (getSize() / 2 + minTickGap);
			result[i$1] = _objectSpread$4(_objectSpread$4({}, entry), {}, { isShow: true });
		}
	};
	for (var i = 0; i < count; i++) _loop2(i);
	return result;
}
function getTicks(props, fontSize, letterSpacing) {
	var tick = props.tick, ticks$1 = props.ticks, viewBox = props.viewBox, minTickGap = props.minTickGap, orientation = props.orientation, interval = props.interval, tickFormatter = props.tickFormatter, unit$1 = props.unit, angle = props.angle;
	if (!ticks$1 || !ticks$1.length || !tick) return [];
	if (isNumber(interval) || Global.isSsr) return getNumberIntervalTicks(ticks$1, typeof interval === "number" && isNumber(interval) ? interval : 0);
	var candidates = [];
	var sizeKey = orientation === "top" || orientation === "bottom" ? "width" : "height";
	var unitSize = unit$1 && sizeKey === "width" ? getStringSize(unit$1, {
		fontSize,
		letterSpacing
	}) : {
		width: 0,
		height: 0
	};
	var getTickSize = function getTickSize$1(content, index) {
		var value = (0, import_isFunction$3.default)(tickFormatter) ? tickFormatter(content.value, index) : content.value;
		return sizeKey === "width" ? getAngledTickWidth(getStringSize(value, {
			fontSize,
			letterSpacing
		}), unitSize, angle) : getStringSize(value, {
			fontSize,
			letterSpacing
		})[sizeKey];
	};
	var sign$1 = ticks$1.length >= 2 ? mathSign(ticks$1[1].coordinate - ticks$1[0].coordinate) : 1;
	var boundaries = getTickBoundaries(viewBox, sign$1, sizeKey);
	if (interval === "equidistantPreserveStart") return getEquidistantTicks(sign$1, boundaries, getTickSize, ticks$1, minTickGap);
	if (interval === "preserveStart" || interval === "preserveStartEnd") candidates = getTicksStart(sign$1, boundaries, getTickSize, ticks$1, minTickGap, interval === "preserveStartEnd");
	else candidates = getTicksEnd(sign$1, boundaries, getTickSize, ticks$1, minTickGap);
	return candidates.filter(function(entry) {
		return entry.isShow;
	});
}
var import_isFunction$2 = /* @__PURE__ */ __toESM(require_isFunction());
var import_get$1 = /* @__PURE__ */ __toESM(require_get());
var _excluded$2 = ["viewBox"], _excluded2$2 = ["viewBox"], _excluded3 = ["ticks"];
function _typeof$6(o) {
	"@babel/helpers - typeof";
	return _typeof$6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$6(o);
}
function _extends$4() {
	_extends$4 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$4.apply(this, arguments);
}
function ownKeys$3(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$3(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$3(Object(t), !0).forEach(function(r$1) {
			_defineProperty$6(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}
function _objectWithoutProperties$2(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$2(source, excluded);
	var key, i;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i = 0; i < sourceSymbolKeys.length; i++) {
			key = sourceSymbolKeys[i];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$2(source, excluded) {
	if (source == null) return {};
	var target = {};
	for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function _classCallCheck$4(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$4(target, props) {
	for (var i = 0; i < props.length; i++) {
		var descriptor = props[i];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$6(descriptor.key), descriptor);
	}
}
function _createClass$4(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$4(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$4(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _callSuper$3(t, o, e) {
	return o = _getPrototypeOf$3(o), _possibleConstructorReturn$3(t, _isNativeReflectConstruct$3() ? Reflect.construct(o, e || [], _getPrototypeOf$3(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn$3(self$1, call) {
	if (call && (_typeof$6(call) === "object" || typeof call === "function")) return call;
	else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
	return _assertThisInitialized$3(self$1);
}
function _assertThisInitialized$3(self$1) {
	if (self$1 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return self$1;
}
function _isNativeReflectConstruct$3() {
	try {
		var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
	} catch (t$1) {}
	return (_isNativeReflectConstruct$3 = function _isNativeReflectConstruct$15() {
		return !!t;
	})();
}
function _getPrototypeOf$3(o) {
	_getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf$15(o$1) {
		return o$1.__proto__ || Object.getPrototypeOf(o$1);
	};
	return _getPrototypeOf$3(o);
}
function _inherits$3(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
	subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
		value: subClass,
		writable: true,
		configurable: true
	} });
	Object.defineProperty(subClass, "prototype", { writable: false });
	if (superClass) _setPrototypeOf$3(subClass, superClass);
}
function _setPrototypeOf$3(o, p) {
	_setPrototypeOf$3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf$15(o$1, p$1) {
		o$1.__proto__ = p$1;
		return o$1;
	};
	return _setPrototypeOf$3(o, p);
}
function _defineProperty$6(obj, key, value) {
	key = _toPropertyKey$6(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$6(t) {
	var i = _toPrimitive$6(t, "string");
	return "symbol" == _typeof$6(i) ? i : i + "";
}
function _toPrimitive$6(t, r) {
	if ("object" != _typeof$6(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$6(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
var CartesianAxis = /* @__PURE__ */ function(_Component) {
	function CartesianAxis$1(props) {
		var _this;
		_classCallCheck$4(this, CartesianAxis$1);
		_this = _callSuper$3(this, CartesianAxis$1, [props]);
		_this.state = {
			fontSize: "",
			letterSpacing: ""
		};
		return _this;
	}
	_inherits$3(CartesianAxis$1, _Component);
	return _createClass$4(CartesianAxis$1, [
		{
			key: "shouldComponentUpdate",
			value: function shouldComponentUpdate(_ref, nextState) {
				var viewBox = _ref.viewBox, restProps = _objectWithoutProperties$2(_ref, _excluded$2);
				var _this$props = this.props, viewBoxOld = _this$props.viewBox, restPropsOld = _objectWithoutProperties$2(_this$props, _excluded2$2);
				return !shallowEqual(viewBox, viewBoxOld) || !shallowEqual(restProps, restPropsOld) || !shallowEqual(nextState, this.state);
			}
		},
		{
			key: "componentDidMount",
			value: function componentDidMount() {
				var htmlLayer = this.layerReference;
				if (!htmlLayer) return;
				var tick = htmlLayer.getElementsByClassName("recharts-cartesian-axis-tick-value")[0];
				if (tick) this.setState({
					fontSize: window.getComputedStyle(tick).fontSize,
					letterSpacing: window.getComputedStyle(tick).letterSpacing
				});
			}
		},
		{
			key: "getTickLineCoord",
			value: function getTickLineCoord(data) {
				var _this$props2 = this.props, x$1 = _this$props2.x, y$1 = _this$props2.y, width = _this$props2.width, height = _this$props2.height, orientation = _this$props2.orientation, tickSize = _this$props2.tickSize, mirror = _this$props2.mirror, tickMargin = _this$props2.tickMargin;
				var x1, x2, y1, y2, tx, ty;
				var sign$1 = mirror ? -1 : 1;
				var finalTickSize = data.tickSize || tickSize;
				var tickCoord = isNumber(data.tickCoord) ? data.tickCoord : data.coordinate;
				switch (orientation) {
					case "top":
						x1 = x2 = data.coordinate;
						y2 = y$1 + +!mirror * height;
						y1 = y2 - sign$1 * finalTickSize;
						ty = y1 - sign$1 * tickMargin;
						tx = tickCoord;
						break;
					case "left":
						y1 = y2 = data.coordinate;
						x2 = x$1 + +!mirror * width;
						x1 = x2 - sign$1 * finalTickSize;
						tx = x1 - sign$1 * tickMargin;
						ty = tickCoord;
						break;
					case "right":
						y1 = y2 = data.coordinate;
						x2 = x$1 + +mirror * width;
						x1 = x2 + sign$1 * finalTickSize;
						tx = x1 + sign$1 * tickMargin;
						ty = tickCoord;
						break;
					default:
						x1 = x2 = data.coordinate;
						y2 = y$1 + +mirror * height;
						y1 = y2 + sign$1 * finalTickSize;
						ty = y1 + sign$1 * tickMargin;
						tx = tickCoord;
						break;
				}
				return {
					line: {
						x1,
						y1,
						x2,
						y2
					},
					tick: {
						x: tx,
						y: ty
					}
				};
			}
		},
		{
			key: "getTickTextAnchor",
			value: function getTickTextAnchor() {
				var _this$props3 = this.props, orientation = _this$props3.orientation, mirror = _this$props3.mirror;
				var textAnchor;
				switch (orientation) {
					case "left":
						textAnchor = mirror ? "start" : "end";
						break;
					case "right":
						textAnchor = mirror ? "end" : "start";
						break;
					default:
						textAnchor = "middle";
						break;
				}
				return textAnchor;
			}
		},
		{
			key: "getTickVerticalAnchor",
			value: function getTickVerticalAnchor() {
				var _this$props4 = this.props, orientation = _this$props4.orientation, mirror = _this$props4.mirror;
				var verticalAnchor = "end";
				switch (orientation) {
					case "left":
					case "right":
						verticalAnchor = "middle";
						break;
					case "top":
						verticalAnchor = mirror ? "start" : "end";
						break;
					default:
						verticalAnchor = mirror ? "end" : "start";
						break;
				}
				return verticalAnchor;
			}
		},
		{
			key: "renderAxisLine",
			value: function renderAxisLine() {
				var _this$props5 = this.props, x$1 = _this$props5.x, y$1 = _this$props5.y, width = _this$props5.width, height = _this$props5.height, orientation = _this$props5.orientation, mirror = _this$props5.mirror, axisLine = _this$props5.axisLine;
				var props = _objectSpread$3(_objectSpread$3(_objectSpread$3({}, filterProps(this.props, false)), filterProps(axisLine, false)), {}, { fill: "none" });
				if (orientation === "top" || orientation === "bottom") {
					var needHeight = +(orientation === "top" && !mirror || orientation === "bottom" && mirror);
					props = _objectSpread$3(_objectSpread$3({}, props), {}, {
						x1: x$1,
						y1: y$1 + needHeight * height,
						x2: x$1 + width,
						y2: y$1 + needHeight * height
					});
				} else {
					var needWidth = +(orientation === "left" && !mirror || orientation === "right" && mirror);
					props = _objectSpread$3(_objectSpread$3({}, props), {}, {
						x1: x$1 + needWidth * width,
						y1: y$1,
						x2: x$1 + needWidth * width,
						y2: y$1 + height
					});
				}
				return /* @__PURE__ */ import_react.createElement("line", _extends$4({}, props, { className: clsx_default("recharts-cartesian-axis-line", (0, import_get$1.default)(axisLine, "className")) }));
			}
		},
		{
			key: "renderTicks",
			value: function renderTicks(ticks$1, fontSize, letterSpacing) {
				var _this2 = this;
				var _this$props6 = this.props, tickLine = _this$props6.tickLine, stroke = _this$props6.stroke, tick = _this$props6.tick, tickFormatter = _this$props6.tickFormatter, unit$1 = _this$props6.unit;
				var finalTicks = getTicks(_objectSpread$3(_objectSpread$3({}, this.props), {}, { ticks: ticks$1 }), fontSize, letterSpacing);
				var textAnchor = this.getTickTextAnchor();
				var verticalAnchor = this.getTickVerticalAnchor();
				var axisProps = filterProps(this.props, false);
				var customTickProps = filterProps(tick, false);
				var tickLineProps = _objectSpread$3(_objectSpread$3({}, axisProps), {}, { fill: "none" }, filterProps(tickLine, false));
				var items = finalTicks.map(function(entry, i) {
					var _this2$getTickLineCoo = _this2.getTickLineCoord(entry), lineCoord = _this2$getTickLineCoo.line, tickCoord = _this2$getTickLineCoo.tick;
					var tickProps = _objectSpread$3(_objectSpread$3(_objectSpread$3(_objectSpread$3({
						textAnchor,
						verticalAnchor
					}, axisProps), {}, {
						stroke: "none",
						fill: stroke
					}, customTickProps), tickCoord), {}, {
						index: i,
						payload: entry,
						visibleTicksCount: finalTicks.length,
						tickFormatter
					});
					return /* @__PURE__ */ import_react.createElement(Layer, _extends$4({
						className: "recharts-cartesian-axis-tick",
						key: "tick-".concat(entry.value, "-").concat(entry.coordinate, "-").concat(entry.tickCoord)
					}, adaptEventsOfChild(_this2.props, entry, i)), tickLine && /* @__PURE__ */ import_react.createElement("line", _extends$4({}, tickLineProps, lineCoord, { className: clsx_default("recharts-cartesian-axis-tick-line", (0, import_get$1.default)(tickLine, "className")) })), tick && CartesianAxis$1.renderTickItem(tick, tickProps, "".concat((0, import_isFunction$2.default)(tickFormatter) ? tickFormatter(entry.value, i) : entry.value).concat(unit$1 || "")));
				});
				return /* @__PURE__ */ import_react.createElement("g", { className: "recharts-cartesian-axis-ticks" }, items);
			}
		},
		{
			key: "render",
			value: function render() {
				var _this3 = this;
				var _this$props7 = this.props, axisLine = _this$props7.axisLine, width = _this$props7.width, height = _this$props7.height, ticksGenerator = _this$props7.ticksGenerator, className = _this$props7.className;
				if (_this$props7.hide) return null;
				var _this$props8 = this.props, ticks$1 = _this$props8.ticks, noTicksProps = _objectWithoutProperties$2(_this$props8, _excluded3);
				var finalTicks = ticks$1;
				if ((0, import_isFunction$2.default)(ticksGenerator)) finalTicks = ticks$1 && ticks$1.length > 0 ? ticksGenerator(this.props) : ticksGenerator(noTicksProps);
				if (width <= 0 || height <= 0 || !finalTicks || !finalTicks.length) return null;
				return /* @__PURE__ */ import_react.createElement(Layer, {
					className: clsx_default("recharts-cartesian-axis", className),
					ref: function ref(_ref2) {
						_this3.layerReference = _ref2;
					}
				}, axisLine && this.renderAxisLine(), this.renderTicks(finalTicks, this.state.fontSize, this.state.letterSpacing), Label.renderCallByParent(this.props));
			}
		}
	], [{
		key: "renderTickItem",
		value: function renderTickItem(option, props, value) {
			var tickItem;
			var combinedClassName = clsx_default(props.className, "recharts-cartesian-axis-tick-value");
			if (/* @__PURE__ */ import_react.isValidElement(option)) tickItem = /* @__PURE__ */ import_react.cloneElement(option, _objectSpread$3(_objectSpread$3({}, props), {}, { className: combinedClassName }));
			else if ((0, import_isFunction$2.default)(option)) tickItem = option(_objectSpread$3(_objectSpread$3({}, props), {}, { className: combinedClassName }));
			else tickItem = /* @__PURE__ */ import_react.createElement(Text, _extends$4({}, props, { className: "recharts-cartesian-axis-tick-value" }), value);
			return tickItem;
		}
	}]);
}(import_react.Component);
_defineProperty$6(CartesianAxis, "displayName", "CartesianAxis");
_defineProperty$6(CartesianAxis, "defaultProps", {
	x: 0,
	y: 0,
	width: 0,
	height: 0,
	viewBox: {
		x: 0,
		y: 0,
		width: 0,
		height: 0
	},
	orientation: "bottom",
	ticks: [],
	stroke: "#666",
	tickLine: true,
	axisLine: true,
	tick: true,
	mirror: false,
	minTickGap: 5,
	tickSize: 6,
	tickMargin: 2,
	interval: "preserveEnd"
});
var import_isFunction$1 = /* @__PURE__ */ __toESM(require_isFunction());
var _excluded$1 = [
	"x1",
	"y1",
	"x2",
	"y2",
	"key"
], _excluded2$1 = ["offset"];
function _typeof$5(o) {
	"@babel/helpers - typeof";
	return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$5(o);
}
function ownKeys$2(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$2(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$2(Object(t), !0).forEach(function(r$1) {
			_defineProperty$5(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}
function _defineProperty$5(obj, key, value) {
	key = _toPropertyKey$5(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$5(t) {
	var i = _toPrimitive$5(t, "string");
	return "symbol" == _typeof$5(i) ? i : i + "";
}
function _toPrimitive$5(t, r) {
	if ("object" != _typeof$5(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$5(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
function _extends$3() {
	_extends$3 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$3.apply(this, arguments);
}
function _objectWithoutProperties$1(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose$1(source, excluded);
	var key, i;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i = 0; i < sourceSymbolKeys.length; i++) {
			key = sourceSymbolKeys[i];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
	if (source == null) return {};
	var target = {};
	for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
var Background = function Background$1(props) {
	var fill = props.fill;
	if (!fill || fill === "none") return null;
	var fillOpacity = props.fillOpacity, x$1 = props.x, y$1 = props.y, width = props.width, height = props.height, ry = props.ry;
	return /* @__PURE__ */ import_react.createElement("rect", {
		x: x$1,
		y: y$1,
		ry,
		width,
		height,
		stroke: "none",
		fill,
		fillOpacity,
		className: "recharts-cartesian-grid-bg"
	});
};
function renderLineItem(option, props) {
	var lineItem;
	if (/* @__PURE__ */ import_react.isValidElement(option)) lineItem = /* @__PURE__ */ import_react.cloneElement(option, props);
	else if ((0, import_isFunction$1.default)(option)) lineItem = option(props);
	else {
		var x1 = props.x1, y1 = props.y1, x2 = props.x2, y2 = props.y2, key = props.key, _filterProps = filterProps(_objectWithoutProperties$1(props, _excluded$1), false);
		_filterProps.offset;
		var restOfFilteredProps = _objectWithoutProperties$1(_filterProps, _excluded2$1);
		lineItem = /* @__PURE__ */ import_react.createElement("line", _extends$3({}, restOfFilteredProps, {
			x1,
			y1,
			x2,
			y2,
			fill: "none",
			key
		}));
	}
	return lineItem;
}
function HorizontalGridLines(props) {
	var x$1 = props.x, width = props.width, _props$horizontal = props.horizontal, horizontal = _props$horizontal === void 0 ? true : _props$horizontal, horizontalPoints = props.horizontalPoints;
	if (!horizontal || !horizontalPoints || !horizontalPoints.length) return null;
	var items = horizontalPoints.map(function(entry, i) {
		return renderLineItem(horizontal, _objectSpread$2(_objectSpread$2({}, props), {}, {
			x1: x$1,
			y1: entry,
			x2: x$1 + width,
			y2: entry,
			key: "line-".concat(i),
			index: i
		}));
	});
	return /* @__PURE__ */ import_react.createElement("g", { className: "recharts-cartesian-grid-horizontal" }, items);
}
function VerticalGridLines(props) {
	var y$1 = props.y, height = props.height, _props$vertical = props.vertical, vertical = _props$vertical === void 0 ? true : _props$vertical, verticalPoints = props.verticalPoints;
	if (!vertical || !verticalPoints || !verticalPoints.length) return null;
	var items = verticalPoints.map(function(entry, i) {
		return renderLineItem(vertical, _objectSpread$2(_objectSpread$2({}, props), {}, {
			x1: entry,
			y1: y$1,
			x2: entry,
			y2: y$1 + height,
			key: "line-".concat(i),
			index: i
		}));
	});
	return /* @__PURE__ */ import_react.createElement("g", { className: "recharts-cartesian-grid-vertical" }, items);
}
function HorizontalStripes(props) {
	var horizontalFill = props.horizontalFill, fillOpacity = props.fillOpacity, x$1 = props.x, y$1 = props.y, width = props.width, height = props.height, horizontalPoints = props.horizontalPoints, _props$horizontal2 = props.horizontal;
	if (!(_props$horizontal2 === void 0 ? true : _props$horizontal2) || !horizontalFill || !horizontalFill.length) return null;
	var roundedSortedHorizontalPoints = horizontalPoints.map(function(e) {
		return Math.round(e + y$1 - y$1);
	}).sort(function(a$1, b) {
		return a$1 - b;
	});
	if (y$1 !== roundedSortedHorizontalPoints[0]) roundedSortedHorizontalPoints.unshift(0);
	var items = roundedSortedHorizontalPoints.map(function(entry, i) {
		var lineHeight = !roundedSortedHorizontalPoints[i + 1] ? y$1 + height - entry : roundedSortedHorizontalPoints[i + 1] - entry;
		if (lineHeight <= 0) return null;
		var colorIndex = i % horizontalFill.length;
		return /* @__PURE__ */ import_react.createElement("rect", {
			key: "react-".concat(i),
			y: entry,
			x: x$1,
			height: lineHeight,
			width,
			stroke: "none",
			fill: horizontalFill[colorIndex],
			fillOpacity,
			className: "recharts-cartesian-grid-bg"
		});
	});
	return /* @__PURE__ */ import_react.createElement("g", { className: "recharts-cartesian-gridstripes-horizontal" }, items);
}
function VerticalStripes(props) {
	var _props$vertical2 = props.vertical, vertical = _props$vertical2 === void 0 ? true : _props$vertical2, verticalFill = props.verticalFill, fillOpacity = props.fillOpacity, x$1 = props.x, y$1 = props.y, width = props.width, height = props.height, verticalPoints = props.verticalPoints;
	if (!vertical || !verticalFill || !verticalFill.length) return null;
	var roundedSortedVerticalPoints = verticalPoints.map(function(e) {
		return Math.round(e + x$1 - x$1);
	}).sort(function(a$1, b) {
		return a$1 - b;
	});
	if (x$1 !== roundedSortedVerticalPoints[0]) roundedSortedVerticalPoints.unshift(0);
	var items = roundedSortedVerticalPoints.map(function(entry, i) {
		var lineWidth = !roundedSortedVerticalPoints[i + 1] ? x$1 + width - entry : roundedSortedVerticalPoints[i + 1] - entry;
		if (lineWidth <= 0) return null;
		var colorIndex = i % verticalFill.length;
		return /* @__PURE__ */ import_react.createElement("rect", {
			key: "react-".concat(i),
			x: entry,
			y: y$1,
			width: lineWidth,
			height,
			stroke: "none",
			fill: verticalFill[colorIndex],
			fillOpacity,
			className: "recharts-cartesian-grid-bg"
		});
	});
	return /* @__PURE__ */ import_react.createElement("g", { className: "recharts-cartesian-gridstripes-vertical" }, items);
}
var defaultVerticalCoordinatesGenerator = function defaultVerticalCoordinatesGenerator$1(_ref, syncWithTicks) {
	var xAxis = _ref.xAxis, width = _ref.width, height = _ref.height, offset = _ref.offset;
	return getCoordinatesOfGrid(getTicks(_objectSpread$2(_objectSpread$2(_objectSpread$2({}, CartesianAxis.defaultProps), xAxis), {}, {
		ticks: getTicksOfAxis(xAxis, true),
		viewBox: {
			x: 0,
			y: 0,
			width,
			height
		}
	})), offset.left, offset.left + offset.width, syncWithTicks);
};
var defaultHorizontalCoordinatesGenerator = function defaultHorizontalCoordinatesGenerator$1(_ref2, syncWithTicks) {
	var yAxis = _ref2.yAxis, width = _ref2.width, height = _ref2.height, offset = _ref2.offset;
	return getCoordinatesOfGrid(getTicks(_objectSpread$2(_objectSpread$2(_objectSpread$2({}, CartesianAxis.defaultProps), yAxis), {}, {
		ticks: getTicksOfAxis(yAxis, true),
		viewBox: {
			x: 0,
			y: 0,
			width,
			height
		}
	})), offset.top, offset.top + offset.height, syncWithTicks);
};
var defaultProps = {
	horizontal: true,
	vertical: true,
	horizontalPoints: [],
	verticalPoints: [],
	stroke: "#ccc",
	fill: "none",
	verticalFill: [],
	horizontalFill: []
};
function CartesianGrid(props) {
	var _props$stroke, _props$fill, _props$horizontal3, _props$horizontalFill, _props$vertical3, _props$verticalFill;
	var chartWidth = useChartWidth();
	var chartHeight = useChartHeight();
	var offset = useOffset();
	var propsIncludingDefaults = _objectSpread$2(_objectSpread$2({}, props), {}, {
		stroke: (_props$stroke = props.stroke) !== null && _props$stroke !== void 0 ? _props$stroke : defaultProps.stroke,
		fill: (_props$fill = props.fill) !== null && _props$fill !== void 0 ? _props$fill : defaultProps.fill,
		horizontal: (_props$horizontal3 = props.horizontal) !== null && _props$horizontal3 !== void 0 ? _props$horizontal3 : defaultProps.horizontal,
		horizontalFill: (_props$horizontalFill = props.horizontalFill) !== null && _props$horizontalFill !== void 0 ? _props$horizontalFill : defaultProps.horizontalFill,
		vertical: (_props$vertical3 = props.vertical) !== null && _props$vertical3 !== void 0 ? _props$vertical3 : defaultProps.vertical,
		verticalFill: (_props$verticalFill = props.verticalFill) !== null && _props$verticalFill !== void 0 ? _props$verticalFill : defaultProps.verticalFill,
		x: isNumber(props.x) ? props.x : offset.left,
		y: isNumber(props.y) ? props.y : offset.top,
		width: isNumber(props.width) ? props.width : offset.width,
		height: isNumber(props.height) ? props.height : offset.height
	});
	var x$1 = propsIncludingDefaults.x, y$1 = propsIncludingDefaults.y, width = propsIncludingDefaults.width, height = propsIncludingDefaults.height, syncWithTicks = propsIncludingDefaults.syncWithTicks, horizontalValues = propsIncludingDefaults.horizontalValues, verticalValues = propsIncludingDefaults.verticalValues;
	var xAxis = useArbitraryXAxis();
	var yAxis = useYAxisWithFiniteDomainOrRandom();
	if (!isNumber(width) || width <= 0 || !isNumber(height) || height <= 0 || !isNumber(x$1) || x$1 !== +x$1 || !isNumber(y$1) || y$1 !== +y$1) return null;
	var verticalCoordinatesGenerator = propsIncludingDefaults.verticalCoordinatesGenerator || defaultVerticalCoordinatesGenerator;
	var horizontalCoordinatesGenerator = propsIncludingDefaults.horizontalCoordinatesGenerator || defaultHorizontalCoordinatesGenerator;
	var horizontalPoints = propsIncludingDefaults.horizontalPoints, verticalPoints = propsIncludingDefaults.verticalPoints;
	if ((!horizontalPoints || !horizontalPoints.length) && (0, import_isFunction$1.default)(horizontalCoordinatesGenerator)) {
		var isHorizontalValues = horizontalValues && horizontalValues.length;
		var generatorResult = horizontalCoordinatesGenerator({
			yAxis: yAxis ? _objectSpread$2(_objectSpread$2({}, yAxis), {}, { ticks: isHorizontalValues ? horizontalValues : yAxis.ticks }) : void 0,
			width: chartWidth,
			height: chartHeight,
			offset
		}, isHorizontalValues ? true : syncWithTicks);
		warn(Array.isArray(generatorResult), "horizontalCoordinatesGenerator should return Array but instead it returned [".concat(_typeof$5(generatorResult), "]"));
		if (Array.isArray(generatorResult)) horizontalPoints = generatorResult;
	}
	if ((!verticalPoints || !verticalPoints.length) && (0, import_isFunction$1.default)(verticalCoordinatesGenerator)) {
		var isVerticalValues = verticalValues && verticalValues.length;
		var _generatorResult = verticalCoordinatesGenerator({
			xAxis: xAxis ? _objectSpread$2(_objectSpread$2({}, xAxis), {}, { ticks: isVerticalValues ? verticalValues : xAxis.ticks }) : void 0,
			width: chartWidth,
			height: chartHeight,
			offset
		}, isVerticalValues ? true : syncWithTicks);
		warn(Array.isArray(_generatorResult), "verticalCoordinatesGenerator should return Array but instead it returned [".concat(_typeof$5(_generatorResult), "]"));
		if (Array.isArray(_generatorResult)) verticalPoints = _generatorResult;
	}
	return /* @__PURE__ */ import_react.createElement("g", { className: "recharts-cartesian-grid" }, /* @__PURE__ */ import_react.createElement(Background, {
		fill: propsIncludingDefaults.fill,
		fillOpacity: propsIncludingDefaults.fillOpacity,
		x: propsIncludingDefaults.x,
		y: propsIncludingDefaults.y,
		width: propsIncludingDefaults.width,
		height: propsIncludingDefaults.height,
		ry: propsIncludingDefaults.ry
	}), /* @__PURE__ */ import_react.createElement(HorizontalGridLines, _extends$3({}, propsIncludingDefaults, {
		offset,
		horizontalPoints,
		xAxis,
		yAxis
	})), /* @__PURE__ */ import_react.createElement(VerticalGridLines, _extends$3({}, propsIncludingDefaults, {
		offset,
		verticalPoints,
		xAxis,
		yAxis
	})), /* @__PURE__ */ import_react.createElement(HorizontalStripes, _extends$3({}, propsIncludingDefaults, { horizontalPoints })), /* @__PURE__ */ import_react.createElement(VerticalStripes, _extends$3({}, propsIncludingDefaults, { verticalPoints })));
}
CartesianGrid.displayName = "CartesianGrid";
function _typeof$4(o) {
	"@babel/helpers - typeof";
	return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$4(o);
}
function _classCallCheck$3(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$3(target, props) {
	for (var i = 0; i < props.length; i++) {
		var descriptor = props[i];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$4(descriptor.key), descriptor);
	}
}
function _createClass$3(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$3(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$3(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _callSuper$2(t, o, e) {
	return o = _getPrototypeOf$2(o), _possibleConstructorReturn$2(t, _isNativeReflectConstruct$2() ? Reflect.construct(o, e || [], _getPrototypeOf$2(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn$2(self$1, call) {
	if (call && (_typeof$4(call) === "object" || typeof call === "function")) return call;
	else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
	return _assertThisInitialized$2(self$1);
}
function _assertThisInitialized$2(self$1) {
	if (self$1 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return self$1;
}
function _isNativeReflectConstruct$2() {
	try {
		var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
	} catch (t$1) {}
	return (_isNativeReflectConstruct$2 = function _isNativeReflectConstruct$15() {
		return !!t;
	})();
}
function _getPrototypeOf$2(o) {
	_getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf$15(o$1) {
		return o$1.__proto__ || Object.getPrototypeOf(o$1);
	};
	return _getPrototypeOf$2(o);
}
function _inherits$2(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
	subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
		value: subClass,
		writable: true,
		configurable: true
	} });
	Object.defineProperty(subClass, "prototype", { writable: false });
	if (superClass) _setPrototypeOf$2(subClass, superClass);
}
function _setPrototypeOf$2(o, p) {
	_setPrototypeOf$2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf$15(o$1, p$1) {
		o$1.__proto__ = p$1;
		return o$1;
	};
	return _setPrototypeOf$2(o, p);
}
function _defineProperty$4(obj, key, value) {
	key = _toPropertyKey$4(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$4(t) {
	var i = _toPrimitive$4(t, "string");
	return "symbol" == _typeof$4(i) ? i : i + "";
}
function _toPrimitive$4(t, r) {
	if ("object" != _typeof$4(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$4(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
function _extends$2() {
	_extends$2 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$2.apply(this, arguments);
}
function XAxisImpl(_ref) {
	var xAxisId = _ref.xAxisId;
	var width = useChartWidth();
	var height = useChartHeight();
	var axisOptions = useXAxisOrThrow(xAxisId);
	if (axisOptions == null) return null;
	return /* @__PURE__ */ import_react.createElement(CartesianAxis, _extends$2({}, axisOptions, {
		className: clsx_default("recharts-".concat(axisOptions.axisType, " ").concat(axisOptions.axisType), axisOptions.className),
		viewBox: {
			x: 0,
			y: 0,
			width,
			height
		},
		ticksGenerator: function ticksGenerator(axis) {
			return getTicksOfAxis(axis, true);
		}
	}));
}
var XAxis = /* @__PURE__ */ function(_React$Component) {
	function XAxis$1() {
		_classCallCheck$3(this, XAxis$1);
		return _callSuper$2(this, XAxis$1, arguments);
	}
	_inherits$2(XAxis$1, _React$Component);
	return _createClass$3(XAxis$1, [{
		key: "render",
		value: function render() {
			return /* @__PURE__ */ import_react.createElement(XAxisImpl, this.props);
		}
	}]);
}(import_react.Component);
_defineProperty$4(XAxis, "displayName", "XAxis");
_defineProperty$4(XAxis, "defaultProps", {
	allowDecimals: true,
	hide: false,
	orientation: "bottom",
	width: 0,
	height: 30,
	mirror: false,
	xAxisId: 0,
	tickCount: 5,
	type: "category",
	padding: {
		left: 0,
		right: 0
	},
	allowDataOverflow: false,
	scale: "auto",
	reversed: false,
	allowDuplicatedCategory: true
});
function _typeof$3(o) {
	"@babel/helpers - typeof";
	return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$3(o);
}
function _classCallCheck$2(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$2(target, props) {
	for (var i = 0; i < props.length; i++) {
		var descriptor = props[i];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$3(descriptor.key), descriptor);
	}
}
function _createClass$2(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$2(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$2(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _callSuper$1(t, o, e) {
	return o = _getPrototypeOf$1(o), _possibleConstructorReturn$1(t, _isNativeReflectConstruct$1() ? Reflect.construct(o, e || [], _getPrototypeOf$1(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn$1(self$1, call) {
	if (call && (_typeof$3(call) === "object" || typeof call === "function")) return call;
	else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
	return _assertThisInitialized$1(self$1);
}
function _assertThisInitialized$1(self$1) {
	if (self$1 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return self$1;
}
function _isNativeReflectConstruct$1() {
	try {
		var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
	} catch (t$1) {}
	return (_isNativeReflectConstruct$1 = function _isNativeReflectConstruct$15() {
		return !!t;
	})();
}
function _getPrototypeOf$1(o) {
	_getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf$15(o$1) {
		return o$1.__proto__ || Object.getPrototypeOf(o$1);
	};
	return _getPrototypeOf$1(o);
}
function _inherits$1(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
	subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
		value: subClass,
		writable: true,
		configurable: true
	} });
	Object.defineProperty(subClass, "prototype", { writable: false });
	if (superClass) _setPrototypeOf$1(subClass, superClass);
}
function _setPrototypeOf$1(o, p) {
	_setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf$15(o$1, p$1) {
		o$1.__proto__ = p$1;
		return o$1;
	};
	return _setPrototypeOf$1(o, p);
}
function _defineProperty$3(obj, key, value) {
	key = _toPropertyKey$3(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$3(t) {
	var i = _toPrimitive$3(t, "string");
	return "symbol" == _typeof$3(i) ? i : i + "";
}
function _toPrimitive$3(t, r) {
	if ("object" != _typeof$3(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$3(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
function _extends$1() {
	_extends$1 = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends$1.apply(this, arguments);
}
var YAxisImpl = function YAxisImpl$1(_ref) {
	var yAxisId = _ref.yAxisId;
	var width = useChartWidth();
	var height = useChartHeight();
	var axisOptions = useYAxisOrThrow(yAxisId);
	if (axisOptions == null) return null;
	return /* @__PURE__ */ import_react.createElement(CartesianAxis, _extends$1({}, axisOptions, {
		className: clsx_default("recharts-".concat(axisOptions.axisType, " ").concat(axisOptions.axisType), axisOptions.className),
		viewBox: {
			x: 0,
			y: 0,
			width,
			height
		},
		ticksGenerator: function ticksGenerator(axis) {
			return getTicksOfAxis(axis, true);
		}
	}));
};
var YAxis = /* @__PURE__ */ function(_React$Component) {
	function YAxis$1() {
		_classCallCheck$2(this, YAxis$1);
		return _callSuper$1(this, YAxis$1, arguments);
	}
	_inherits$1(YAxis$1, _React$Component);
	return _createClass$2(YAxis$1, [{
		key: "render",
		value: function render() {
			return /* @__PURE__ */ import_react.createElement(YAxisImpl, this.props);
		}
	}]);
}(import_react.Component);
_defineProperty$3(YAxis, "displayName", "YAxis");
_defineProperty$3(YAxis, "defaultProps", {
	allowDuplicatedCategory: true,
	allowDecimals: true,
	hide: false,
	orientation: "left",
	width: 60,
	height: 0,
	mirror: false,
	yAxisId: 0,
	tickCount: 5,
	type: "number",
	padding: {
		top: 0,
		bottom: 0
	},
	allowDataOverflow: false,
	scale: "auto",
	reversed: false
});
function _toConsumableArray$1(arr) {
	return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread$1();
}
function _nonIterableSpread$1() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$1(o, minLen) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
}
function _iterableToArray$1(iter) {
	if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles$1(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray$1(arr);
}
function _arrayLikeToArray$1(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
var detectReferenceElementsDomain = function detectReferenceElementsDomain$1(children, domain, axisId, axisType, specifiedTicks) {
	var lines = findAllByType(children, ReferenceLine);
	var dots = findAllByType(children, ReferenceDot);
	var elements = [].concat(_toConsumableArray$1(lines), _toConsumableArray$1(dots));
	var areas = findAllByType(children, ReferenceArea);
	var idKey = "".concat(axisType, "Id");
	var valueKey = axisType[0];
	var finalDomain = domain;
	if (elements.length) finalDomain = elements.reduce(function(result, el) {
		if (el.props[idKey] === axisId && ifOverflowMatches(el.props, "extendDomain") && isNumber(el.props[valueKey])) {
			var value = el.props[valueKey];
			return [Math.min(result[0], value), Math.max(result[1], value)];
		}
		return result;
	}, finalDomain);
	if (areas.length) {
		var key1 = "".concat(valueKey, "1");
		var key2 = "".concat(valueKey, "2");
		finalDomain = areas.reduce(function(result, el) {
			if (el.props[idKey] === axisId && ifOverflowMatches(el.props, "extendDomain") && isNumber(el.props[key1]) && isNumber(el.props[key2])) {
				var value1 = el.props[key1];
				var value2 = el.props[key2];
				return [Math.min(result[0], value1, value2), Math.max(result[1], value1, value2)];
			}
			return result;
		}, finalDomain);
	}
	if (specifiedTicks && specifiedTicks.length) finalDomain = specifiedTicks.reduce(function(result, tick) {
		if (isNumber(tick)) return [Math.min(result[0], tick), Math.max(result[1], tick)];
		return result;
	}, finalDomain);
	return finalDomain;
};
var eventCenter = new (/* @__PURE__ */ __toESM((/* @__PURE__ */ __commonJSMin(((exports, module) => {
	var has = Object.prototype.hasOwnProperty, prefix = "~";
	function Events() {}
	if (Object.create) {
		Events.prototype = Object.create(null);
		if (!new Events().__proto__) prefix = false;
	}
	function EE(fn, context, once) {
		this.fn = fn;
		this.context = context;
		this.once = once || false;
	}
	function addListener(emitter, event, fn, context, once) {
		if (typeof fn !== "function") throw new TypeError("The listener must be a function");
		var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
		if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
		else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
		else emitter._events[evt] = [emitter._events[evt], listener];
		return emitter;
	}
	function clearEvent(emitter, evt) {
		if (--emitter._eventsCount === 0) emitter._events = new Events();
		else delete emitter._events[evt];
	}
	function EventEmitter$1() {
		this._events = new Events();
		this._eventsCount = 0;
	}
	EventEmitter$1.prototype.eventNames = function eventNames() {
		var names = [], events, name;
		if (this._eventsCount === 0) return names;
		for (name in events = this._events) if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
		if (Object.getOwnPropertySymbols) return names.concat(Object.getOwnPropertySymbols(events));
		return names;
	};
	EventEmitter$1.prototype.listeners = function listeners(event) {
		var evt = prefix ? prefix + event : event, handlers = this._events[evt];
		if (!handlers) return [];
		if (handlers.fn) return [handlers.fn];
		for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) ee[i] = handlers[i].fn;
		return ee;
	};
	EventEmitter$1.prototype.listenerCount = function listenerCount(event) {
		var evt = prefix ? prefix + event : event, listeners = this._events[evt];
		if (!listeners) return 0;
		if (listeners.fn) return 1;
		return listeners.length;
	};
	EventEmitter$1.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
		var evt = prefix ? prefix + event : event;
		if (!this._events[evt]) return false;
		var listeners = this._events[evt], len = arguments.length, args, i;
		if (listeners.fn) {
			if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
			switch (len) {
				case 1: return listeners.fn.call(listeners.context), true;
				case 2: return listeners.fn.call(listeners.context, a1), true;
				case 3: return listeners.fn.call(listeners.context, a1, a2), true;
				case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
				case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
				case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
			}
			for (i = 1, args = new Array(len - 1); i < len; i++) args[i - 1] = arguments[i];
			listeners.fn.apply(listeners.context, args);
		} else {
			var length = listeners.length, j;
			for (i = 0; i < length; i++) {
				if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
				switch (len) {
					case 1:
						listeners[i].fn.call(listeners[i].context);
						break;
					case 2:
						listeners[i].fn.call(listeners[i].context, a1);
						break;
					case 3:
						listeners[i].fn.call(listeners[i].context, a1, a2);
						break;
					case 4:
						listeners[i].fn.call(listeners[i].context, a1, a2, a3);
						break;
					default:
						if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) args[j - 1] = arguments[j];
						listeners[i].fn.apply(listeners[i].context, args);
				}
			}
		}
		return true;
	};
	EventEmitter$1.prototype.on = function on(event, fn, context) {
		return addListener(this, event, fn, context, false);
	};
	EventEmitter$1.prototype.once = function once(event, fn, context) {
		return addListener(this, event, fn, context, true);
	};
	EventEmitter$1.prototype.removeListener = function removeListener(event, fn, context, once) {
		var evt = prefix ? prefix + event : event;
		if (!this._events[evt]) return this;
		if (!fn) {
			clearEvent(this, evt);
			return this;
		}
		var listeners = this._events[evt];
		if (listeners.fn) {
			if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) clearEvent(this, evt);
		} else {
			for (var i = 0, events = [], length = listeners.length; i < length; i++) if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) events.push(listeners[i]);
			if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
			else clearEvent(this, evt);
		}
		return this;
	};
	EventEmitter$1.prototype.removeAllListeners = function removeAllListeners(event) {
		var evt;
		if (event) {
			evt = prefix ? prefix + event : event;
			if (this._events[evt]) clearEvent(this, evt);
		} else {
			this._events = new Events();
			this._eventsCount = 0;
		}
		return this;
	};
	EventEmitter$1.prototype.off = EventEmitter$1.prototype.removeListener;
	EventEmitter$1.prototype.addListener = EventEmitter$1.prototype.on;
	EventEmitter$1.prefixed = prefix;
	EventEmitter$1.EventEmitter = EventEmitter$1;
	if ("undefined" !== typeof module) module.exports = EventEmitter$1;
})))())).default();
var SYNC_EVENT = "recharts.syncMouseEvents";
function _typeof$2(o) {
	"@babel/helpers - typeof";
	return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$2(o);
}
function _classCallCheck$1(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$1(target, props) {
	for (var i = 0; i < props.length; i++) {
		var descriptor = props[i];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey$2(descriptor.key), descriptor);
	}
}
function _createClass$1(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties$1(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _defineProperty$2(obj, key, value) {
	key = _toPropertyKey$2(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$2(t) {
	var i = _toPrimitive$2(t, "string");
	return "symbol" == _typeof$2(i) ? i : i + "";
}
function _toPrimitive$2(t, r) {
	if ("object" != _typeof$2(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$2(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
var AccessibilityManager = /* @__PURE__ */ function() {
	function AccessibilityManager$1() {
		_classCallCheck$1(this, AccessibilityManager$1);
		_defineProperty$2(this, "activeIndex", 0);
		_defineProperty$2(this, "coordinateList", []);
		_defineProperty$2(this, "layout", "horizontal");
	}
	return _createClass$1(AccessibilityManager$1, [
		{
			key: "setDetails",
			value: function setDetails(_ref) {
				var _ref2;
				var _ref$coordinateList = _ref.coordinateList, coordinateList = _ref$coordinateList === void 0 ? null : _ref$coordinateList, _ref$container = _ref.container, container = _ref$container === void 0 ? null : _ref$container, _ref$layout = _ref.layout, layout = _ref$layout === void 0 ? null : _ref$layout, _ref$offset = _ref.offset, offset = _ref$offset === void 0 ? null : _ref$offset, _ref$mouseHandlerCall = _ref.mouseHandlerCallback, mouseHandlerCallback = _ref$mouseHandlerCall === void 0 ? null : _ref$mouseHandlerCall;
				this.coordinateList = (_ref2 = coordinateList !== null && coordinateList !== void 0 ? coordinateList : this.coordinateList) !== null && _ref2 !== void 0 ? _ref2 : [];
				this.container = container !== null && container !== void 0 ? container : this.container;
				this.layout = layout !== null && layout !== void 0 ? layout : this.layout;
				this.offset = offset !== null && offset !== void 0 ? offset : this.offset;
				this.mouseHandlerCallback = mouseHandlerCallback !== null && mouseHandlerCallback !== void 0 ? mouseHandlerCallback : this.mouseHandlerCallback;
				this.activeIndex = Math.min(Math.max(this.activeIndex, 0), this.coordinateList.length - 1);
			}
		},
		{
			key: "focus",
			value: function focus() {
				this.spoofMouse();
			}
		},
		{
			key: "keyboardEvent",
			value: function keyboardEvent(e) {
				if (this.coordinateList.length === 0) return;
				switch (e.key) {
					case "ArrowRight":
						if (this.layout !== "horizontal") return;
						this.activeIndex = Math.min(this.activeIndex + 1, this.coordinateList.length - 1);
						this.spoofMouse();
						break;
					case "ArrowLeft":
						if (this.layout !== "horizontal") return;
						this.activeIndex = Math.max(this.activeIndex - 1, 0);
						this.spoofMouse();
						break;
					default: break;
				}
			}
		},
		{
			key: "setIndex",
			value: function setIndex(newIndex) {
				this.activeIndex = newIndex;
			}
		},
		{
			key: "spoofMouse",
			value: function spoofMouse() {
				var _window, _window2;
				if (this.layout !== "horizontal") return;
				if (this.coordinateList.length === 0) return;
				var _this$container$getBo = this.container.getBoundingClientRect(), x$1 = _this$container$getBo.x, y$1 = _this$container$getBo.y, height = _this$container$getBo.height;
				var coordinate = this.coordinateList[this.activeIndex].coordinate;
				var scrollOffsetX = ((_window = window) === null || _window === void 0 ? void 0 : _window.scrollX) || 0;
				var scrollOffsetY = ((_window2 = window) === null || _window2 === void 0 ? void 0 : _window2.scrollY) || 0;
				var pageX = x$1 + coordinate + scrollOffsetX;
				var pageY = y$1 + this.offset.top + height / 2 + scrollOffsetY;
				this.mouseHandlerCallback({
					pageX,
					pageY
				});
			}
		}
	]);
}();
function isDomainSpecifiedByUser(domain, allowDataOverflow, axisType) {
	if (axisType === "number" && allowDataOverflow === true && Array.isArray(domain)) {
		var domainStart = domain === null || domain === void 0 ? void 0 : domain[0];
		var domainEnd = domain === null || domain === void 0 ? void 0 : domain[1];
		if (!!domainStart && !!domainEnd && isNumber(domainStart) && isNumber(domainEnd)) return true;
	}
	return false;
}
function getCursorRectangle(layout, activeCoordinate, offset, tooltipAxisBandSize) {
	var halfSize = tooltipAxisBandSize / 2;
	return {
		stroke: "none",
		fill: "#ccc",
		x: layout === "horizontal" ? activeCoordinate.x - halfSize : offset.left + .5,
		y: layout === "horizontal" ? offset.top + .5 : activeCoordinate.y - halfSize,
		width: layout === "horizontal" ? tooltipAxisBandSize : offset.width - 1,
		height: layout === "horizontal" ? offset.height - 1 : tooltipAxisBandSize
	};
}
function getRadialCursorPoints(activeCoordinate) {
	var cx = activeCoordinate.cx, cy = activeCoordinate.cy, radius = activeCoordinate.radius, startAngle = activeCoordinate.startAngle, endAngle = activeCoordinate.endAngle;
	return {
		points: [polarToCartesian(cx, cy, radius, startAngle), polarToCartesian(cx, cy, radius, endAngle)],
		cx,
		cy,
		radius,
		startAngle,
		endAngle
	};
}
function getCursorPoints(layout, activeCoordinate, offset) {
	var x1, y1, x2, y2;
	if (layout === "horizontal") {
		x1 = activeCoordinate.x;
		x2 = x1;
		y1 = offset.top;
		y2 = offset.top + offset.height;
	} else if (layout === "vertical") {
		y1 = activeCoordinate.y;
		y2 = y1;
		x1 = offset.left;
		x2 = offset.left + offset.width;
	} else if (activeCoordinate.cx != null && activeCoordinate.cy != null) if (layout === "centric") {
		var cx = activeCoordinate.cx, cy = activeCoordinate.cy, innerRadius = activeCoordinate.innerRadius, outerRadius = activeCoordinate.outerRadius, angle = activeCoordinate.angle;
		var innerPoint = polarToCartesian(cx, cy, innerRadius, angle);
		var outerPoint = polarToCartesian(cx, cy, outerRadius, angle);
		x1 = innerPoint.x;
		y1 = innerPoint.y;
		x2 = outerPoint.x;
		y2 = outerPoint.y;
	} else return getRadialCursorPoints(activeCoordinate);
	return [{
		x: x1,
		y: y1
	}, {
		x: x2,
		y: y2
	}];
}
function _typeof$1(o) {
	"@babel/helpers - typeof";
	return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof$1(o);
}
function ownKeys$1(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$1(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys$1(Object(t), !0).forEach(function(r$1) {
			_defineProperty$1(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}
function _defineProperty$1(obj, key, value) {
	key = _toPropertyKey$1(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey$1(t) {
	var i = _toPrimitive$1(t, "string");
	return "symbol" == _typeof$1(i) ? i : i + "";
}
function _toPrimitive$1(t, r) {
	if ("object" != _typeof$1(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof$1(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
function Cursor(props) {
	var _element$props$cursor, _defaultProps;
	var element = props.element, tooltipEventType = props.tooltipEventType, isActive = props.isActive, activeCoordinate = props.activeCoordinate, activePayload = props.activePayload, offset = props.offset, activeTooltipIndex = props.activeTooltipIndex, tooltipAxisBandSize = props.tooltipAxisBandSize, layout = props.layout, chartName = props.chartName;
	var elementPropsCursor = (_element$props$cursor = element.props.cursor) !== null && _element$props$cursor !== void 0 ? _element$props$cursor : (_defaultProps = element.type.defaultProps) === null || _defaultProps === void 0 ? void 0 : _defaultProps.cursor;
	if (!element || !elementPropsCursor || !isActive || !activeCoordinate || chartName !== "ScatterChart" && tooltipEventType !== "axis") return null;
	var restProps;
	var cursorComp = Curve;
	if (chartName === "ScatterChart") {
		restProps = activeCoordinate;
		cursorComp = Cross;
	} else if (chartName === "BarChart") {
		restProps = getCursorRectangle(layout, activeCoordinate, offset, tooltipAxisBandSize);
		cursorComp = Rectangle;
	} else if (layout === "radial") {
		var _getRadialCursorPoint = getRadialCursorPoints(activeCoordinate), cx = _getRadialCursorPoint.cx, cy = _getRadialCursorPoint.cy, radius = _getRadialCursorPoint.radius;
		restProps = {
			cx,
			cy,
			startAngle: _getRadialCursorPoint.startAngle,
			endAngle: _getRadialCursorPoint.endAngle,
			innerRadius: radius,
			outerRadius: radius
		};
		cursorComp = Sector;
	} else {
		restProps = { points: getCursorPoints(layout, activeCoordinate, offset) };
		cursorComp = Curve;
	}
	var cursorProps = _objectSpread$1(_objectSpread$1(_objectSpread$1(_objectSpread$1({
		stroke: "#ccc",
		pointerEvents: "none"
	}, offset), restProps), filterProps(elementPropsCursor, false)), {}, {
		payload: activePayload,
		payloadIndex: activeTooltipIndex,
		className: clsx_default("recharts-tooltip-cursor", elementPropsCursor.className)
	});
	return /* @__PURE__ */ (0, import_react.isValidElement)(elementPropsCursor) ? /* @__PURE__ */ (0, import_react.cloneElement)(elementPropsCursor, cursorProps) : /* @__PURE__ */ (0, import_react.createElement)(cursorComp, cursorProps);
}
var import_isNil = /* @__PURE__ */ __toESM(require_isNil());
var import_isFunction = /* @__PURE__ */ __toESM(require_isFunction());
var import_range = /* @__PURE__ */ __toESM(require_range());
var import_get = /* @__PURE__ */ __toESM(require_get());
var import_sortBy = /* @__PURE__ */ __toESM(require_sortBy());
var import_throttle = /* @__PURE__ */ __toESM(require_throttle());
var _excluded = ["item"], _excluded2 = [
	"children",
	"className",
	"width",
	"height",
	"style",
	"compact",
	"title",
	"desc"
];
function _typeof(o) {
	"@babel/helpers - typeof";
	return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
		return typeof o$1;
	} : function(o$1) {
		return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
	}, _typeof(o);
}
function _extends() {
	_extends = Object.assign ? Object.assign.bind() : function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
		}
		return target;
	};
	return _extends.apply(this, arguments);
}
function _slicedToArray(arr, i) {
	return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArrayLimit(r, l) {
	var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
	if (null != t) {
		var e, n, i, u, a$1 = [], f = !0, o = !1;
		try {
			if (i = (t = t.call(r)).next, 0 === l) {
				if (Object(t) !== t) return;
				f = !1;
			} else for (; !(f = (e = i.call(t)).done) && (a$1.push(e.value), a$1.length !== l); f = !0);
		} catch (r$1) {
			o = !0, n = r$1;
		} finally {
			try {
				if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
			} finally {
				if (o) throw n;
			}
		}
		return a$1;
	}
}
function _arrayWithHoles(arr) {
	if (Array.isArray(arr)) return arr;
}
function _objectWithoutProperties(source, excluded) {
	if (source == null) return {};
	var target = _objectWithoutPropertiesLoose(source, excluded);
	var key, i;
	if (Object.getOwnPropertySymbols) {
		var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
		for (i = 0; i < sourceSymbolKeys.length; i++) {
			key = sourceSymbolKeys[i];
			if (excluded.indexOf(key) >= 0) continue;
			if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
			target[key] = source[key];
		}
	}
	return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
	if (source == null) return {};
	var target = {};
	for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) {
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}
	return target;
}
function _classCallCheck(instance, Constructor) {
	if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
	for (var i = 0; i < props.length; i++) {
		var descriptor = props[i];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
	}
}
function _createClass(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties(Constructor, staticProps);
	Object.defineProperty(Constructor, "prototype", { writable: false });
	return Constructor;
}
function _callSuper(t, o, e) {
	return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn(self$1, call) {
	if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
	else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
	return _assertThisInitialized(self$1);
}
function _assertThisInitialized(self$1) {
	if (self$1 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return self$1;
}
function _isNativeReflectConstruct() {
	try {
		var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
	} catch (t$1) {}
	return (_isNativeReflectConstruct = function _isNativeReflectConstruct$15() {
		return !!t;
	})();
}
function _getPrototypeOf(o) {
	_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf$15(o$1) {
		return o$1.__proto__ || Object.getPrototypeOf(o$1);
	};
	return _getPrototypeOf(o);
}
function _inherits(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
	subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: {
		value: subClass,
		writable: true,
		configurable: true
	} });
	Object.defineProperty(subClass, "prototype", { writable: false });
	if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
	_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf$15(o$1, p$1) {
		o$1.__proto__ = p$1;
		return o$1;
	};
	return _setPrototypeOf(o, p);
}
function _toConsumableArray(arr) {
	return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
	if (!o) return;
	if (typeof o === "string") return _arrayLikeToArray(o, minLen);
	var n = Object.prototype.toString.call(o).slice(8, -1);
	if (n === "Object" && o.constructor) n = o.constructor.name;
	if (n === "Map" || n === "Set") return Array.from(o);
	if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _iterableToArray(iter) {
	if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _arrayLikeToArray(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
	return arr2;
}
function ownKeys(e, r) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r && (o = o.filter(function(r$1) {
			return Object.getOwnPropertyDescriptor(e, r$1).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread(e) {
	for (var r = 1; r < arguments.length; r++) {
		var t = null != arguments[r] ? arguments[r] : {};
		r % 2 ? ownKeys(Object(t), !0).forEach(function(r$1) {
			_defineProperty(e, r$1, t[r$1]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r$1) {
			Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));
		});
	}
	return e;
}
function _defineProperty(obj, key, value) {
	key = _toPropertyKey(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey(t) {
	var i = _toPrimitive(t, "string");
	return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
	if ("object" != _typeof(t) || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r || "default");
		if ("object" != _typeof(i)) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r ? String : Number)(t);
}
var ORIENT_MAP = {
	xAxis: ["bottom", "top"],
	yAxis: ["left", "right"]
};
var FULL_WIDTH_AND_HEIGHT = {
	width: "100%",
	height: "100%"
};
var originCoordinate = {
	x: 0,
	y: 0
};
function renderAsIs(element) {
	return element;
}
var calculateTooltipPos = function calculateTooltipPos$1(rangeObj, layout) {
	if (layout === "horizontal") return rangeObj.x;
	if (layout === "vertical") return rangeObj.y;
	if (layout === "centric") return rangeObj.angle;
	return rangeObj.radius;
};
var getActiveCoordinate = function getActiveCoordinate$1(layout, tooltipTicks, activeIndex, rangeObj) {
	var entry = tooltipTicks.find(function(tick) {
		return tick && tick.index === activeIndex;
	});
	if (entry) {
		if (layout === "horizontal") return {
			x: entry.coordinate,
			y: rangeObj.y
		};
		if (layout === "vertical") return {
			x: rangeObj.x,
			y: entry.coordinate
		};
		if (layout === "centric") {
			var _angle = entry.coordinate;
			var _radius = rangeObj.radius;
			return _objectSpread(_objectSpread(_objectSpread({}, rangeObj), polarToCartesian(rangeObj.cx, rangeObj.cy, _radius, _angle)), {}, {
				angle: _angle,
				radius: _radius
			});
		}
		var radius = entry.coordinate;
		var angle = rangeObj.angle;
		return _objectSpread(_objectSpread(_objectSpread({}, rangeObj), polarToCartesian(rangeObj.cx, rangeObj.cy, radius, angle)), {}, {
			angle,
			radius
		});
	}
	return originCoordinate;
};
var getDisplayedData = function getDisplayedData$1(data, _ref) {
	var graphicalItems = _ref.graphicalItems, dataStartIndex = _ref.dataStartIndex, dataEndIndex = _ref.dataEndIndex;
	var itemsData = (graphicalItems !== null && graphicalItems !== void 0 ? graphicalItems : []).reduce(function(result, child) {
		var itemData = child.props.data;
		if (itemData && itemData.length) return [].concat(_toConsumableArray(result), _toConsumableArray(itemData));
		return result;
	}, []);
	if (itemsData.length > 0) return itemsData;
	if (data && data.length && isNumber(dataStartIndex) && isNumber(dataEndIndex)) return data.slice(dataStartIndex, dataEndIndex + 1);
	return [];
};
function getDefaultDomainByAxisType(axisType) {
	return axisType === "number" ? [0, "auto"] : void 0;
}
var getTooltipContent = function getTooltipContent$1(state, chartData, activeIndex, activeLabel) {
	var graphicalItems = state.graphicalItems, tooltipAxis = state.tooltipAxis;
	var displayedData = getDisplayedData(chartData, state);
	if (activeIndex < 0 || !graphicalItems || !graphicalItems.length || activeIndex >= displayedData.length) return null;
	return graphicalItems.reduce(function(result, child) {
		var _child$props$data;
		var data = (_child$props$data = child.props.data) !== null && _child$props$data !== void 0 ? _child$props$data : chartData;
		if (data && state.dataStartIndex + state.dataEndIndex !== 0 && state.dataEndIndex - state.dataStartIndex >= activeIndex) data = data.slice(state.dataStartIndex, state.dataEndIndex + 1);
		var payload;
		if (tooltipAxis.dataKey && !tooltipAxis.allowDuplicatedCategory) payload = findEntryInArray(data === void 0 ? displayedData : data, tooltipAxis.dataKey, activeLabel);
		else payload = data && data[activeIndex] || displayedData[activeIndex];
		if (!payload) return result;
		return [].concat(_toConsumableArray(result), [getTooltipItem(child, payload)]);
	}, []);
};
var getTooltipData = function getTooltipData$1(state, chartData, layout, rangeObj) {
	var rangeData = rangeObj || {
		x: state.chartX,
		y: state.chartY
	};
	var pos = calculateTooltipPos(rangeData, layout);
	var ticks$1 = state.orderedTooltipTicks, axis = state.tooltipAxis, tooltipTicks = state.tooltipTicks;
	var activeIndex = calculateActiveTickIndex(pos, ticks$1, tooltipTicks, axis);
	if (activeIndex >= 0 && tooltipTicks) {
		var activeLabel = tooltipTicks[activeIndex] && tooltipTicks[activeIndex].value;
		return {
			activeTooltipIndex: activeIndex,
			activeLabel,
			activePayload: getTooltipContent(state, chartData, activeIndex, activeLabel),
			activeCoordinate: getActiveCoordinate(layout, ticks$1, activeIndex, rangeData)
		};
	}
	return null;
};
var getAxisMapByAxes = function getAxisMapByAxes$1(props, _ref2) {
	var axes = _ref2.axes, graphicalItems = _ref2.graphicalItems, axisType = _ref2.axisType, axisIdKey = _ref2.axisIdKey, stackGroups = _ref2.stackGroups, dataStartIndex = _ref2.dataStartIndex, dataEndIndex = _ref2.dataEndIndex;
	var layout = props.layout, children = props.children, stackOffset = props.stackOffset;
	var isCategorical = isCategoricalAxis(layout, axisType);
	return axes.reduce(function(result, child) {
		var _childProps$domain2;
		var childProps = child.type.defaultProps !== void 0 ? _objectSpread(_objectSpread({}, child.type.defaultProps), child.props) : child.props;
		var type = childProps.type, dataKey = childProps.dataKey, allowDataOverflow = childProps.allowDataOverflow, allowDuplicatedCategory = childProps.allowDuplicatedCategory, scale = childProps.scale, ticks$1 = childProps.ticks, includeHidden = childProps.includeHidden;
		var axisId = childProps[axisIdKey];
		if (result[axisId]) return result;
		var displayedData = getDisplayedData(props.data, {
			graphicalItems: graphicalItems.filter(function(item) {
				var _defaultProps;
				return (axisIdKey in item.props ? item.props[axisIdKey] : (_defaultProps = item.type.defaultProps) === null || _defaultProps === void 0 ? void 0 : _defaultProps[axisIdKey]) === axisId;
			}),
			dataStartIndex,
			dataEndIndex
		});
		var len = displayedData.length;
		var domain, duplicateDomain, categoricalDomain;
		if (isDomainSpecifiedByUser(childProps.domain, allowDataOverflow, type)) {
			domain = parseSpecifiedDomain(childProps.domain, null, allowDataOverflow);
			if (isCategorical && (type === "number" || scale !== "auto")) categoricalDomain = getDomainOfDataByKey(displayedData, dataKey, "category");
		}
		var defaultDomain = getDefaultDomainByAxisType(type);
		if (!domain || domain.length === 0) {
			var _childProps$domain;
			var childDomain = (_childProps$domain = childProps.domain) !== null && _childProps$domain !== void 0 ? _childProps$domain : defaultDomain;
			if (dataKey) {
				domain = getDomainOfDataByKey(displayedData, dataKey, type);
				if (type === "category" && isCategorical) {
					var duplicate = hasDuplicate(domain);
					if (allowDuplicatedCategory && duplicate) {
						duplicateDomain = domain;
						domain = (0, import_range.default)(0, len);
					} else if (!allowDuplicatedCategory) domain = parseDomainOfCategoryAxis(childDomain, domain, child).reduce(function(finalDomain, entry) {
						return finalDomain.indexOf(entry) >= 0 ? finalDomain : [].concat(_toConsumableArray(finalDomain), [entry]);
					}, []);
				} else if (type === "category") if (!allowDuplicatedCategory) domain = parseDomainOfCategoryAxis(childDomain, domain, child).reduce(function(finalDomain, entry) {
					return finalDomain.indexOf(entry) >= 0 || entry === "" || (0, import_isNil.default)(entry) ? finalDomain : [].concat(_toConsumableArray(finalDomain), [entry]);
				}, []);
				else domain = domain.filter(function(entry) {
					return entry !== "" && !(0, import_isNil.default)(entry);
				});
				else if (type === "number") {
					var errorBarsDomain = parseErrorBarsOfAxis(displayedData, graphicalItems.filter(function(item) {
						var _defaultProps2, _defaultProps3;
						var itemAxisId = axisIdKey in item.props ? item.props[axisIdKey] : (_defaultProps2 = item.type.defaultProps) === null || _defaultProps2 === void 0 ? void 0 : _defaultProps2[axisIdKey];
						var itemHide = "hide" in item.props ? item.props.hide : (_defaultProps3 = item.type.defaultProps) === null || _defaultProps3 === void 0 ? void 0 : _defaultProps3.hide;
						return itemAxisId === axisId && (includeHidden || !itemHide);
					}), dataKey, axisType, layout);
					if (errorBarsDomain) domain = errorBarsDomain;
				}
				if (isCategorical && (type === "number" || scale !== "auto")) categoricalDomain = getDomainOfDataByKey(displayedData, dataKey, "category");
			} else if (isCategorical) domain = (0, import_range.default)(0, len);
			else if (stackGroups && stackGroups[axisId] && stackGroups[axisId].hasStack && type === "number") domain = stackOffset === "expand" ? [0, 1] : getDomainOfStackGroups(stackGroups[axisId].stackGroups, dataStartIndex, dataEndIndex);
			else domain = getDomainOfItemsWithSameAxis(displayedData, graphicalItems.filter(function(item) {
				var itemAxisId = axisIdKey in item.props ? item.props[axisIdKey] : item.type.defaultProps[axisIdKey];
				var itemHide = "hide" in item.props ? item.props.hide : item.type.defaultProps.hide;
				return itemAxisId === axisId && (includeHidden || !itemHide);
			}), type, layout, true);
			if (type === "number") {
				domain = detectReferenceElementsDomain(children, domain, axisId, axisType, ticks$1);
				if (childDomain) domain = parseSpecifiedDomain(childDomain, domain, allowDataOverflow);
			} else if (type === "category" && childDomain) {
				var axisDomain = childDomain;
				if (domain.every(function(entry) {
					return axisDomain.indexOf(entry) >= 0;
				})) domain = axisDomain;
			}
		}
		return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, _objectSpread(_objectSpread({}, childProps), {}, {
			axisType,
			domain,
			categoricalDomain,
			duplicateDomain,
			originalDomain: (_childProps$domain2 = childProps.domain) !== null && _childProps$domain2 !== void 0 ? _childProps$domain2 : defaultDomain,
			isCategorical,
			layout
		})));
	}, {});
};
var getAxisMapByItems = function getAxisMapByItems$1(props, _ref3) {
	var graphicalItems = _ref3.graphicalItems, Axis = _ref3.Axis, axisType = _ref3.axisType, axisIdKey = _ref3.axisIdKey, stackGroups = _ref3.stackGroups, dataStartIndex = _ref3.dataStartIndex, dataEndIndex = _ref3.dataEndIndex;
	var layout = props.layout, children = props.children;
	var displayedData = getDisplayedData(props.data, {
		graphicalItems,
		dataStartIndex,
		dataEndIndex
	});
	var len = displayedData.length;
	var isCategorical = isCategoricalAxis(layout, axisType);
	var index = -1;
	return graphicalItems.reduce(function(result, child) {
		var axisId = (child.type.defaultProps !== void 0 ? _objectSpread(_objectSpread({}, child.type.defaultProps), child.props) : child.props)[axisIdKey];
		var originalDomain = getDefaultDomainByAxisType("number");
		if (!result[axisId]) {
			index++;
			var domain;
			if (isCategorical) domain = (0, import_range.default)(0, len);
			else if (stackGroups && stackGroups[axisId] && stackGroups[axisId].hasStack) {
				domain = getDomainOfStackGroups(stackGroups[axisId].stackGroups, dataStartIndex, dataEndIndex);
				domain = detectReferenceElementsDomain(children, domain, axisId, axisType);
			} else {
				domain = parseSpecifiedDomain(originalDomain, getDomainOfItemsWithSameAxis(displayedData, graphicalItems.filter(function(item) {
					var _defaultProps4, _defaultProps5;
					var itemAxisId = axisIdKey in item.props ? item.props[axisIdKey] : (_defaultProps4 = item.type.defaultProps) === null || _defaultProps4 === void 0 ? void 0 : _defaultProps4[axisIdKey];
					var itemHide = "hide" in item.props ? item.props.hide : (_defaultProps5 = item.type.defaultProps) === null || _defaultProps5 === void 0 ? void 0 : _defaultProps5.hide;
					return itemAxisId === axisId && !itemHide;
				}), "number", layout), Axis.defaultProps.allowDataOverflow);
				domain = detectReferenceElementsDomain(children, domain, axisId, axisType);
			}
			return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, _objectSpread(_objectSpread({ axisType }, Axis.defaultProps), {}, {
				hide: true,
				orientation: (0, import_get.default)(ORIENT_MAP, "".concat(axisType, ".").concat(index % 2), null),
				domain,
				originalDomain,
				isCategorical,
				layout
			})));
		}
		return result;
	}, {});
};
var getAxisMap = function getAxisMap$1(props, _ref4) {
	var _ref4$axisType = _ref4.axisType, axisType = _ref4$axisType === void 0 ? "xAxis" : _ref4$axisType, AxisComp = _ref4.AxisComp, graphicalItems = _ref4.graphicalItems, stackGroups = _ref4.stackGroups, dataStartIndex = _ref4.dataStartIndex, dataEndIndex = _ref4.dataEndIndex;
	var children = props.children;
	var axisIdKey = "".concat(axisType, "Id");
	var axes = findAllByType(children, AxisComp);
	var axisMap = {};
	if (axes && axes.length) axisMap = getAxisMapByAxes(props, {
		axes,
		graphicalItems,
		axisType,
		axisIdKey,
		stackGroups,
		dataStartIndex,
		dataEndIndex
	});
	else if (graphicalItems && graphicalItems.length) axisMap = getAxisMapByItems(props, {
		Axis: AxisComp,
		graphicalItems,
		axisType,
		axisIdKey,
		stackGroups,
		dataStartIndex,
		dataEndIndex
	});
	return axisMap;
};
var tooltipTicksGenerator = function tooltipTicksGenerator$1(axisMap) {
	var axis = getAnyElementOfObject(axisMap);
	var tooltipTicks = getTicksOfAxis(axis, false, true);
	return {
		tooltipTicks,
		orderedTooltipTicks: (0, import_sortBy.default)(tooltipTicks, function(o) {
			return o.coordinate;
		}),
		tooltipAxis: axis,
		tooltipAxisBandSize: getBandSizeOfAxis(axis, tooltipTicks)
	};
};
var createDefaultState = function createDefaultState$1(props) {
	var children = props.children, defaultShowTooltip = props.defaultShowTooltip;
	var brushItem = findChildByType(children, Brush);
	var startIndex = 0;
	var endIndex = 0;
	if (props.data && props.data.length !== 0) endIndex = props.data.length - 1;
	if (brushItem && brushItem.props) {
		if (brushItem.props.startIndex >= 0) startIndex = brushItem.props.startIndex;
		if (brushItem.props.endIndex >= 0) endIndex = brushItem.props.endIndex;
	}
	return {
		chartX: 0,
		chartY: 0,
		dataStartIndex: startIndex,
		dataEndIndex: endIndex,
		activeTooltipIndex: -1,
		isTooltipActive: Boolean(defaultShowTooltip)
	};
};
var hasGraphicalBarItem = function hasGraphicalBarItem$1(graphicalItems) {
	if (!graphicalItems || !graphicalItems.length) return false;
	return graphicalItems.some(function(item) {
		var name = getDisplayName(item && item.type);
		return name && name.indexOf("Bar") >= 0;
	});
};
var getAxisNameByLayout = function getAxisNameByLayout$1(layout) {
	if (layout === "horizontal") return {
		numericAxisName: "yAxis",
		cateAxisName: "xAxis"
	};
	if (layout === "vertical") return {
		numericAxisName: "xAxis",
		cateAxisName: "yAxis"
	};
	if (layout === "centric") return {
		numericAxisName: "radiusAxis",
		cateAxisName: "angleAxis"
	};
	return {
		numericAxisName: "angleAxis",
		cateAxisName: "radiusAxis"
	};
};
var calculateOffset = function calculateOffset$1(_ref5, prevLegendBBox) {
	var props = _ref5.props, graphicalItems = _ref5.graphicalItems, _ref5$xAxisMap = _ref5.xAxisMap, xAxisMap = _ref5$xAxisMap === void 0 ? {} : _ref5$xAxisMap, _ref5$yAxisMap = _ref5.yAxisMap, yAxisMap = _ref5$yAxisMap === void 0 ? {} : _ref5$yAxisMap;
	var width = props.width, height = props.height, children = props.children;
	var margin = props.margin || {};
	var brushItem = findChildByType(children, Brush);
	var legendItem = findChildByType(children, Legend);
	var offsetH = Object.keys(yAxisMap).reduce(function(result, id) {
		var entry = yAxisMap[id];
		var orientation = entry.orientation;
		if (!entry.mirror && !entry.hide) return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, orientation, result[orientation] + entry.width));
		return result;
	}, {
		left: margin.left || 0,
		right: margin.right || 0
	});
	var offset = _objectSpread(_objectSpread({}, Object.keys(xAxisMap).reduce(function(result, id) {
		var entry = xAxisMap[id];
		var orientation = entry.orientation;
		if (!entry.mirror && !entry.hide) return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, orientation, (0, import_get.default)(result, "".concat(orientation)) + entry.height));
		return result;
	}, {
		top: margin.top || 0,
		bottom: margin.bottom || 0
	})), offsetH);
	var brushBottom = offset.bottom;
	if (brushItem) offset.bottom += brushItem.props.height || Brush.defaultProps.height;
	if (legendItem && prevLegendBBox) offset = appendOffsetOfLegend(offset, graphicalItems, props, prevLegendBBox);
	var offsetWidth = width - offset.left - offset.right;
	var offsetHeight = height - offset.top - offset.bottom;
	return _objectSpread(_objectSpread({ brushBottom }, offset), {}, {
		width: Math.max(offsetWidth, 0),
		height: Math.max(offsetHeight, 0)
	});
};
var getCartesianAxisSize = function getCartesianAxisSize$1(axisObj, axisName) {
	if (axisName === "xAxis") return axisObj[axisName].width;
	if (axisName === "yAxis") return axisObj[axisName].height;
};
var BarChart = function generateCategoricalChart$1(_ref6) {
	var chartName = _ref6.chartName, GraphicalChild = _ref6.GraphicalChild, _ref6$defaultTooltipE = _ref6.defaultTooltipEventType, defaultTooltipEventType = _ref6$defaultTooltipE === void 0 ? "axis" : _ref6$defaultTooltipE, _ref6$validateTooltip = _ref6.validateTooltipEventTypes, validateTooltipEventTypes = _ref6$validateTooltip === void 0 ? ["axis"] : _ref6$validateTooltip, axisComponents = _ref6.axisComponents, legendContent = _ref6.legendContent, formatAxisMap$1 = _ref6.formatAxisMap, defaultProps$4 = _ref6.defaultProps;
	var getFormatItems = function getFormatItems$1(props, currentState) {
		var graphicalItems = currentState.graphicalItems, stackGroups = currentState.stackGroups, offset = currentState.offset, updateId = currentState.updateId, dataStartIndex = currentState.dataStartIndex, dataEndIndex = currentState.dataEndIndex;
		var barSize = props.barSize, layout = props.layout, barGap = props.barGap, barCategoryGap = props.barCategoryGap, globalMaxBarSize = props.maxBarSize;
		var _getAxisNameByLayout = getAxisNameByLayout(layout), numericAxisName = _getAxisNameByLayout.numericAxisName, cateAxisName = _getAxisNameByLayout.cateAxisName;
		var hasBar = hasGraphicalBarItem(graphicalItems);
		var formattedItems = [];
		graphicalItems.forEach(function(item, index) {
			var displayedData = getDisplayedData(props.data, {
				graphicalItems: [item],
				dataStartIndex,
				dataEndIndex
			});
			var itemProps = item.type.defaultProps !== void 0 ? _objectSpread(_objectSpread({}, item.type.defaultProps), item.props) : item.props;
			var dataKey = itemProps.dataKey, childMaxBarSize = itemProps.maxBarSize;
			var numericAxisId = itemProps["".concat(numericAxisName, "Id")];
			var cateAxisId = itemProps["".concat(cateAxisName, "Id")];
			var axisObj = axisComponents.reduce(function(result, entry) {
				var _item$type$displayNam, _item$type;
				var axisMap = currentState["".concat(entry.axisType, "Map")];
				var id = itemProps["".concat(entry.axisType, "Id")];
				!(axisMap && axisMap[id] || entry.axisType === "zAxis") && invariant(false, "Specifying a(n) ".concat(entry.axisType, "Id requires a corresponding ").concat(entry.axisType, "Id on the targeted graphical component ").concat((_item$type$displayNam = item === null || item === void 0 || (_item$type = item.type) === null || _item$type === void 0 ? void 0 : _item$type.displayName) !== null && _item$type$displayNam !== void 0 ? _item$type$displayNam : ""));
				var axis = axisMap[id];
				return _objectSpread(_objectSpread({}, result), {}, _defineProperty(_defineProperty({}, entry.axisType, axis), "".concat(entry.axisType, "Ticks"), getTicksOfAxis(axis)));
			}, {});
			var cateAxis = axisObj[cateAxisName];
			var cateTicks = axisObj["".concat(cateAxisName, "Ticks")];
			var stackedData = stackGroups && stackGroups[numericAxisId] && stackGroups[numericAxisId].hasStack && getStackedDataOfItem(item, stackGroups[numericAxisId].stackGroups);
			var itemIsBar = getDisplayName(item.type).indexOf("Bar") >= 0;
			var bandSize = getBandSizeOfAxis(cateAxis, cateTicks);
			var barPosition = [];
			var sizeList = hasBar && getBarSizeList({
				barSize,
				stackGroups,
				totalSize: getCartesianAxisSize(axisObj, cateAxisName)
			});
			if (itemIsBar) {
				var _ref7, _getBandSizeOfAxis;
				var maxBarSize = (0, import_isNil.default)(childMaxBarSize) ? globalMaxBarSize : childMaxBarSize;
				var barBandSize = (_ref7 = (_getBandSizeOfAxis = getBandSizeOfAxis(cateAxis, cateTicks, true)) !== null && _getBandSizeOfAxis !== void 0 ? _getBandSizeOfAxis : maxBarSize) !== null && _ref7 !== void 0 ? _ref7 : 0;
				barPosition = getBarPosition({
					barGap,
					barCategoryGap,
					bandSize: barBandSize !== bandSize ? barBandSize : bandSize,
					sizeList: sizeList[cateAxisId],
					maxBarSize
				});
				if (barBandSize !== bandSize) barPosition = barPosition.map(function(pos) {
					return _objectSpread(_objectSpread({}, pos), {}, { position: _objectSpread(_objectSpread({}, pos.position), {}, { offset: pos.position.offset - barBandSize / 2 }) });
				});
			}
			var composedFn = item && item.type && item.type.getComposedData;
			if (composedFn) formattedItems.push({
				props: _objectSpread(_objectSpread({}, composedFn(_objectSpread(_objectSpread({}, axisObj), {}, {
					displayedData,
					props,
					dataKey,
					item,
					bandSize,
					barPosition,
					offset,
					stackedData,
					layout,
					dataStartIndex,
					dataEndIndex
				}))), {}, _defineProperty(_defineProperty(_defineProperty({ key: item.key || "item-".concat(index) }, numericAxisName, axisObj[numericAxisName]), cateAxisName, axisObj[cateAxisName]), "animationId", updateId)),
				childIndex: parseChildIndex(item, props.children),
				item
			});
		});
		return formattedItems;
	};
	var updateStateOfAxisMapsOffsetAndStackGroups = function updateStateOfAxisMapsOffsetAndStackGroups$1(_ref8, prevState) {
		var props = _ref8.props, dataStartIndex = _ref8.dataStartIndex, dataEndIndex = _ref8.dataEndIndex, updateId = _ref8.updateId;
		if (!validateWidthHeight({ props })) return null;
		var children = props.children, layout = props.layout, stackOffset = props.stackOffset, data = props.data, reverseStackOrder = props.reverseStackOrder;
		var _getAxisNameByLayout2 = getAxisNameByLayout(layout), numericAxisName = _getAxisNameByLayout2.numericAxisName, cateAxisName = _getAxisNameByLayout2.cateAxisName;
		var graphicalItems = findAllByType(children, GraphicalChild);
		var stackGroups = getStackGroupsByAxisId(data, graphicalItems, "".concat(numericAxisName, "Id"), "".concat(cateAxisName, "Id"), stackOffset, reverseStackOrder);
		var axisObj = axisComponents.reduce(function(result, entry) {
			var name = "".concat(entry.axisType, "Map");
			return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, name, getAxisMap(props, _objectSpread(_objectSpread({}, entry), {}, {
				graphicalItems,
				stackGroups: entry.axisType === numericAxisName && stackGroups,
				dataStartIndex,
				dataEndIndex
			}))));
		}, {});
		var offset = calculateOffset(_objectSpread(_objectSpread({}, axisObj), {}, {
			props,
			graphicalItems
		}), prevState === null || prevState === void 0 ? void 0 : prevState.legendBBox);
		Object.keys(axisObj).forEach(function(key) {
			axisObj[key] = formatAxisMap$1(props, axisObj[key], offset, key.replace("Map", ""), chartName);
		});
		var cateAxisMap = axisObj["".concat(cateAxisName, "Map")];
		var ticksObj = tooltipTicksGenerator(cateAxisMap);
		return _objectSpread(_objectSpread({
			formattedGraphicalItems: getFormatItems(props, _objectSpread(_objectSpread({}, axisObj), {}, {
				dataStartIndex,
				dataEndIndex,
				updateId,
				graphicalItems,
				stackGroups,
				offset
			})),
			graphicalItems,
			offset,
			stackGroups
		}, ticksObj), axisObj);
	};
	var CategoricalChartWrapper = /* @__PURE__ */ function(_Component) {
		function CategoricalChartWrapper$1(_props) {
			var _props$id, _props$throttleDelay;
			var _this;
			_classCallCheck(this, CategoricalChartWrapper$1);
			_this = _callSuper(this, CategoricalChartWrapper$1, [_props]);
			_defineProperty(_this, "eventEmitterSymbol", Symbol("rechartsEventEmitter"));
			_defineProperty(_this, "accessibilityManager", new AccessibilityManager());
			_defineProperty(_this, "handleLegendBBoxUpdate", function(box) {
				if (box) {
					var _this$state = _this.state, dataStartIndex = _this$state.dataStartIndex, dataEndIndex = _this$state.dataEndIndex, updateId = _this$state.updateId;
					_this.setState(_objectSpread({ legendBBox: box }, updateStateOfAxisMapsOffsetAndStackGroups({
						props: _this.props,
						dataStartIndex,
						dataEndIndex,
						updateId
					}, _objectSpread(_objectSpread({}, _this.state), {}, { legendBBox: box }))));
				}
			});
			_defineProperty(_this, "handleReceiveSyncEvent", function(cId, data, emitter) {
				if (_this.props.syncId === cId) {
					if (emitter === _this.eventEmitterSymbol && typeof _this.props.syncMethod !== "function") return;
					_this.applySyncEvent(data);
				}
			});
			_defineProperty(_this, "handleBrushChange", function(_ref9) {
				var startIndex = _ref9.startIndex, endIndex = _ref9.endIndex;
				if (startIndex !== _this.state.dataStartIndex || endIndex !== _this.state.dataEndIndex) {
					var updateId = _this.state.updateId;
					_this.setState(function() {
						return _objectSpread({
							dataStartIndex: startIndex,
							dataEndIndex: endIndex
						}, updateStateOfAxisMapsOffsetAndStackGroups({
							props: _this.props,
							dataStartIndex: startIndex,
							dataEndIndex: endIndex,
							updateId
						}, _this.state));
					});
					_this.triggerSyncEvent({
						dataStartIndex: startIndex,
						dataEndIndex: endIndex
					});
				}
			});
			_defineProperty(_this, "handleMouseEnter", function(e) {
				var mouse = _this.getMouseInfo(e);
				if (mouse) {
					var _nextState = _objectSpread(_objectSpread({}, mouse), {}, { isTooltipActive: true });
					_this.setState(_nextState);
					_this.triggerSyncEvent(_nextState);
					var onMouseEnter = _this.props.onMouseEnter;
					if ((0, import_isFunction.default)(onMouseEnter)) onMouseEnter(_nextState, e);
				}
			});
			_defineProperty(_this, "triggeredAfterMouseMove", function(e) {
				var mouse = _this.getMouseInfo(e);
				var nextState = mouse ? _objectSpread(_objectSpread({}, mouse), {}, { isTooltipActive: true }) : { isTooltipActive: false };
				_this.setState(nextState);
				_this.triggerSyncEvent(nextState);
				var onMouseMove = _this.props.onMouseMove;
				if ((0, import_isFunction.default)(onMouseMove)) onMouseMove(nextState, e);
			});
			_defineProperty(_this, "handleItemMouseEnter", function(el) {
				_this.setState(function() {
					return {
						isTooltipActive: true,
						activeItem: el,
						activePayload: el.tooltipPayload,
						activeCoordinate: el.tooltipPosition || {
							x: el.cx,
							y: el.cy
						}
					};
				});
			});
			_defineProperty(_this, "handleItemMouseLeave", function() {
				_this.setState(function() {
					return { isTooltipActive: false };
				});
			});
			_defineProperty(_this, "handleMouseMove", function(e) {
				e.persist();
				_this.throttleTriggeredAfterMouseMove(e);
			});
			_defineProperty(_this, "handleMouseLeave", function(e) {
				_this.throttleTriggeredAfterMouseMove.cancel();
				var nextState = { isTooltipActive: false };
				_this.setState(nextState);
				_this.triggerSyncEvent(nextState);
				var onMouseLeave = _this.props.onMouseLeave;
				if ((0, import_isFunction.default)(onMouseLeave)) onMouseLeave(nextState, e);
			});
			_defineProperty(_this, "handleOuterEvent", function(e) {
				var eventName = getReactEventByType(e);
				var event = (0, import_get.default)(_this.props, "".concat(eventName));
				if (eventName && (0, import_isFunction.default)(event)) {
					var _mouse;
					var mouse;
					if (/.*touch.*/i.test(eventName)) mouse = _this.getMouseInfo(e.changedTouches[0]);
					else mouse = _this.getMouseInfo(e);
					event((_mouse = mouse) !== null && _mouse !== void 0 ? _mouse : {}, e);
				}
			});
			_defineProperty(_this, "handleClick", function(e) {
				var mouse = _this.getMouseInfo(e);
				if (mouse) {
					var _nextState2 = _objectSpread(_objectSpread({}, mouse), {}, { isTooltipActive: true });
					_this.setState(_nextState2);
					_this.triggerSyncEvent(_nextState2);
					var onClick = _this.props.onClick;
					if ((0, import_isFunction.default)(onClick)) onClick(_nextState2, e);
				}
			});
			_defineProperty(_this, "handleMouseDown", function(e) {
				var onMouseDown = _this.props.onMouseDown;
				if ((0, import_isFunction.default)(onMouseDown)) onMouseDown(_this.getMouseInfo(e), e);
			});
			_defineProperty(_this, "handleMouseUp", function(e) {
				var onMouseUp = _this.props.onMouseUp;
				if ((0, import_isFunction.default)(onMouseUp)) onMouseUp(_this.getMouseInfo(e), e);
			});
			_defineProperty(_this, "handleTouchMove", function(e) {
				if (e.changedTouches != null && e.changedTouches.length > 0) _this.throttleTriggeredAfterMouseMove(e.changedTouches[0]);
			});
			_defineProperty(_this, "handleTouchStart", function(e) {
				if (e.changedTouches != null && e.changedTouches.length > 0) _this.handleMouseDown(e.changedTouches[0]);
			});
			_defineProperty(_this, "handleTouchEnd", function(e) {
				if (e.changedTouches != null && e.changedTouches.length > 0) _this.handleMouseUp(e.changedTouches[0]);
			});
			_defineProperty(_this, "handleDoubleClick", function(e) {
				var onDoubleClick = _this.props.onDoubleClick;
				if ((0, import_isFunction.default)(onDoubleClick)) onDoubleClick(_this.getMouseInfo(e), e);
			});
			_defineProperty(_this, "handleContextMenu", function(e) {
				var onContextMenu = _this.props.onContextMenu;
				if ((0, import_isFunction.default)(onContextMenu)) onContextMenu(_this.getMouseInfo(e), e);
			});
			_defineProperty(_this, "triggerSyncEvent", function(data) {
				if (_this.props.syncId !== void 0) eventCenter.emit(SYNC_EVENT, _this.props.syncId, data, _this.eventEmitterSymbol);
			});
			_defineProperty(_this, "applySyncEvent", function(data) {
				var _this$props = _this.props, layout = _this$props.layout, syncMethod = _this$props.syncMethod;
				var updateId = _this.state.updateId;
				var dataStartIndex = data.dataStartIndex, dataEndIndex = data.dataEndIndex;
				if (data.dataStartIndex !== void 0 || data.dataEndIndex !== void 0) _this.setState(_objectSpread({
					dataStartIndex,
					dataEndIndex
				}, updateStateOfAxisMapsOffsetAndStackGroups({
					props: _this.props,
					dataStartIndex,
					dataEndIndex,
					updateId
				}, _this.state)));
				else if (data.activeTooltipIndex !== void 0) {
					var chartX = data.chartX, chartY = data.chartY;
					var activeTooltipIndex = data.activeTooltipIndex;
					var _this$state2 = _this.state, offset = _this$state2.offset, tooltipTicks = _this$state2.tooltipTicks;
					if (!offset) return;
					if (typeof syncMethod === "function") activeTooltipIndex = syncMethod(tooltipTicks, data);
					else if (syncMethod === "value") {
						activeTooltipIndex = -1;
						for (var i = 0; i < tooltipTicks.length; i++) if (tooltipTicks[i].value === data.activeLabel) {
							activeTooltipIndex = i;
							break;
						}
					}
					var viewBox = _objectSpread(_objectSpread({}, offset), {}, {
						x: offset.left,
						y: offset.top
					});
					var validateChartX = Math.min(chartX, viewBox.x + viewBox.width);
					var validateChartY = Math.min(chartY, viewBox.y + viewBox.height);
					var activeLabel = tooltipTicks[activeTooltipIndex] && tooltipTicks[activeTooltipIndex].value;
					var activePayload = getTooltipContent(_this.state, _this.props.data, activeTooltipIndex);
					var activeCoordinate = tooltipTicks[activeTooltipIndex] ? {
						x: layout === "horizontal" ? tooltipTicks[activeTooltipIndex].coordinate : validateChartX,
						y: layout === "horizontal" ? validateChartY : tooltipTicks[activeTooltipIndex].coordinate
					} : originCoordinate;
					_this.setState(_objectSpread(_objectSpread({}, data), {}, {
						activeLabel,
						activeCoordinate,
						activePayload,
						activeTooltipIndex
					}));
				} else _this.setState(data);
			});
			_defineProperty(_this, "renderCursor", function(element) {
				var _element$props$active;
				var _this$state3 = _this.state, isTooltipActive = _this$state3.isTooltipActive, activeCoordinate = _this$state3.activeCoordinate, activePayload = _this$state3.activePayload, offset = _this$state3.offset, activeTooltipIndex = _this$state3.activeTooltipIndex, tooltipAxisBandSize = _this$state3.tooltipAxisBandSize;
				var tooltipEventType = _this.getTooltipEventType();
				var isActive = (_element$props$active = element.props.active) !== null && _element$props$active !== void 0 ? _element$props$active : isTooltipActive;
				var layout = _this.props.layout;
				var key = element.key || "_recharts-cursor";
				return /* @__PURE__ */ import_react.createElement(Cursor, {
					key,
					activeCoordinate,
					activePayload,
					activeTooltipIndex,
					chartName,
					element,
					isActive,
					layout,
					offset,
					tooltipAxisBandSize,
					tooltipEventType
				});
			});
			_defineProperty(_this, "renderPolarAxis", function(element, displayName, index) {
				var axisType = (0, import_get.default)(element, "type.axisType");
				var axisMap = (0, import_get.default)(_this.state, "".concat(axisType, "Map"));
				var elementDefaultProps = element.type.defaultProps;
				var elementProps = elementDefaultProps !== void 0 ? _objectSpread(_objectSpread({}, elementDefaultProps), element.props) : element.props;
				var axisOption = axisMap && axisMap[elementProps["".concat(axisType, "Id")]];
				return /* @__PURE__ */ (0, import_react.cloneElement)(element, _objectSpread(_objectSpread({}, axisOption), {}, {
					className: clsx_default(axisType, axisOption.className),
					key: element.key || "".concat(displayName, "-").concat(index),
					ticks: getTicksOfAxis(axisOption, true)
				}));
			});
			_defineProperty(_this, "renderPolarGrid", function(element) {
				var _element$props = element.props, radialLines = _element$props.radialLines, polarAngles = _element$props.polarAngles, polarRadius = _element$props.polarRadius;
				var _this$state4 = _this.state, radiusAxisMap = _this$state4.radiusAxisMap, angleAxisMap = _this$state4.angleAxisMap;
				var radiusAxis = getAnyElementOfObject(radiusAxisMap);
				var angleAxis = getAnyElementOfObject(angleAxisMap);
				var cx = angleAxis.cx, cy = angleAxis.cy, innerRadius = angleAxis.innerRadius, outerRadius = angleAxis.outerRadius;
				return /* @__PURE__ */ (0, import_react.cloneElement)(element, {
					polarAngles: Array.isArray(polarAngles) ? polarAngles : getTicksOfAxis(angleAxis, true).map(function(entry) {
						return entry.coordinate;
					}),
					polarRadius: Array.isArray(polarRadius) ? polarRadius : getTicksOfAxis(radiusAxis, true).map(function(entry) {
						return entry.coordinate;
					}),
					cx,
					cy,
					innerRadius,
					outerRadius,
					key: element.key || "polar-grid",
					radialLines
				});
			});
			_defineProperty(_this, "renderLegend", function() {
				var formattedGraphicalItems = _this.state.formattedGraphicalItems;
				var _this$props2 = _this.props, children = _this$props2.children, width = _this$props2.width, height = _this$props2.height;
				var margin = _this.props.margin || {};
				var props = getLegendProps({
					children,
					formattedGraphicalItems,
					legendWidth: width - (margin.left || 0) - (margin.right || 0),
					legendContent
				});
				if (!props) return null;
				var item = props.item;
				return /* @__PURE__ */ (0, import_react.cloneElement)(item, _objectSpread(_objectSpread({}, _objectWithoutProperties(props, _excluded)), {}, {
					chartWidth: width,
					chartHeight: height,
					margin,
					onBBoxUpdate: _this.handleLegendBBoxUpdate
				}));
			});
			_defineProperty(_this, "renderTooltip", function() {
				var _tooltipItem$props$ac;
				var _this$props3 = _this.props, children = _this$props3.children, accessibilityLayer = _this$props3.accessibilityLayer;
				var tooltipItem = findChildByType(children, Tooltip);
				if (!tooltipItem) return null;
				var _this$state5 = _this.state, isTooltipActive = _this$state5.isTooltipActive, activeCoordinate = _this$state5.activeCoordinate, activePayload = _this$state5.activePayload, activeLabel = _this$state5.activeLabel, offset = _this$state5.offset;
				var isActive = (_tooltipItem$props$ac = tooltipItem.props.active) !== null && _tooltipItem$props$ac !== void 0 ? _tooltipItem$props$ac : isTooltipActive;
				return /* @__PURE__ */ (0, import_react.cloneElement)(tooltipItem, {
					viewBox: _objectSpread(_objectSpread({}, offset), {}, {
						x: offset.left,
						y: offset.top
					}),
					active: isActive,
					label: activeLabel,
					payload: isActive ? activePayload : [],
					coordinate: activeCoordinate,
					accessibilityLayer
				});
			});
			_defineProperty(_this, "renderBrush", function(element) {
				var _this$props4 = _this.props, margin = _this$props4.margin, data = _this$props4.data;
				var _this$state6 = _this.state, offset = _this$state6.offset, dataStartIndex = _this$state6.dataStartIndex, dataEndIndex = _this$state6.dataEndIndex, updateId = _this$state6.updateId;
				return /* @__PURE__ */ (0, import_react.cloneElement)(element, {
					key: element.key || "_recharts-brush",
					onChange: combineEventHandlers(_this.handleBrushChange, element.props.onChange),
					data,
					x: isNumber(element.props.x) ? element.props.x : offset.left,
					y: isNumber(element.props.y) ? element.props.y : offset.top + offset.height + offset.brushBottom - (margin.bottom || 0),
					width: isNumber(element.props.width) ? element.props.width : offset.width,
					startIndex: dataStartIndex,
					endIndex: dataEndIndex,
					updateId: "brush-".concat(updateId)
				});
			});
			_defineProperty(_this, "renderReferenceElement", function(element, displayName, index) {
				if (!element) return null;
				var clipPathId = _this.clipPathId;
				var _this$state7 = _this.state, xAxisMap = _this$state7.xAxisMap, yAxisMap = _this$state7.yAxisMap, offset = _this$state7.offset;
				var elementDefaultProps = element.type.defaultProps || {};
				var _element$props2 = element.props, _element$props2$xAxis = _element$props2.xAxisId, xAxisId = _element$props2$xAxis === void 0 ? elementDefaultProps.xAxisId : _element$props2$xAxis, _element$props2$yAxis = _element$props2.yAxisId, yAxisId = _element$props2$yAxis === void 0 ? elementDefaultProps.yAxisId : _element$props2$yAxis;
				return /* @__PURE__ */ (0, import_react.cloneElement)(element, {
					key: element.key || "".concat(displayName, "-").concat(index),
					xAxis: xAxisMap[xAxisId],
					yAxis: yAxisMap[yAxisId],
					viewBox: {
						x: offset.left,
						y: offset.top,
						width: offset.width,
						height: offset.height
					},
					clipPathId
				});
			});
			_defineProperty(_this, "renderActivePoints", function(_ref10) {
				var item = _ref10.item, activePoint = _ref10.activePoint, basePoint = _ref10.basePoint, childIndex = _ref10.childIndex, isRange = _ref10.isRange;
				var result = [];
				var key = item.props.key;
				var itemItemProps = item.item.type.defaultProps !== void 0 ? _objectSpread(_objectSpread({}, item.item.type.defaultProps), item.item.props) : item.item.props;
				var activeDot = itemItemProps.activeDot, dataKey = itemItemProps.dataKey;
				var dotProps = _objectSpread(_objectSpread({
					index: childIndex,
					dataKey,
					cx: activePoint.x,
					cy: activePoint.y,
					r: 4,
					fill: getMainColorOfGraphicItem(item.item),
					strokeWidth: 2,
					stroke: "#fff",
					payload: activePoint.payload,
					value: activePoint.value
				}, filterProps(activeDot, false)), adaptEventHandlers(activeDot));
				result.push(CategoricalChartWrapper$1.renderActiveDot(activeDot, dotProps, "".concat(key, "-activePoint-").concat(childIndex)));
				if (basePoint) result.push(CategoricalChartWrapper$1.renderActiveDot(activeDot, _objectSpread(_objectSpread({}, dotProps), {}, {
					cx: basePoint.x,
					cy: basePoint.y
				}), "".concat(key, "-basePoint-").concat(childIndex)));
				else if (isRange) result.push(null);
				return result;
			});
			_defineProperty(_this, "renderGraphicChild", function(element, displayName, index) {
				var item = _this.filterFormatItem(element, displayName, index);
				if (!item) return null;
				var tooltipEventType = _this.getTooltipEventType();
				var _this$state8 = _this.state, isTooltipActive = _this$state8.isTooltipActive, tooltipAxis = _this$state8.tooltipAxis, activeTooltipIndex = _this$state8.activeTooltipIndex, activeLabel = _this$state8.activeLabel;
				var children = _this.props.children;
				var tooltipItem = findChildByType(children, Tooltip);
				var _item$props = item.props, points = _item$props.points, isRange = _item$props.isRange, baseLine = _item$props.baseLine;
				var itemItemProps = item.item.type.defaultProps !== void 0 ? _objectSpread(_objectSpread({}, item.item.type.defaultProps), item.item.props) : item.item.props;
				var activeDot = itemItemProps.activeDot, hide = itemItemProps.hide, activeBar = itemItemProps.activeBar, activeShape = itemItemProps.activeShape;
				var hasActive = Boolean(!hide && isTooltipActive && tooltipItem && (activeDot || activeBar || activeShape));
				var itemEvents = {};
				if (tooltipEventType !== "axis" && tooltipItem && tooltipItem.props.trigger === "click") itemEvents = { onClick: combineEventHandlers(_this.handleItemMouseEnter, element.props.onClick) };
				else if (tooltipEventType !== "axis") itemEvents = {
					onMouseLeave: combineEventHandlers(_this.handleItemMouseLeave, element.props.onMouseLeave),
					onMouseEnter: combineEventHandlers(_this.handleItemMouseEnter, element.props.onMouseEnter)
				};
				var graphicalItem = /* @__PURE__ */ (0, import_react.cloneElement)(element, _objectSpread(_objectSpread({}, item.props), itemEvents));
				function findWithPayload(entry) {
					return typeof tooltipAxis.dataKey === "function" ? tooltipAxis.dataKey(entry.payload) : null;
				}
				if (hasActive) if (activeTooltipIndex >= 0) {
					var activePoint, basePoint;
					if (tooltipAxis.dataKey && !tooltipAxis.allowDuplicatedCategory) {
						var specifiedKey = typeof tooltipAxis.dataKey === "function" ? findWithPayload : "payload.".concat(tooltipAxis.dataKey.toString());
						activePoint = findEntryInArray(points, specifiedKey, activeLabel);
						basePoint = isRange && baseLine && findEntryInArray(baseLine, specifiedKey, activeLabel);
					} else {
						activePoint = points === null || points === void 0 ? void 0 : points[activeTooltipIndex];
						basePoint = isRange && baseLine && baseLine[activeTooltipIndex];
					}
					if (activeShape || activeBar) {
						var activeIndex = element.props.activeIndex !== void 0 ? element.props.activeIndex : activeTooltipIndex;
						return [
							/* @__PURE__ */ (0, import_react.cloneElement)(element, _objectSpread(_objectSpread(_objectSpread({}, item.props), itemEvents), {}, { activeIndex })),
							null,
							null
						];
					}
					if (!(0, import_isNil.default)(activePoint)) return [graphicalItem].concat(_toConsumableArray(_this.renderActivePoints({
						item,
						activePoint,
						basePoint,
						childIndex: activeTooltipIndex,
						isRange
					})));
				} else {
					var _this$getItemByXY;
					var _ref11$graphicalItem = ((_this$getItemByXY = _this.getItemByXY(_this.state.activeCoordinate)) !== null && _this$getItemByXY !== void 0 ? _this$getItemByXY : { graphicalItem }).graphicalItem, _ref11$graphicalItem$ = _ref11$graphicalItem.item, xyItem = _ref11$graphicalItem$ === void 0 ? element : _ref11$graphicalItem$, childIndex = _ref11$graphicalItem.childIndex;
					return [
						/* @__PURE__ */ (0, import_react.cloneElement)(xyItem, _objectSpread(_objectSpread(_objectSpread({}, item.props), itemEvents), {}, { activeIndex: childIndex })),
						null,
						null
					];
				}
				if (isRange) return [
					graphicalItem,
					null,
					null
				];
				return [graphicalItem, null];
			});
			_defineProperty(_this, "renderCustomized", function(element, displayName, index) {
				return /* @__PURE__ */ (0, import_react.cloneElement)(element, _objectSpread(_objectSpread({ key: "recharts-customized-".concat(index) }, _this.props), _this.state));
			});
			_defineProperty(_this, "renderMap", {
				CartesianGrid: {
					handler: renderAsIs,
					once: true
				},
				ReferenceArea: { handler: _this.renderReferenceElement },
				ReferenceLine: { handler: renderAsIs },
				ReferenceDot: { handler: _this.renderReferenceElement },
				XAxis: { handler: renderAsIs },
				YAxis: { handler: renderAsIs },
				Brush: {
					handler: _this.renderBrush,
					once: true
				},
				Bar: { handler: _this.renderGraphicChild },
				Line: { handler: _this.renderGraphicChild },
				Area: { handler: _this.renderGraphicChild },
				Radar: { handler: _this.renderGraphicChild },
				RadialBar: { handler: _this.renderGraphicChild },
				Scatter: { handler: _this.renderGraphicChild },
				Pie: { handler: _this.renderGraphicChild },
				Funnel: { handler: _this.renderGraphicChild },
				Tooltip: {
					handler: _this.renderCursor,
					once: true
				},
				PolarGrid: {
					handler: _this.renderPolarGrid,
					once: true
				},
				PolarAngleAxis: { handler: _this.renderPolarAxis },
				PolarRadiusAxis: { handler: _this.renderPolarAxis },
				Customized: { handler: _this.renderCustomized }
			});
			_this.clipPathId = "".concat((_props$id = _props.id) !== null && _props$id !== void 0 ? _props$id : uniqueId("recharts"), "-clip");
			_this.throttleTriggeredAfterMouseMove = (0, import_throttle.default)(_this.triggeredAfterMouseMove, (_props$throttleDelay = _props.throttleDelay) !== null && _props$throttleDelay !== void 0 ? _props$throttleDelay : 1e3 / 60);
			_this.state = {};
			return _this;
		}
		_inherits(CategoricalChartWrapper$1, _Component);
		return _createClass(CategoricalChartWrapper$1, [
			{
				key: "componentDidMount",
				value: function componentDidMount() {
					var _this$props$margin$le, _this$props$margin$to;
					this.addListener();
					this.accessibilityManager.setDetails({
						container: this.container,
						offset: {
							left: (_this$props$margin$le = this.props.margin.left) !== null && _this$props$margin$le !== void 0 ? _this$props$margin$le : 0,
							top: (_this$props$margin$to = this.props.margin.top) !== null && _this$props$margin$to !== void 0 ? _this$props$margin$to : 0
						},
						coordinateList: this.state.tooltipTicks,
						mouseHandlerCallback: this.triggeredAfterMouseMove,
						layout: this.props.layout
					});
					this.displayDefaultTooltip();
				}
			},
			{
				key: "displayDefaultTooltip",
				value: function displayDefaultTooltip() {
					var _this$props5 = this.props, children = _this$props5.children, data = _this$props5.data, height = _this$props5.height, layout = _this$props5.layout;
					var tooltipElem = findChildByType(children, Tooltip);
					if (!tooltipElem) return;
					var defaultIndex = tooltipElem.props.defaultIndex;
					if (typeof defaultIndex !== "number" || defaultIndex < 0 || defaultIndex > this.state.tooltipTicks.length - 1) return;
					var activeLabel = this.state.tooltipTicks[defaultIndex] && this.state.tooltipTicks[defaultIndex].value;
					var activePayload = getTooltipContent(this.state, data, defaultIndex, activeLabel);
					var independentAxisCoord = this.state.tooltipTicks[defaultIndex].coordinate;
					var dependentAxisCoord = (this.state.offset.top + height) / 2;
					var activeCoordinate = layout === "horizontal" ? {
						x: independentAxisCoord,
						y: dependentAxisCoord
					} : {
						y: independentAxisCoord,
						x: dependentAxisCoord
					};
					var scatterPlotElement = this.state.formattedGraphicalItems.find(function(_ref12) {
						return _ref12.item.type.name === "Scatter";
					});
					if (scatterPlotElement) {
						activeCoordinate = _objectSpread(_objectSpread({}, activeCoordinate), scatterPlotElement.props.points[defaultIndex].tooltipPosition);
						activePayload = scatterPlotElement.props.points[defaultIndex].tooltipPayload;
					}
					var nextState = {
						activeTooltipIndex: defaultIndex,
						isTooltipActive: true,
						activeLabel,
						activePayload,
						activeCoordinate
					};
					this.setState(nextState);
					this.renderCursor(tooltipElem);
					this.accessibilityManager.setIndex(defaultIndex);
				}
			},
			{
				key: "getSnapshotBeforeUpdate",
				value: function getSnapshotBeforeUpdate(prevProps, prevState) {
					if (!this.props.accessibilityLayer) return null;
					if (this.state.tooltipTicks !== prevState.tooltipTicks) this.accessibilityManager.setDetails({ coordinateList: this.state.tooltipTicks });
					if (this.props.layout !== prevProps.layout) this.accessibilityManager.setDetails({ layout: this.props.layout });
					if (this.props.margin !== prevProps.margin) {
						var _this$props$margin$le2, _this$props$margin$to2;
						this.accessibilityManager.setDetails({ offset: {
							left: (_this$props$margin$le2 = this.props.margin.left) !== null && _this$props$margin$le2 !== void 0 ? _this$props$margin$le2 : 0,
							top: (_this$props$margin$to2 = this.props.margin.top) !== null && _this$props$margin$to2 !== void 0 ? _this$props$margin$to2 : 0
						} });
					}
					return null;
				}
			},
			{
				key: "componentDidUpdate",
				value: function componentDidUpdate(prevProps) {
					if (!isChildrenEqual([findChildByType(prevProps.children, Tooltip)], [findChildByType(this.props.children, Tooltip)])) this.displayDefaultTooltip();
				}
			},
			{
				key: "componentWillUnmount",
				value: function componentWillUnmount() {
					this.removeListener();
					this.throttleTriggeredAfterMouseMove.cancel();
				}
			},
			{
				key: "getTooltipEventType",
				value: function getTooltipEventType() {
					var tooltipItem = findChildByType(this.props.children, Tooltip);
					if (tooltipItem && typeof tooltipItem.props.shared === "boolean") {
						var eventType = tooltipItem.props.shared ? "axis" : "item";
						return validateTooltipEventTypes.indexOf(eventType) >= 0 ? eventType : defaultTooltipEventType;
					}
					return defaultTooltipEventType;
				}
			},
			{
				key: "getMouseInfo",
				value: function getMouseInfo(event) {
					if (!this.container) return null;
					var element = this.container;
					var boundingRect = element.getBoundingClientRect();
					var containerOffset = getOffset(boundingRect);
					var e = {
						chartX: Math.round(event.pageX - containerOffset.left),
						chartY: Math.round(event.pageY - containerOffset.top)
					};
					var scale = boundingRect.width / element.offsetWidth || 1;
					var rangeObj = this.inRange(e.chartX, e.chartY, scale);
					if (!rangeObj) return null;
					var _this$state9 = this.state, xAxisMap = _this$state9.xAxisMap, yAxisMap = _this$state9.yAxisMap;
					var tooltipEventType = this.getTooltipEventType();
					var toolTipData = getTooltipData(this.state, this.props.data, this.props.layout, rangeObj);
					if (tooltipEventType !== "axis" && xAxisMap && yAxisMap) {
						var xScale = getAnyElementOfObject(xAxisMap).scale;
						var yScale = getAnyElementOfObject(yAxisMap).scale;
						var xValue = xScale && xScale.invert ? xScale.invert(e.chartX) : null;
						var yValue = yScale && yScale.invert ? yScale.invert(e.chartY) : null;
						return _objectSpread(_objectSpread({}, e), {}, {
							xValue,
							yValue
						}, toolTipData);
					}
					if (toolTipData) return _objectSpread(_objectSpread({}, e), toolTipData);
					return null;
				}
			},
			{
				key: "inRange",
				value: function inRange(x$1, y$1) {
					var scale = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
					var layout = this.props.layout;
					var scaledX = x$1 / scale, scaledY = y$1 / scale;
					if (layout === "horizontal" || layout === "vertical") {
						var offset = this.state.offset;
						return scaledX >= offset.left && scaledX <= offset.left + offset.width && scaledY >= offset.top && scaledY <= offset.top + offset.height ? {
							x: scaledX,
							y: scaledY
						} : null;
					}
					var _this$state10 = this.state, angleAxisMap = _this$state10.angleAxisMap, radiusAxisMap = _this$state10.radiusAxisMap;
					if (angleAxisMap && radiusAxisMap) {
						var angleAxis = getAnyElementOfObject(angleAxisMap);
						return inRangeOfSector({
							x: scaledX,
							y: scaledY
						}, angleAxis);
					}
					return null;
				}
			},
			{
				key: "parseEventsOfWrapper",
				value: function parseEventsOfWrapper() {
					var children = this.props.children;
					var tooltipEventType = this.getTooltipEventType();
					var tooltipItem = findChildByType(children, Tooltip);
					var tooltipEvents = {};
					if (tooltipItem && tooltipEventType === "axis") if (tooltipItem.props.trigger === "click") tooltipEvents = { onClick: this.handleClick };
					else tooltipEvents = {
						onMouseEnter: this.handleMouseEnter,
						onDoubleClick: this.handleDoubleClick,
						onMouseMove: this.handleMouseMove,
						onMouseLeave: this.handleMouseLeave,
						onTouchMove: this.handleTouchMove,
						onTouchStart: this.handleTouchStart,
						onTouchEnd: this.handleTouchEnd,
						onContextMenu: this.handleContextMenu
					};
					return _objectSpread(_objectSpread({}, adaptEventHandlers(this.props, this.handleOuterEvent)), tooltipEvents);
				}
			},
			{
				key: "addListener",
				value: function addListener$1() {
					eventCenter.on(SYNC_EVENT, this.handleReceiveSyncEvent);
				}
			},
			{
				key: "removeListener",
				value: function removeListener() {
					eventCenter.removeListener(SYNC_EVENT, this.handleReceiveSyncEvent);
				}
			},
			{
				key: "filterFormatItem",
				value: function filterFormatItem(item, displayName, childIndex) {
					var formattedGraphicalItems = this.state.formattedGraphicalItems;
					for (var i = 0, len = formattedGraphicalItems.length; i < len; i++) {
						var entry = formattedGraphicalItems[i];
						if (entry.item === item || entry.props.key === item.key || displayName === getDisplayName(entry.item.type) && childIndex === entry.childIndex) return entry;
					}
					return null;
				}
			},
			{
				key: "renderClipPath",
				value: function renderClipPath() {
					var clipPathId = this.clipPathId;
					var _this$state$offset = this.state.offset, left = _this$state$offset.left, top = _this$state$offset.top, height = _this$state$offset.height, width = _this$state$offset.width;
					return /* @__PURE__ */ import_react.createElement("defs", null, /* @__PURE__ */ import_react.createElement("clipPath", { id: clipPathId }, /* @__PURE__ */ import_react.createElement("rect", {
						x: left,
						y: top,
						height,
						width
					})));
				}
			},
			{
				key: "getXScales",
				value: function getXScales() {
					var xAxisMap = this.state.xAxisMap;
					return xAxisMap ? Object.entries(xAxisMap).reduce(function(res, _ref13) {
						var _ref14 = _slicedToArray(_ref13, 2), axisId = _ref14[0], axisProps = _ref14[1];
						return _objectSpread(_objectSpread({}, res), {}, _defineProperty({}, axisId, axisProps.scale));
					}, {}) : null;
				}
			},
			{
				key: "getYScales",
				value: function getYScales() {
					var yAxisMap = this.state.yAxisMap;
					return yAxisMap ? Object.entries(yAxisMap).reduce(function(res, _ref15) {
						var _ref16 = _slicedToArray(_ref15, 2), axisId = _ref16[0], axisProps = _ref16[1];
						return _objectSpread(_objectSpread({}, res), {}, _defineProperty({}, axisId, axisProps.scale));
					}, {}) : null;
				}
			},
			{
				key: "getXScaleByAxisId",
				value: function getXScaleByAxisId(axisId) {
					var _this$state$xAxisMap;
					return (_this$state$xAxisMap = this.state.xAxisMap) === null || _this$state$xAxisMap === void 0 || (_this$state$xAxisMap = _this$state$xAxisMap[axisId]) === null || _this$state$xAxisMap === void 0 ? void 0 : _this$state$xAxisMap.scale;
				}
			},
			{
				key: "getYScaleByAxisId",
				value: function getYScaleByAxisId(axisId) {
					var _this$state$yAxisMap;
					return (_this$state$yAxisMap = this.state.yAxisMap) === null || _this$state$yAxisMap === void 0 || (_this$state$yAxisMap = _this$state$yAxisMap[axisId]) === null || _this$state$yAxisMap === void 0 ? void 0 : _this$state$yAxisMap.scale;
				}
			},
			{
				key: "getItemByXY",
				value: function getItemByXY(chartXY) {
					var _this$state11 = this.state, formattedGraphicalItems = _this$state11.formattedGraphicalItems, activeItem = _this$state11.activeItem;
					if (formattedGraphicalItems && formattedGraphicalItems.length) for (var i = 0, len = formattedGraphicalItems.length; i < len; i++) {
						var graphicalItem = formattedGraphicalItems[i];
						var props = graphicalItem.props, item = graphicalItem.item;
						var itemProps = item.type.defaultProps !== void 0 ? _objectSpread(_objectSpread({}, item.type.defaultProps), item.props) : item.props;
						var itemDisplayName = getDisplayName(item.type);
						if (itemDisplayName === "Bar") {
							var activeBarItem = (props.data || []).find(function(entry) {
								return isInRectangle(chartXY, entry);
							});
							if (activeBarItem) return {
								graphicalItem,
								payload: activeBarItem
							};
						} else if (itemDisplayName === "RadialBar") {
							var _activeBarItem = (props.data || []).find(function(entry) {
								return inRangeOfSector(chartXY, entry);
							});
							if (_activeBarItem) return {
								graphicalItem,
								payload: _activeBarItem
							};
						} else if (isFunnel(graphicalItem, activeItem) || isPie(graphicalItem, activeItem) || isScatter(graphicalItem, activeItem)) {
							var activeIndex = getActiveShapeIndexForTooltip({
								graphicalItem,
								activeTooltipItem: activeItem,
								itemData: itemProps.data
							});
							var childIndex = itemProps.activeIndex === void 0 ? activeIndex : itemProps.activeIndex;
							return {
								graphicalItem: _objectSpread(_objectSpread({}, graphicalItem), {}, { childIndex }),
								payload: isScatter(graphicalItem, activeItem) ? itemProps.data[activeIndex] : graphicalItem.props.data[activeIndex]
							};
						}
					}
					return null;
				}
			},
			{
				key: "render",
				value: function render() {
					var _this3 = this;
					if (!validateWidthHeight(this)) return null;
					var _this$props6 = this.props, children = _this$props6.children, className = _this$props6.className, width = _this$props6.width, height = _this$props6.height, style = _this$props6.style, compact = _this$props6.compact, title = _this$props6.title, desc = _this$props6.desc;
					var attrs = filterProps(_objectWithoutProperties(_this$props6, _excluded2), false);
					if (compact) return /* @__PURE__ */ import_react.createElement(ChartLayoutContextProvider, {
						state: this.state,
						width: this.props.width,
						height: this.props.height,
						clipPathId: this.clipPathId
					}, /* @__PURE__ */ import_react.createElement(Surface, _extends({}, attrs, {
						width,
						height,
						title,
						desc
					}), this.renderClipPath(), renderByOrder(children, this.renderMap)));
					if (this.props.accessibilityLayer) {
						var _this$props$tabIndex, _this$props$role;
						attrs.tabIndex = (_this$props$tabIndex = this.props.tabIndex) !== null && _this$props$tabIndex !== void 0 ? _this$props$tabIndex : 0;
						attrs.role = (_this$props$role = this.props.role) !== null && _this$props$role !== void 0 ? _this$props$role : "application";
						attrs.onKeyDown = function(e) {
							_this3.accessibilityManager.keyboardEvent(e);
						};
						attrs.onFocus = function() {
							_this3.accessibilityManager.focus();
						};
					}
					var events = this.parseEventsOfWrapper();
					return /* @__PURE__ */ import_react.createElement(ChartLayoutContextProvider, {
						state: this.state,
						width: this.props.width,
						height: this.props.height,
						clipPathId: this.clipPathId
					}, /* @__PURE__ */ import_react.createElement("div", _extends({
						className: clsx_default("recharts-wrapper", className),
						style: _objectSpread({
							position: "relative",
							cursor: "default",
							width,
							height
						}, style)
					}, events, { ref: function ref(node) {
						_this3.container = node;
					} }), /* @__PURE__ */ import_react.createElement(Surface, _extends({}, attrs, {
						width,
						height,
						title,
						desc,
						style: FULL_WIDTH_AND_HEIGHT
					}), this.renderClipPath(), renderByOrder(children, this.renderMap)), this.renderLegend(), this.renderTooltip()));
				}
			}
		]);
	}(import_react.Component);
	_defineProperty(CategoricalChartWrapper, "displayName", chartName);
	_defineProperty(CategoricalChartWrapper, "defaultProps", _objectSpread({
		layout: "horizontal",
		stackOffset: "none",
		barCategoryGap: "10%",
		barGap: 4,
		margin: {
			top: 5,
			right: 5,
			bottom: 5,
			left: 5
		},
		reverseStackOrder: false,
		syncMethod: "index"
	}, defaultProps$4));
	_defineProperty(CategoricalChartWrapper, "getDerivedStateFromProps", function(nextProps, prevState) {
		var dataKey = nextProps.dataKey, data = nextProps.data, children = nextProps.children, width = nextProps.width, height = nextProps.height, layout = nextProps.layout, stackOffset = nextProps.stackOffset, margin = nextProps.margin;
		var dataStartIndex = prevState.dataStartIndex, dataEndIndex = prevState.dataEndIndex;
		if (prevState.updateId === void 0) {
			var defaultState = createDefaultState(nextProps);
			return _objectSpread(_objectSpread(_objectSpread({}, defaultState), {}, { updateId: 0 }, updateStateOfAxisMapsOffsetAndStackGroups(_objectSpread(_objectSpread({ props: nextProps }, defaultState), {}, { updateId: 0 }), prevState)), {}, {
				prevDataKey: dataKey,
				prevData: data,
				prevWidth: width,
				prevHeight: height,
				prevLayout: layout,
				prevStackOffset: stackOffset,
				prevMargin: margin,
				prevChildren: children
			});
		}
		if (dataKey !== prevState.prevDataKey || data !== prevState.prevData || width !== prevState.prevWidth || height !== prevState.prevHeight || layout !== prevState.prevLayout || stackOffset !== prevState.prevStackOffset || !shallowEqual(margin, prevState.prevMargin)) {
			var _defaultState = createDefaultState(nextProps);
			var keepFromPrevState = {
				chartX: prevState.chartX,
				chartY: prevState.chartY,
				isTooltipActive: prevState.isTooltipActive
			};
			var updatesToState = _objectSpread(_objectSpread({}, getTooltipData(prevState, data, layout)), {}, { updateId: prevState.updateId + 1 });
			var newState = _objectSpread(_objectSpread(_objectSpread({}, _defaultState), keepFromPrevState), updatesToState);
			return _objectSpread(_objectSpread(_objectSpread({}, newState), updateStateOfAxisMapsOffsetAndStackGroups(_objectSpread({ props: nextProps }, newState), prevState)), {}, {
				prevDataKey: dataKey,
				prevData: data,
				prevWidth: width,
				prevHeight: height,
				prevLayout: layout,
				prevStackOffset: stackOffset,
				prevMargin: margin,
				prevChildren: children
			});
		}
		if (!isChildrenEqual(children, prevState.prevChildren)) {
			var _brush$props$startInd, _brush$props, _brush$props$endIndex, _brush$props2;
			var brush = findChildByType(children, Brush);
			var startIndex = brush ? (_brush$props$startInd = (_brush$props = brush.props) === null || _brush$props === void 0 ? void 0 : _brush$props.startIndex) !== null && _brush$props$startInd !== void 0 ? _brush$props$startInd : dataStartIndex : dataStartIndex;
			var endIndex = brush ? (_brush$props$endIndex = (_brush$props2 = brush.props) === null || _brush$props2 === void 0 ? void 0 : _brush$props2.endIndex) !== null && _brush$props$endIndex !== void 0 ? _brush$props$endIndex : dataEndIndex : dataEndIndex;
			var hasDifferentStartOrEndIndex = startIndex !== dataStartIndex || endIndex !== dataEndIndex;
			var newUpdateId = !(0, import_isNil.default)(data) && !hasDifferentStartOrEndIndex ? prevState.updateId : prevState.updateId + 1;
			return _objectSpread(_objectSpread({ updateId: newUpdateId }, updateStateOfAxisMapsOffsetAndStackGroups(_objectSpread(_objectSpread({ props: nextProps }, prevState), {}, {
				updateId: newUpdateId,
				dataStartIndex: startIndex,
				dataEndIndex: endIndex
			}), prevState)), {}, {
				prevChildren: children,
				dataStartIndex: startIndex,
				dataEndIndex: endIndex
			});
		}
		return null;
	});
	_defineProperty(CategoricalChartWrapper, "renderActiveDot", function(option, props, key) {
		var dot;
		if (/* @__PURE__ */ (0, import_react.isValidElement)(option)) dot = /* @__PURE__ */ (0, import_react.cloneElement)(option, props);
		else if ((0, import_isFunction.default)(option)) dot = option(props);
		else dot = /* @__PURE__ */ import_react.createElement(Dot, props);
		return /* @__PURE__ */ import_react.createElement(Layer, {
			className: "recharts-active-dot",
			key
		}, dot);
	});
	var CategoricalChart = /* @__PURE__ */ (0, import_react.forwardRef)(function CategoricalChart$1(props, ref) {
		return /* @__PURE__ */ import_react.createElement(CategoricalChartWrapper, _extends({}, props, { ref }));
	});
	CategoricalChart.displayName = CategoricalChartWrapper.displayName;
	return CategoricalChart;
}({
	chartName: "BarChart",
	GraphicalChild: Bar,
	defaultTooltipEventType: "axis",
	validateTooltipEventTypes: ["axis", "item"],
	axisComponents: [{
		axisType: "xAxis",
		AxisComp: XAxis
	}, {
		axisType: "yAxis",
		AxisComp: YAxis
	}],
	formatAxisMap
});
var import_jsx_runtime = /* @__PURE__ */ __toESM(require_jsx_runtime(), 1);
var THEMES = {
	light: "",
	dark: ".dark"
};
var ChartContext = import_react.createContext(null);
function useChart() {
	const context = import_react.useContext(ChartContext);
	if (!context) throw new Error("useChart must be used within a <ChartContainer />");
	return context;
}
var ChartContainer = import_react.forwardRef(({ id, className, children, config, ...props }, ref) => {
	const uniqueId$1 = import_react.useId();
	const chartId = `chart-${id || uniqueId$1.replace(/:/g, "")}`;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ChartContext.Provider, {
		value: { config },
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
			"data-chart": chartId,
			ref,
			className: cn("flex w-full h-full aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none", className),
			...props,
			children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(ChartStyle, {
				id: chartId,
				config
			}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ResponsiveContainer, { children })]
		})
	});
});
ChartContainer.displayName = "Chart";
var ChartStyle = ({ id, config }) => {
	const colorConfig = Object.entries(config).filter(([, itemConfig]) => itemConfig.theme || itemConfig.color);
	if (!colorConfig.length) return null;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("style", { dangerouslySetInnerHTML: { __html: Object.entries(THEMES).map(([theme, prefix$2]) => `
${prefix$2} [data-chart="${id}"] {
${colorConfig.map(([key, itemConfig]) => {
		const color$1 = itemConfig.theme?.[theme] || itemConfig.color;
		return color$1 ? `  --color-${key}: ${color$1};` : null;
	}).filter(Boolean).join("\n")}
}
`).join("\n") } });
};
var ChartTooltip = Tooltip;
var ChartTooltipContent = import_react.forwardRef(({ active, payload, className, indicator = "dot", hideLabel = false, hideIndicator = false, label, labelFormatter, labelClassName, formatter, color: color$1, nameKey, labelKey }, ref) => {
	const { config } = useChart();
	const tooltipLabel = import_react.useMemo(() => {
		if (hideLabel || !payload?.length) return null;
		const [item] = payload;
		const itemConfig = getPayloadConfigFromPayload(config, item, `${labelKey || item?.dataKey || item?.name || "value"}`);
		const value = !labelKey && typeof label === "string" ? config[label]?.label || label : itemConfig?.label;
		if (labelFormatter) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			className: cn("font-medium", labelClassName),
			children: labelFormatter(value, payload)
		});
		if (!value) return null;
		return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			className: cn("font-medium", labelClassName),
			children: value
		});
	}, [
		label,
		labelFormatter,
		payload,
		hideLabel,
		labelClassName,
		config,
		labelKey
	]);
	if (!active || !payload?.length) return null;
	const nestLabel = payload.length === 1 && indicator !== "dot";
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		ref,
		className: cn("grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl", className),
		children: [!nestLabel ? tooltipLabel : null, /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			className: "grid gap-1.5",
			children: payload.map((item, index) => {
				const itemConfig = getPayloadConfigFromPayload(config, item, `${nameKey || item.name || item.dataKey || "value"}`);
				const indicatorColor = color$1 || item.payload.fill || item.color;
				return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					className: cn("flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground", indicator === "dot" && "items-center"),
					children: formatter && item?.value !== void 0 && item.name ? formatter(item.value, item.name, item, index, item.payload) : /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [itemConfig?.icon ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(itemConfig.icon, {}) : !hideIndicator && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
						className: cn("shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]", {
							"h-2.5 w-2.5": indicator === "dot",
							"w-1": indicator === "line",
							"w-0 border-[1.5px] border-dashed bg-transparent": indicator === "dashed",
							"my-0.5": nestLabel && indicator === "dashed"
						}),
						style: {
							"--color-bg": indicatorColor,
							"--color-border": indicatorColor
						}
					}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
						className: cn("flex flex-1 justify-between leading-none", nestLabel ? "items-end" : "items-center"),
						children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
							className: "grid gap-1.5",
							children: [nestLabel ? tooltipLabel : null, /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
								className: "text-muted-foreground",
								children: itemConfig?.label || item.name
							})]
						}), item.value && /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
							className: "font-mono font-medium tabular-nums text-foreground",
							children: item.value.toLocaleString()
						})]
					})] })
				}, item.dataKey);
			})
		})]
	});
});
ChartTooltipContent.displayName = "ChartTooltip";
var ChartLegendContent = import_react.forwardRef(({ className, hideIcon = false, payload, verticalAlign = "bottom", nameKey }, ref) => {
	const { config } = useChart();
	if (!payload?.length) return null;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		ref,
		className: cn("flex items-center justify-center gap-4", verticalAlign === "top" ? "pb-3" : "pt-3", className),
		children: payload.map((item) => {
			const itemConfig = getPayloadConfigFromPayload(config, item, `${nameKey || item.dataKey || "value"}`);
			return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				className: cn("flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground"),
				children: [itemConfig?.icon && !hideIcon ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(itemConfig.icon, {}) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					className: "h-2 w-2 shrink-0 rounded-[2px]",
					style: { backgroundColor: item.color }
				}), itemConfig?.label]
			}, item.value);
		})
	});
});
ChartLegendContent.displayName = "ChartLegend";
function getPayloadConfigFromPayload(config, payload, key) {
	if (typeof payload !== "object" || payload === null) return;
	const payloadPayload = "payload" in payload && typeof payload.payload === "object" && payload.payload !== null ? payload.payload : void 0;
	let configLabelKey = key;
	if (key in payload && typeof payload[key] === "string") configLabelKey = payload[key];
	else if (payloadPayload && key in payloadPayload && typeof payloadPayload[key] === "string") configLabelKey = payloadPayload[key];
	return configLabelKey in config ? config[configLabelKey] : config[key];
}
function DashboardOverview() {
	const [stats, setStats] = (0, import_react.useState)({
		books: 0,
		tracks: 0,
		playlists: 0,
		submissions: 0,
		uniqueVisitors: 0
	});
	const [recentActivity, setRecentActivity] = (0, import_react.useState)([]);
	const [loading, setLoading] = (0, import_react.useState)(true);
	(0, import_react.useEffect)(() => {
		const fetchData = async () => {
			const { count: booksCount } = await supabase.from("books").select("*", {
				count: "exact",
				head: true
			});
			const { count: tracksCount } = await supabase.from("music_tracks").select("*", {
				count: "exact",
				head: true
			});
			const { count: playlistsCount } = await supabase.from("playlists").select("*", {
				count: "exact",
				head: true
			});
			const { count: submissionsCount } = await supabase.from("contact_submissions").select("*", {
				count: "exact",
				head: true
			});
			const { count: activityCount } = await supabase.from("audit_logs").select("*", {
				count: "exact",
				head: true
			});
			setStats({
				books: booksCount || 0,
				tracks: tracksCount || 0,
				playlists: playlistsCount || 0,
				submissions: submissionsCount || 0,
				uniqueVisitors: activityCount || 0
			});
			const { data: recentSubmissions } = await supabase.from("contact_submissions").select("id, name, created_at, message").order("created_at", { ascending: false }).limit(5);
			const { data: recentLogs } = await supabase.from("audit_logs").select("id, action, table_name, created_at").order("created_at", { ascending: false }).limit(5);
			setRecentActivity([...(recentSubmissions || []).map((s$1) => ({
				...s$1,
				type: "submission",
				label: `Message from ${s$1.name}`
			})), ...(recentLogs || []).map((l) => ({
				...l,
				type: "log",
				label: `${l.action} on ${l.table_name}`
			}))].sort((a$1, b) => new Date(b.created_at).getTime() - new Date(a$1.created_at).getTime()).slice(0, 5));
			setLoading(false);
		};
		fetchData();
	}, []);
	const chartData = [
		{
			name: "Books",
			count: stats.books
		},
		{
			name: "Music",
			count: stats.tracks
		},
		{
			name: "Playlists",
			count: stats.playlists
		},
		{
			name: "Messages",
			count: stats.submissions
		}
	];
	const chartConfig = { count: {
		label: "Total Items",
		color: "hsl(var(--primary))"
	} };
	if (loading) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		className: "flex h-[50vh] items-center justify-center",
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
			className: "text-muted-foreground",
			children: "Loading dashboard..."
		})
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		className: "space-y-8 animate-fade-in",
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				className: "flex items-center justify-between",
				children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("h1", {
					className: "text-3xl font-bold tracking-tight",
					children: "Dashboard"
				}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					className: "flex items-center gap-2",
					children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
						className: "text-muted-foreground text-sm",
						children: "Overview & Statistics"
					})
				})]
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				className: "grid gap-4 md:grid-cols-2 lg:grid-cols-4",
				children: [
					/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Card, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(CardHeader, {
						className: "flex flex-row items-center justify-between space-y-0 pb-2",
						children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(CardTitle, {
							className: "text-sm font-medium",
							children: "Activity Logs"
						}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Activity, { className: "h-4 w-4 text-muted-foreground" })]
					}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(CardContent, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
						className: "text-2xl font-bold",
						children: stats.uniqueVisitors
					}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
						className: "text-xs text-muted-foreground",
						children: "Total system actions recorded"
					})] })] }),
					/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Card, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(CardHeader, {
						className: "flex flex-row items-center justify-between space-y-0 pb-2",
						children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(CardTitle, {
							className: "text-sm font-medium",
							children: "Library Size"
						}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(BookOpen, { className: "h-4 w-4 text-muted-foreground" })]
					}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(CardContent, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
						className: "text-2xl font-bold",
						children: stats.books
					}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
						className: "text-xs text-muted-foreground",
						children: "Books curated"
					})] })] }),
					/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Card, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(CardHeader, {
						className: "flex flex-row items-center justify-between space-y-0 pb-2",
						children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(CardTitle, {
							className: "text-sm font-medium",
							children: "Music DB"
						}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Music, { className: "h-4 w-4 text-muted-foreground" })]
					}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(CardContent, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
						className: "text-2xl font-bold",
						children: stats.tracks
					}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("p", {
						className: "text-xs text-muted-foreground",
						children: [
							"Tracks across ",
							stats.playlists,
							" playlists"
						]
					})] })] }),
					/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Card, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(CardHeader, {
						className: "flex flex-row items-center justify-between space-y-0 pb-2",
						children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(CardTitle, {
							className: "text-sm font-medium",
							children: "Messages"
						}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(MessageSquare, { className: "h-4 w-4 text-muted-foreground" })]
					}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(CardContent, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
						className: "text-2xl font-bold",
						children: stats.submissions
					}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
						className: "text-xs text-muted-foreground",
						children: "Contact form submissions"
					})] })] })
				]
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				className: "grid gap-4 md:grid-cols-2 lg:grid-cols-7",
				children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Card, {
					className: "col-span-4",
					children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(CardHeader, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(CardTitle, { children: "Content Overview" }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CardDescription, { children: "Distribution of content across the platform." })] }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CardContent, {
						className: "pl-2",
						children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ChartContainer, {
							config: chartConfig,
							className: "h-[300px] w-full",
							children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(BarChart, {
								data: chartData,
								children: [
									/* @__PURE__ */ (0, import_jsx_runtime.jsx)(CartesianGrid, { vertical: false }),
									/* @__PURE__ */ (0, import_jsx_runtime.jsx)(XAxis, {
										dataKey: "name",
										tickLine: false,
										tickMargin: 10,
										axisLine: false
									}),
									/* @__PURE__ */ (0, import_jsx_runtime.jsx)(ChartTooltip, { content: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ChartTooltipContent, {}) }),
									/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Bar, {
										dataKey: "count",
										fill: "var(--color-count)",
										radius: [
											4,
											4,
											0,
											0
										]
									})
								]
							})
						})
					})]
				}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Card, {
					className: "col-span-3",
					children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(CardHeader, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(CardTitle, { children: "Recent Activity" }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CardDescription, { children: "Latest actions and submissions." })] }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CardContent, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
						className: "space-y-8",
						children: recentActivity.length === 0 ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
							className: "text-sm text-muted-foreground",
							children: "No recent activity found."
						}) : recentActivity.map((item) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
							className: "flex items-center",
							children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
								className: "ml-4 space-y-1",
								children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
									className: "text-sm font-medium leading-none",
									children: item.label
								}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
									className: "text-xs text-muted-foreground",
									children: item.type === "submission" ? "Contact Form" : "System Log"
								})]
							}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
								className: "ml-auto font-medium text-xs text-muted-foreground",
								children: new Date(item.created_at).toLocaleDateString()
							})]
						}, item.id))
					}) })]
				})]
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				className: "space-y-4",
				children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("h2", {
					className: "text-xl font-semibold",
					children: "Quick Actions"
				}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
					className: "grid gap-4 md:grid-cols-3",
					children: [
						/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Button, {
							variant: "outline",
							className: "h-24 flex flex-col items-center justify-center gap-2 hover:border-primary/50 transition-colors",
							asChild: true,
							children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Link, {
								to: "/admin/books",
								children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Plus, { className: "h-6 w-6" }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { children: "Add New Book" })]
							})
						}),
						/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Button, {
							variant: "outline",
							className: "h-24 flex flex-col items-center justify-center gap-2 hover:border-primary/50 transition-colors",
							asChild: true,
							children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Link, {
								to: "/admin/music",
								children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Plus, { className: "h-6 w-6" }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { children: "Add New Track" })]
							})
						}),
						/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Button, {
							variant: "outline",
							className: "h-24 flex flex-col items-center justify-center gap-2 hover:border-primary/50 transition-colors",
							asChild: true,
							children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Link, {
								to: "/admin/users",
								children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Users, { className: "h-6 w-6" }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { children: "Manage Users" })]
							})
						})
					]
				})]
			})
		]
	});
}
export { DashboardOverview as default };

//# sourceMappingURL=DashboardOverview-DHWXhVNJ.js.map